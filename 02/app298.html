<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enciclopedia de Artes Marciales</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Fuentes con inspiración asiática/fuerza -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Estilos Adaptados para Artes Marciales --- */
        :root {
            --color-primary: #B91C1C; /* Rojo Intenso */
            --color-secondary: #1F2937; /* Gris Oscuro Casi Negro */
            --color-tertiary: #FBBF24; /* Dorado/Amarillo */
            --color-background: #F9FAFB; /* Gris Muy Claro */
            --color-text: #374151; /* Gris Medio Oscuro (Texto Principal) */
            --color-text-muted: #6B7280; /* Gris Medio (Texto Secundario) */
            --color-modal-bg: #ffffff; /* Blanco */
            --color-border: #D1D5DB; /* Gris Claro (Bordes) */
            --color-locked-bg: #E5E7EB; /* Fondo título bloqueado */
            --color-locked-text: #9CA3AF; /* Texto título bloqueado */
            --color-error-bg: #fde8e8; /* Fondo error rosa pálido */
            --color-error-text: #9b2c2c; /* Texto error rojo oscuro */
            --color-error-border: #fecaca; /* Borde error rojo claro */

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --border-radius: 4px; /* Bordes más rectos */
            --transition-normal: all 0.25s ease-in-out;
        }
        body { font-family: 'Noto Sans JP', sans-serif; background-color: var(--color-background); color: var(--color-text); line-height: 1.7; font-weight: 400; }
        h1, h2, h3, h4, .logo { font-family: 'Orbitron', sans-serif; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .logo { color: var(--color-primary); }
        h1.page-title { color: var(--color-primary); font-weight: 700; }
        h2.section-title { color: var(--color-secondary); border-bottom: 3px solid var(--color-primary); padding-bottom: 0.6rem; display: inline-block; font-weight: 700; }
        #modal-title { color: var(--color-secondary); font-weight: 700; }
        .navbar { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); box-shadow: var(--shadow-md); position: sticky; top: 0; z-index: 20; border-bottom: 1px solid var(--color-border); }

        /* Estilos Buscador (sin cambios mayores) */
        #search-container { margin-bottom: 2.5rem; position: relative; }
        #search-input { width: 100%; padding: 0.8rem 1.1rem 0.8rem 2.8rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); font-size: 1rem; background-color: var(--color-modal-bg); color: var(--color-text); box-shadow: var(--shadow-sm); transition: var(--transition-normal); font-family: 'Noto Sans JP'; }
        #search-input::placeholder { color: var(--color-text-muted); }
        #search-input:focus { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(185, 28, 28, 0.2); outline: none; }
        #search-container .fa-search { position: absolute; left: 0.9rem; top: 50%; transform: translateY(-50%); color: var(--color-text-muted); font-size: 1.1rem; transition: color 0.2s ease; }
        #search-input:focus + .fa-search { color: var(--color-primary); }

        #title-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1.1rem; }
        .title-item { background-color: var(--color-modal-bg); padding: 1rem 1.2rem; border-radius: var(--border-radius); box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition-normal); text-align: left; font-weight: 400; color: var(--color-text); border: 1px solid var(--color-border); display: flex; align-items: center; justify-content: space-between; min-height: 60px; font-family: 'Noto Sans JP'; font-size: 0.98rem; position: relative; overflow: hidden; }
        .title-item::before { /* Pequeño detalle estilo bambú/sello */ content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 5px; background-color: var(--color-primary); opacity: 0; transition: opacity 0.2s ease; }
        .title-item:hover::before { opacity: 1; }
        .title-item:hover { transform: translateX(3px); box-shadow: var(--shadow-md); border-color: var(--color-tertiary); color: var(--color-primary); background-color: #fff; }
        .title-item .title-text { flex-grow: 1; margin-right: 10px; }
        .title-item .lock-icon { color: var(--color-text-muted); font-size: 1.1rem; flex-shrink: 0; }

        /* Estilos para Títulos Bloqueados */
        .title-item.locked { background-color: var(--color-locked-bg); color: var(--color-locked-text); cursor: not-allowed; border-color: #D1D5DB; }
        .title-item.locked:hover { transform: none; box-shadow: var(--shadow-sm); border-color: #D1D5DB; background-color: var(--color-locked-bg); }
        .title-item.locked::before { display: none; }
        .title-item.locked .lock-icon { color: var(--color-primary); /* Candado rojo */ animation: pulse-lock 1.5s infinite ease-in-out; }
        @keyframes pulse-lock { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        /* Botón Generar Más */
        #generate-more-btn { grid-column: 1 / -1; background: linear-gradient(45deg, var(--color-primary), var(--color-secondary)); color: white; padding: 0.9rem 1.8rem; border: none; border-radius: var(--border-radius); font-family: 'Orbitron', sans-serif; font-weight: 400; cursor: pointer; transition: var(--transition-normal); margin-top: 2rem; letter-spacing: 1px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        #generate-more-btn:hover:not(:disabled) { background: linear-gradient(45deg, var(--color-secondary), var(--color-primary)); box-shadow: var(--shadow-lg); transform: scale(1.02); }
        #generate-more-btn:disabled { background: var(--color-text-muted); color: var(--color-background); cursor: not-allowed; opacity: 0.7; transform: none; box-shadow: none; }
        #generate-more-btn .fa-sync-alt { color: white; }

        /* Modal Principal (sin cambios mayores) */
        #story-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(31, 41, 55, 0.88); display: none; align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        #story-modal.active { display: flex; }
        .modal-content-wrapper { background-color: var(--color-modal-bg); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: 1.5rem 2rem; max-width: 950px; width: 95%; max-height: 90vh; min-height: 400px; overflow: hidden; position: relative; box-shadow: var(--shadow-lg); display: flex; flex-direction: column; }
        .modal-close-btn { position: absolute; top: 10px; right: 10px; background: var(--color-border); border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 1.6rem; color: var(--color-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); z-index: 60; }
        .modal-close-btn:hover { background-color: var(--color-primary); color: white; transform: rotate(90deg); }
        #modal-title { font-size: 1.8rem; text-align: center; margin-bottom: 1.2rem; flex-shrink: 0; padding: 0 1rem; line-height: 1.3; }

        /* Área de Contenido Principal (Scrollable) */
        #modal-content-area { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; overflow-y: auto; padding-right: 10px; margin-bottom: 1rem; scrollbar-width: thin; scrollbar-color: var(--color-tertiary) var(--color-border); }
        #modal-content-area::-webkit-scrollbar { width: 8px; }
        #modal-content-area::-webkit-scrollbar-track { background: var(--color-border); border-radius: var(--border-radius); }
        #modal-content-area::-webkit-scrollbar-thumb { background-color: var(--color-tertiary); border-radius: var(--border-radius); border: 1px solid var(--color-border); }

        #modal-content { padding: 0 5px; }
        #modal-content p:not(:last-child) { margin-bottom: 1.4em; }
        #modal-content strong { color: var(--color-primary); font-weight: 700; }
        #modal-content em { color: var(--color-secondary); font-style: italic; font-weight: 300; }
        #modal-content h1, #modal-content h2, #modal-content h3, #modal-content h4 { font-family: 'Orbitron', sans-serif; margin-top: 2em; margin-bottom: 1em; color: var(--color-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 0.4em; font-weight: 400; letter-spacing: 0.5px;}
        #modal-content h1 { font-size: 1.4em; }
        #modal-content h2 { font-size: 1.25em; }
        #modal-content h3 { font-size: 1.15em; color: var(--color-primary); border-bottom: none; }
        #modal-content h4 { font-size: 1.05em; color: var(--color-text-muted); border-bottom: none;}
        /* Imagen Final */
        #modal-content .final-image { display: block; max-width: 75%; height: auto; margin: 2rem auto 1rem auto; border: 1px solid var(--color-border); border-radius: var(--border-radius); box-shadow: var(--shadow-sm); cursor: pointer; transition: transform 0.2s ease; }
        #modal-content .final-image:hover { transform: scale(1.03); box-shadow: var(--shadow-md); }
        #modal-content .image-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 150px; margin: 2rem auto 1rem auto; color: var(--color-text-muted); }
        #modal-content .image-placeholder .spinner { border: 4px solid rgba(209, 213, 219, 0.7); width: 35px; height: 35px; border-radius: 50%; border-left-color: var(--color-primary); animation: spin 1s linear infinite; margin-bottom: 0.5rem; }
        #modal-content .image-placeholder .placeholder-icon { font-size: 2.5rem; color: var(--color-tertiary);}

        /* Chat Section (sin cambios mayores) */
        #chat-section { border-top: 1px solid var(--color-border); padding-top: 1rem; margin-top: 1rem; flex-shrink: 0; display: flex; flex-direction: column; max-height: 250px; }
        #chat-history { flex-grow: 1; overflow-y: auto; margin-bottom: 0.8rem; padding: 0.5rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: rgba(249, 250, 251, 0.6); scroll-behavior: smooth; scrollbar-width: thin; scrollbar-color: var(--color-primary) var(--color-border); }
        #chat-history::-webkit-scrollbar { width: 6px; }
        #chat-history::-webkit-scrollbar-track { background: var(--color-border); border-radius: var(--border-radius); }
        #chat-history::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: var(--border-radius); }
        .chat-message { margin-bottom: 0.6rem; padding: 0.5rem 0.8rem; border-radius: var(--border-radius); max-width: 85%; word-wrap: break-word; line-height: 1.5; font-size: 0.95rem; }
        .user-message { background-color: var(--color-tertiary); color: var(--color-secondary); margin-left: auto; text-align: right; font-weight: 400;}
        .ai-message { background-color: #e5e7eb; color: var(--color-text); margin-right: auto; text-align: left; font-weight: 400; }
        .chat-error { color: var(--color-error-text); font-style: italic; text-align: center; font-size: 0.9em; }
        #chat-input-area { display: flex; gap: 0.5rem; }
        #chat-input { flex-grow: 1; padding: 0.6rem 0.8rem; border: 1px solid var(--color-border); background-color: white; color: var(--color-text); border-radius: var(--border-radius); font-family: 'Noto Sans JP'; font-size: 0.95rem; }
        #chat-input:focus { outline: none; border-color: var(--color-primary); }
        #chat-send-btn { padding: 0.6rem 1rem; background-color: var(--color-secondary); color: white; border: none; border-radius: var(--border-radius); cursor: pointer; transition: background-color 0.2s ease; font-size: 0.9rem; }
        #chat-send-btn:hover:not(:disabled) { background-color: var(--color-primary); }
        #chat-send-btn:disabled { background-color: var(--color-text-muted); cursor: not-allowed; }
        #chat-loading { text-align: center; padding: 0.5rem; font-size: 0.9em; color: var(--color-text-muted); display: none; }
        #chat-loading .fa-spinner { margin-right: 0.5rem; }

        /* Loading Overlay con Puzzle (sin cambios mayores) */
        #modal-loading { text-align: center; padding: 1rem; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.97); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 55; border-radius: var(--border-radius); }
        #modal-loading.active { display: flex; }
        #loading-status { margin-bottom: 1rem; }
        #loading-text { font-weight: 700; color: var(--color-primary); font-size: 1.3rem; font-family: 'Orbitron'; margin-bottom: 0.5rem; }
        #puzzle-score-level { font-weight: 400; color: var(--color-text); font-size: 1rem; font-family: 'Noto Sans JP'; }
        #puzzle-canvas { background-color: #E5E7EB; border: 2px solid var(--color-secondary); border-radius: 4px; display: block; margin-bottom: 1rem; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1); }
        #loading-final-text { font-weight: 400; color: var(--color-text-muted); font-size: 0.9rem; font-family: 'Noto Sans JP'; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .error-msg { background-color: var(--color-error-bg); color: var(--color-error-text); padding: 1.2rem; border-radius: var(--border-radius); border: 1px solid var(--color-error-border); margin-top: 1.5rem; text-align: center; flex-shrink: 0; font-weight: 400; font-family: 'Noto Sans JP'; }
        .error-msg i { margin-right: 0.7rem; }
        .content-hidden { display: none !important; }
        .title-item.hidden { display: none; }

        /* Fullscreen Image Overlay (sin cambios) */
        #image-fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(31, 41, 55, 0.95); display: none; align-items: center; justify-content: center; z-index: 100; padding: 2rem; cursor: zoom-out; }
        #image-fullscreen-overlay.active { display: flex; }
        #fullscreen-image { max-width: 95%; max-height: 95%; object-fit: contain; border: 2px solid var(--color-tertiary); box-shadow: var(--shadow-lg); }
        #fullscreen-close-btn { position: absolute; top: 20px; right: 25px; background: var(--color-modal-bg); border: 1px solid var(--color-tertiary); border-radius: 50%; width: 40px; height: 40px; font-size: 1.8rem; color: var(--color-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); }
        #fullscreen-close-btn:hover { background-color: var(--color-tertiary); color: var(--color-secondary); transform: scale(1.1); }

        /* ---- Nuevo: Modal de Desbloqueo ---- */
        #unlock-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(31, 41, 55, 0.85); /* Overlay oscuro */
            display: none; /* Oculto por defecto */
            align-items: center; justify-content: center;
            z-index: 70; /* Encima del modal principal si estuviera abierto */
            padding: 1rem;
            font-family: 'Noto Sans JP', sans-serif;
        }
        #unlock-modal.active { display: flex; }
        .unlock-modal-content {
            background-color: var(--color-modal-bg);
            padding: 2.5rem 2rem 2rem 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            text-align: center;
            max-width: 450px;
            width: 90%;
            position: relative;
            border: 1px solid var(--color-border);
        }
        .unlock-modal-close-btn {
            position: absolute; top: 10px; right: 10px; background: transparent; border: none;
            font-size: 1.8rem; color: var(--color-text-muted); cursor: pointer;
            line-height: 1; transition: color 0.2s ease;
        }
        .unlock-modal-close-btn:hover { color: var(--color-primary); }
        #unlock-modal h3 {
            font-family: 'Orbitron', sans-serif; color: var(--color-primary);
            font-size: 1.6rem; margin-bottom: 1rem;
        }
        #unlock-modal p { color: var(--color-text); margin-bottom: 1.5rem; line-height: 1.6; font-size: 1rem; }
        #unlock-ad-button {
            background-color: var(--color-primary); color: white;
            padding: 0.8rem 2rem; border: none; border-radius: var(--border-radius);
            font-family: 'Orbitron', sans-serif; font-size: 1.1rem;
            cursor: pointer; transition: var(--transition-normal);
            margin-bottom: 1.5rem; display: inline-block;
            box-shadow: var(--shadow-md);
        }
        #unlock-ad-button:hover:not(:disabled) { background-color: #991B1B; /* Rojo más oscuro */ box-shadow: var(--shadow-lg); transform: translateY(-2px); }
        #unlock-ad-button:disabled { background-color: var(--color-text-muted); cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none;}
        #unlock-countdown {
            font-size: 1.8rem; font-weight: 700; color: var(--color-secondary);
            font-family: 'Orbitron', sans-serif;
            min-height: 30px; /* Espacio para el número */
        }
        #unlock-status {
             font-size: 0.9rem; color: var(--color-text-muted); margin-top: 0.5rem;
        }

    </style>
</head>
<body>
     <!-- Header/Navbar -->
     <nav class="navbar mb-10">
         <div class="container mx-auto px-4 py-4 flex flex-col sm:flex-row justify-between items-center">
             <div class="flex items-center text-center mb-3 sm:mb-0">
                  <h1 class="logo text-3xl sm:text-4xl">
                      <i class="fas fa-fist-raised mr-3 text-red-700"></i> <!-- Puño levantado -->
                     Artes Marciales
                 </h1>
             </div>
             <span class="text-sm text-gray-600 font-sans tracking-wider uppercase">» El Camino del Guerrero «</span>
         </div>
     </nav>

     <!-- Main content -->
     <main class="container mx-auto px-4 pb-16">
         <!-- Hero section -->
         <section class="mb-12 text-center">
             <h1 class="page-title text-5xl sm:text-6xl mb-5">Domina el Conocimiento</h1>
             <p class="text-xl text-gray-700 mb-8 max-w-3xl mx-auto font-light">Explora la historia, técnicas y filosofía de diversas artes marciales. Elige una disciplina o busca para iniciar tu entrenamiento.</p>
         </section>

         <!-- Search Bar -->
         <section id="search-container" class="mb-10 max-w-2xl mx-auto">
             <input type="text" id="search-input" placeholder="Buscar arte marcial, técnica, maestro...">
             <i class="fas fa-search"></i>
         </section>

         <!-- Title List Container -->
         <section class="mb-10">
             <h2 class="section-title text-3xl sm:text-4xl mb-8 text-center mx-auto">
                 <i class="fas fa-torii-gate text-red-700 mr-2"></i> <!-- Puerta Torii -->
                 Dojos de Sabiduría
             </h2>
             <div id="title-list">
                  <p id="titles-loading" class="text-gray-500 col-span-full text-center text-lg font-sans">Preparando el tatami...</p>
                  <!-- Los .title-item se añadirán aquí -->
             </div>
             <p id="no-results" class="text-gray-500 col-span-full text-center text-lg mt-4 hidden font-sans">» No se encontraron katas para esa búsqueda «</p>
             <div id="generate-more-container" class="text-center mt-8">
                 <button id="generate-more-btn">
                      <i class="fas fa-sync-alt mr-2 animate-spin hidden"></i>
                     Descubrir Más Disciplinas (40)
                  </button>
             </div>
         </section>
     </main>

     <!-- Explanation Modal (Principal) -->
     <div id="story-modal">
         <div class="modal-content-wrapper">
             <button class="modal-close-btn" id="modal-close" aria-label="Cerrar">&times;</button>
             <!-- Loading Overlay con Puzzle -->
             <div id="modal-loading">
                 <div id="loading-status">
                     <p id="loading-text">Concentrando Energía (Ki)...</p>
                     <p id="puzzle-score-level">Nivel: 1 | Puntos: 0 / 1000</p>
                 </div>
                 <canvas id="puzzle-canvas" width="300" height="300"></canvas> <!-- Puzzle temático -->
                 <p id="loading-final-text">Mientras esperas, alinea los símbolos marciales.</p>
             </div>
             <!-- Content Area Wrapper -->
             <div id="modal-story-content-area" class="content-hidden flex flex-col flex-grow min-h-0">
                 <!-- Scrollable Text Area -->
                 <div id="modal-content-area">
                     <h2 id="modal-title" class="text-xl md:text-2xl font-bold mb-4 text-center flex-shrink-0"></h2>
                     <div id="modal-content"></div>
                 </div>
                 <!-- Chat Section -->
                 <div id="chat-section">
                     <div id="chat-history"></div>
                     <div id="chat-loading"><i class="fas fa-spinner fa-spin"></i> Consultando al Sensei...</div>
                     <div id="chat-input-area">
                         <input type="text" id="chat-input" placeholder="Pregunta más sobre esta disciplina...">
                         <button id="chat-send-btn" aria-label="Enviar Consulta"><i class="fas fa-paper-plane"></i></button>
                     </div>
                 </div>
                 <!-- Error Display Area -->
                 <div id="modal-error" class="error-msg content-hidden mt-4 flex-shrink-0">
                     <i class="fas fa-exclamation-triangle"></i>
                     <span id="modal-error-message"></span>
                 </div>
             </div>
         </div>
     </div>

      <!-- Nuevo: Unlock Modal -->
      <div id="unlock-modal">
          <div class="unlock-modal-content">
              <button class="unlock-modal-close-btn" id="unlock-modal-close" aria-label="Cerrar">&times;</button>
              <h3><i class="fas fa-lock mr-2"></i> Contenido Bloqueado</h3>
              <p>Para acceder a este conocimiento, haz clic en el botón "ANUNCIO" y espera 5 segundos mientras se valida tu acceso.</p>
              <button id="unlock-ad-button">
                  <i class="fas fa-ad mr-2"></i> ANUNCIO
              </button>
              <div id="unlock-countdown"></div>
              <div id="unlock-status"></div>
              <input type="hidden" id="unlock-target-title" value=""> <!-- Guardar el título a desbloquear -->
          </div>
      </div>

      <!-- Fullscreen Image Overlay (sin cambios) -->
      <div id="image-fullscreen-overlay">
          <button id="fullscreen-close-btn" aria-label="Cerrar Imagen">&times;</button>
          <img id="fullscreen-image" src="" alt="Imagen Ampliada">
      </div>

      <!-- Footer -->
      <footer class="bg-gray-800 text-gray-400 py-6 mt-12 border-t border-gray-700 font-sans">
          <div class="container mx-auto px-4 text-center text-sm">
              <p>Información sobre artes marciales generada por IA, inspirada en fuentes históricas y técnicas.</p>
              <p class="mt-1">Consulta siempre a instructores cualificados y fuentes académicas para un estudio profundo.</p>
              <p class="mt-2">© 2025 Dojo Digital</p>
          </div>
      </footer>

    <script>
        // ========== CONFIG & DATA ==========
        const adUrl = 'https://increasingbelieveabonnement.com/pcmu77j4?key=1f38fa224b5ecf757563a32d2d8ac126';
        const unlockCountdownSeconds = 5;
        const lockPercentage = 0.7; // 70%
        const localStorageKey = 'unlockedTitles_MartialArts'; // Key específica para este tema

        const predefinedTitles = [
            // Artes Japonesas
            "Karate-Do: Origen y Filosofía", "Shotokan Karate: Historia y Katas Principales", "Goju-Ryu Karate: Técnicas de Respiración y Combate Cercano", "Wado-Ryu Karate: Armonía y Movimiento", "Kyokushin Karate: Full Contact y Espíritu Indomable", "Judo: El Camino de la Gentileza (Ju-no-michi)", "Aikido: El Arte de la Paz y la Armonización (Ki)", "Jujutsu (Jiu-Jitsu Japonés): Orígenes y Técnicas de Autodefensa", "Kendo: El Camino de la Espada (Esgrima Japonesa)", "Iaido: El Arte de Desenvainar la Katana", "Ninjutsu: Historia y Mitos de los Shinobi", "Sumo: Lucha Ritual y Tradición Japonesa", "Shorinji Kempo: Unidad de Espíritu y Técnica",
            // Artes Chinas (Kung Fu / Wushu)
            "Kung Fu (Wushu): Términos Generales y Diversidad", "Shaolin Kung Fu: Orígenes Monásticos y Estilos", "Wing Chun: Economía de Movimiento y Línea Central", "Tai Chi Chuan (Taijiquan): Meditación en Movimiento y Salud", "Baguazhang: Caminar en Círculo y Cambios Constantes", "Xing Yi Quan: Mente, Intención y Poder Explosivo", "Hung Gar: Posturas Bajas y Técnicas de Tigre y Grulla", "Choy Li Fut: Combinación de Estilos del Norte y Sur", "Sanda (Sanshou): Combate Deportivo Chino", "Wushu Moderno: Formas de Exhibición y Competencia",
            // Artes Coreanas
            "Taekwondo: El Camino del Puño y la Patada", "Hapkido: Defensa Personal Integral Coreana", "Tang Soo Do: El Camino de la Mano China", "Kuk Sool Won: Sistema Marcial Coreano Tradicional", "Taekkyeon: Arte Marcial Coreano Antiguo (Patadas fluidas)",
            // Artes del Sudeste Asiático
            "Muay Thai (Boxeo Tailandés): El Arte de las Ocho Extremidades", "Silat (Pencak Silat): Artes Marciales de Indonesia y Malasia", "Eskrima (Arnis/Kali): Artes Marciales Filipinas con Armas", "Lethwei: Boxeo Birmano (con cabezazos)", "Vovinam: Arte Marcial Vietnamita Moderno",
            // Artes Occidentales y Modernas
            "Boxeo Occidental: Historia y Técnicas", "Lucha Libre (Wrestling): Greco-Romana y Estilo Libre", "Esgrima Histórica Europea (HEMA): Reconstrucción de Técnicas Medievales", "Savate (Boxeo Francés): Elegancia y Patadas", "Krav Maga: Sistema de Defensa Personal Israelí", "Systema: Arte Marcial Ruso Enfocado en la Respiración y Relajación", "Jeet Kune Do (JKD): La Filosofía de Bruce Lee", "Brazilian Jiu-Jitsu (BJJ): Lucha en el Suelo y Sumisiones", "Kickboxing (Americano/Japonés): Fusión de Técnicas", "MMA (Artes Marciales Mixtas): El Deporte Moderno",
            // Conceptos y Filosofía
            "Ki (Chi/Qi): Concepto de Energía Vital", "Dojo Kun: Código Ético del Lugar de Entrenamiento", "Budo: El Camino Marcial Japonés (Filosofía)", "Kata / Poomsae / Forma: Secuencias de Movimientos", "Randori / Sparring: Práctica Libre de Combate", "Mokuso: Meditación Zen en las Artes Marciales", "Zanshin: Estado de Alerta y Conciencia", "Kime: Enfoque de la Energía en un Punto", "Maai: Distancia de Combate Correcta", "Sen (Sensibilidad/Iniciativa): Anticipación en Combate", "Mushin: Mente sin Mente (Estado de Fluidez)", "Fudoshin: Mente Imperturbable", "Bushido: El Código del Samurai (Influencia)", "Los Cinco Anillos de Miyamoto Musashi", "El Arte de la Guerra de Sun Tzu (Aplicación Marcial)", "Yin y Yang en las Artes Marciales", "Los Cinco Elementos (Wu Xing) en el Kung Fu", "Respeto y Etiqueta en el Dojo", "El Rol del Sensei / Sifu / Maestro", "Graduaciones y Cinturones: Sistema de Rangos",
            // Figuras Históricas
            "Gichin Funakoshi: Padre del Karate Moderno", "Jigoro Kano: Fundador del Judo", "Morihei Ueshiba: Fundador del Aikido", "Mas Oyama: Fundador del Kyokushin Karate", "Bruce Lee: Ícono Marcial y Fundador del JKD", "Ip Man (Yip Man): Maestro de Wing Chun", "Helio Gracie: Pilar del Brazilian Jiu-Jitsu", "Choi Yong-Sool: Fundador del Hapkido", "Bodhidharma (Daruma): Figura Legendaria (Shaolin)", "Miyamoto Musashi: El Samurai Legendario",
            // Técnicas y Entrenamiento
            "Tipos de Golpes de Puño (Tsuki, Chuan)", "Tipos de Patadas (Geri, Ti)", "Bloqueos y Defensas (Uke, Fang)", "Proyecciones y Derribos (Nage Waza, Shuai Jiao)", "Llaves y Luxaciones (Kansetsu Waza, Qin Na)", "Estrangulaciones (Shime Waza)", "Combate en el Suelo (Ne Waza, Grappling)", "Uso de Armas Tradicionales (Kobudo, Bingqi)", "Entrenamiento de Endurecimiento (Kote Kitae, Iron Palm)", "Ejercicios de Respiración (Kokyu Ho, Qigong)", "Flexibilidad y Acondicionamiento Físico", "Entrenamiento Mental y Visualización", "Técnicas de Caída (Ukemi)", "Puntos Vitales (Kyusho, Dim Mak)",
            // ... (Añadir más para llegar a 400+, cubriendo estilos menos conocidos, armas específicas, historia regional, etc.)
            "Niten Ichi-ryu: La Escuela de Musashi", "Yoseikan Budo: Síntesis Marcial", "Capoeira: Danza y Lucha Afro-Brasileña", "Daitō-ryū Aiki-jūjutsu: Precursor del Aikido", "Bartitsu: Arte Marcial Victoriano", "Combatives (Defensa Personal Militar)", "Bokator: Arte Marcial Camboyano Antiguo", "Kalaripayattu: Arte Marcial Indio Antiguo", "Hwa Rang Do: Arte Marcial Coreano Comprensivo", "Shuri-ryu Karate", "Uechi-ryu Karate", "Isshin-ryu Karate", "Motobu-ryu Karate", "Chito-ryu Karate", "Kobudo de Okinawa: Armas Tradicionales", "Bo (Bastón Largo)", "Sai (Daga Tridente)", "Tonfa (Mango de Molino)", "Nunchaku (Mayal)", "Kama (Hoz)", "Eku (Remo)", "Jian (Espada Recta China)", "Dao (Sable Chino)", "Gun (Bastón Chino)", "Qiang (Lanza China)", "Nandao (Sable del Sur)", "Katana: Alma del Samurai", "Wakizashi: Espada Corta Samurai", "Tanto: Daga Japonesa", "Yari (Lanza Japonesa)", "Naginata (Alabarda Japonesa)", "Kyudo: Arquería Japonesa", "Shurikenjutsu: Lanzamiento de Hojas", "Filosofía Zen y Artes Marciales", "Confucianismo y Artes Marciales", "Taoísmo y Artes Marciales", "La Mujer en las Artes Marciales: Historia", "Artes Marciales y Cine", "Artes Marciales en la Cultura Pop", "Beneficios Físicos de las Artes Marciales", "Beneficios Mentales y Emocionales", "Artes Marciales para Niños", "Artes Marciales para la Tercera Edad", "Competiciones de Artes Marciales: Formatos", "Organizaciones Mundiales (WKF, IJF, WTF)", "Diferencias entre Estilos Duros y Suaves", "Concepto de Centro (Hara/Tanden/Dantian)", "Uso de la Cadera en la Generación de Potencia", "Técnicas de Evasión (Tai Sabaki)", "Guardias de Combate (Kamae)", "Gritos (Kiai / Hasheng)", "Puntos de Presión en Combate", "Primeros Auxilios en el Dojo", "Nutrición para Artistas Marciales", "Prevención de Lesiones", "Historia del MMA", "Reglas Unificadas del MMA", "Grandes Campeones de MMA", "Impacto Cultural del BJJ", "El Debate: Arte Marcial Tradicional vs. Moderno" // etc.
        ];
        const martialArtsThemes = [
            "karate", "judo", "aikido", "kung fu", "taekwondo", "jiu-jitsu", "muay thai", "kendo", "ninjutsu", "filosofía marcial", "historia artes marciales", "técnicas de defensa", "entrenamiento marcial", "maestros marciales", "armas tradicionales", "combate deportivo", "energía Ki/Chi", "kata/formas", "meditación marcial", "artes marciales mixtas", "defensa personal", "cultura samurai", "monjes Shaolin", "estilos animales kung fu", "taichi"
        ];
        const textApiConfig = {
            model: "mistral",
            systemPrompt: "Eres un Sensei digital, un experto enciclopédico y respetado en todas las formas de artes marciales del mundo. Tu conocimiento abarca historia, filosofía, técnicas, figuras clave, estilos y conceptos de disciplinas desde Japón, China, Corea, Sudeste Asiático hasta Occidente. Proporciona una explicación detallada, precisa y respetuosa sobre el tema marcial consultado. Incluye contexto histórico, principios fundamentales, técnicas representativas (si aplica), filosofía subyacente y figuras relevantes. Usa terminología adecuada (explicándola si es necesario). El objetivo es una exposición clara y completa de aproximadamente 1200-1300 palabras. Responde a la consulta sobre:",
            timeoutSeconds: 180
        };
        const chatApiConfig = {
            model: "mistral-tiny",
            systemPrompt: "Actúa como un asistente del Sensei, respondiendo preguntas específicas sobre el arte marcial o concepto previamente explicado. Céntrate en clarificar detalles, explicar términos o comparar aspectos mencionados en la descripción principal. Sé conciso, preciso y mantén el respeto y la terminología del tema marcial en cuestión.",
            timeoutSeconds: 45
        };
        const titleGenerationConfig = {
            model: "mistral",
            systemPrompt: "Genera una lista concisa de 40 temas específicos y variados sobre artes marciales globales (disciplinas, técnicas, conceptos, historia, armas, filosofía). Devuelve *solo* la lista de ítems, uno por línea. Sin números, guiones, introducciones ni despedidas.",
            timeoutSeconds: 60
        };
        // Puzzle Colors/Symbols (Ejemplo temático)
        const puzzleColors = ['#B91C1C', '#1F2937', '#FBBF24', '#4B5563', '#6EE7B7', '#FFFFFF']; // Rojo, Negro, Dorado, Gris, Verde Bambú, Blanco
        const puzzleSymbols = ['<i class="fas fa-fist-raised"></i>', '<i class="fas fa-yin-yang"></i>', '<i class="fas fa-khanda"></i>', '<i class="fas fa-torii-gate"></i>', '<i class="fas fa-feather-alt"></i>', '<i class="fas fa-shield-alt"></i>']; // Puño, YinYang, Khanda(espadas), Torii, Pluma(ligereza), Escudo(defensa) - Usar FA

        // ========== DOM ELEMENTS ==========
        const searchInput = document.getElementById('search-input');
        const titleListContainer = document.getElementById('title-list');
        const titlesLoading = document.getElementById('titles-loading');
        const noResultsMsg = document.getElementById('no-results');
        const generateMoreContainer = document.getElementById('generate-more-container');
        const generateMoreBtn = document.getElementById('generate-more-btn');
        const generateMoreSpinner = generateMoreBtn.querySelector('i');
        // Modal Principal
        const storyModal = document.getElementById('story-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const modalLoadingIndicator = document.getElementById('modal-loading');
        const modalStoryContentArea = document.getElementById('modal-story-content-area');
        const modalTextArea = document.getElementById('modal-content-area');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalError = document.getElementById('modal-error');
        const modalErrorMessage = document.getElementById('modal-error-message');
        // Chat Elements
        const chatSection = document.getElementById('chat-section');
        const chatHistory = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatLoadingIndicator = document.getElementById('chat-loading');
        // Fullscreen Image Elements
        const imageFullscreenOverlay = document.getElementById('image-fullscreen-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
        // Puzzle Elements
        const puzzleCanvas = document.getElementById('puzzle-canvas');
        const loadingText = document.getElementById('loading-text');
        const puzzleScoreLevelText = document.getElementById('puzzle-score-level');
        // Unlock Modal Elements
        const unlockModal = document.getElementById('unlock-modal');
        const unlockModalCloseBtn = document.getElementById('unlock-modal-close');
        const unlockAdButton = document.getElementById('unlock-ad-button');
        const unlockCountdownDisplay = document.getElementById('unlock-countdown');
        const unlockStatusDisplay = document.getElementById('unlock-status');
        const unlockTargetTitleInput = document.getElementById('unlock-target-title');


        // ========== PUZZLE GAME LOGIC ========== (Adaptado a nuevos colores/iconos)
        const PuzzleGame = {
            // ... (resto de la lógica del PuzzleGame como en el ejemplo anterior) ...
            tileColors: puzzleColors, // Usar colores temáticos
            tileSymbols: puzzleSymbols, // Usar iconos temáticos

            init(canvasElement, scoreLevelElement) {
                this.canvas = canvasElement;
                 if (!this.canvas) { console.error("Puzzle canvas not found!"); return; }
                 this.ctx = this.canvas.getContext('2d');
                 this.canvas.width = this.gridSize * this.tileSize;
                 this.canvas.height = this.gridSize * this.tileSize;
                 this.scoreLevelElement = scoreLevelElement;
                 this.canvas.addEventListener('click', this.handleClick.bind(this));
                 console.log("Puzzle Initialized");
            },

            // --- Función draw adaptada para los nuevos iconos ---
             draw() {
                 this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                 for (let r = 0; r < this.gridSize; r++) {
                     for (let c = 0; c < this.gridSize; c++) {
                         if (this.tiles[r][c] !== null) {
                             const x = c * this.tileSize;
                             const y = r * this.tileSize;
                             const tileType = this.tiles[r][c];

                             this.ctx.fillStyle = this.tileColors[tileType];
                             this.ctx.fillRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);
                             this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                             this.ctx.strokeRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);

                             this.ctx.font = `${this.tileSize * 0.6}px "Font Awesome 6 Free"`;
                              // Ajustar color de icono para que contraste (ej. negro sobre blanco)
                             this.ctx.fillStyle = (this.tileColors[tileType] === '#FFFFFF') ? '#000000' : '#FFFFFF';
                             this.ctx.textAlign = 'center';
                             this.ctx.textBaseline = 'middle';

                             let symbolChar = '?';
                             switch(this.tileSymbols[tileType]) {
                                 case '<i class="fas fa-fist-raised"></i>': symbolChar = '\uf6de'; break; // Fist
                                 case '<i class="fas fa-yin-yang"></i>': symbolChar = '\uf6ad'; break; // Yin Yang
                                 case '<i class="fas fa-khanda"></i>': symbolChar = '\uf66d'; break; // Khanda (similar a espadas cruzadas)
                                 case '<i class="fas fa-torii-gate"></i>': symbolChar = '\uf6a1'; break; // Torii Gate
                                 case '<i class="fas fa-feather-alt"></i>': symbolChar = '\uf5ab'; break; // Feather (ligereza)
                                 case '<i class="fas fa-shield-alt"></i>': symbolChar = '\uf3ed'; break; // Shield (defensa)
                             }
                             this.ctx.fillText(symbolChar, x + this.tileSize / 2, y + this.tileSize / 2 + 2);

                            if (this.selectedTile && this.selectedTile.r === r && this.selectedTile.c === c) {
                                this.ctx.strokeStyle = '#FFFF00'; // Yellow highlight
                                this.ctx.lineWidth = 3;
                                this.ctx.strokeRect(x + 1, y + 1, this.tileSize - 2, this.tileSize - 2);
                                this.ctx.lineWidth = 1;
                             }
                         }
                     }
                 }
             },
             // ... (resto de funciones: start, stop, gameLoop, update, initBoard, etc., SIN CAMBIOS LÓGICOS)
             // Mantener las funciones: handleClick, attemptSwap, checkForMatchesAfterSwap, findAndClearMatches, dropTiles, updateScoreLevelDisplay, getRandomTileType, checkForInitialMatches
             // --- COPIAR EL RESTO DE FUNCIONES DEL PUZZLE DESDE EL EJEMPLO ANTERIOR ---
             // (Por brevedad, no se repiten aquí, pero deben estar presentes)
             canvas: null, ctx: null, gridSize: 8, tileSize: 36, tiles: [], tileTypes: 6,
             selectedTile: null, isSwapping: false, isDropping: false, score: 0, level: 1,
             pointsPerLevel: 1000, gameLoopInterval: null, isRunning: false, lastFrameTime: 0,
             comboMultiplier: 1, scoreLevelElement: null,
            start() { if (this.isRunning) return; console.log("Starting Puzzle Game"); this.isRunning = true; this.score = 0; this.level = 1; this.comboMultiplier = 1; this.selectedTile = null; this.isSwapping = false; this.isDropping = false; this.updateScoreLevelDisplay(); this.initBoard(); while(this.findAndClearMatches()){ this.dropTiles(); } this.lastFrameTime = performance.now(); this.gameLoopInterval = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if (!this.isRunning) return; console.log("Stopping Puzzle Game"); this.isRunning = false; if (this.gameLoopInterval) { cancelAnimationFrame(this.gameLoopInterval); this.gameLoopInterval = null; } if(this.ctx) this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); },
            gameLoop(currentTime) { if (!this.isRunning) return; const deltaTime = (currentTime - this.lastFrameTime) / 1000; this.lastFrameTime = currentTime; this.update(deltaTime); this.draw(); this.gameLoopInterval = requestAnimationFrame(this.gameLoop.bind(this)); },
            update(deltaTime) { if (this.isSwapping || this.isDropping) {} else { if (this.findAndClearMatches()) { this.isDropping = true; this.dropTiles(); this.isDropping = false; this.comboMultiplier++; } else { this.comboMultiplier = 1; } } if (this.score >= this.level * this.pointsPerLevel) { this.level++; console.log("Level Up! Reached Level", this.level); this.updateScoreLevelDisplay(); } },
            initBoard() { this.tiles = []; for (let r = 0; r < this.gridSize; r++) { this.tiles[r] = []; for (let c = 0; c < this.gridSize; c++) { this.tiles[r][c] = this.getRandomTileType(); } } while (this.checkForInitialMatches()) { for (let r = 0; r < this.gridSize; r++) { for (let c = 0; c < this.gridSize; c++) { this.tiles[r][c] = this.getRandomTileType(); } } } console.log("Board Initialized"); },
            checkForInitialMatches() { for (let r = 0; r < this.gridSize; r++) { for (let c = 0; c < this.gridSize; c++) { if (c < this.gridSize - 2 && this.tiles[r][c] === this.tiles[r][c+1] && this.tiles[r][c] === this.tiles[r][c+2]) return true; if (r < this.gridSize - 2 && this.tiles[r][c] === this.tiles[r+1][c] && this.tiles[r][c] === this.tiles[r+2][c]) return true; } } return false; },
            getRandomTileType() { return Math.floor(Math.random() * this.tileTypes); },
            handleClick(event) { if (!this.isRunning || this.isSwapping || this.isDropping) return; const rect = this.canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const c = Math.floor(x / this.tileSize); const r = Math.floor(y / this.tileSize); if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) return; if (!this.selectedTile) { this.selectedTile = { r, c }; console.log("Selected:", r, c); } else { const dr = Math.abs(r - this.selectedTile.r); const dc = Math.abs(c - this.selectedTile.c); if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) { this.attemptSwap(this.selectedTile.r, this.selectedTile.c, r, c); } else { if(this.selectedTile.r === r && this.selectedTile.c === c) { this.selectedTile = null; } else { this.selectedTile = { r, c }; console.log("Selected new:", r, c); } } } this.draw(); },
            attemptSwap(r1, c1, r2, c2) { this.isSwapping = true; [this.tiles[r1][c1], this.tiles[r2][c2]] = [this.tiles[r2][c2], this.tiles[r1][c1]]; const matchFound = this.checkForMatchesAfterSwap(r1, c1) || this.checkForMatchesAfterSwap(r2, c2); if (matchFound) { console.log("Valid Swap - Match found!"); this.findAndClearMatches(); this.dropTiles(); this.selectedTile = null; this.isSwapping = false; } else { console.log("Invalid Swap - No match"); [this.tiles[r1][c1], this.tiles[r2][c2]] = [this.tiles[r2][c2], this.tiles[r1][c1]]; this.selectedTile = null; this.isSwapping = false; } this.draw(); },
            checkForMatchesAfterSwap(r, c) { const tileType = this.tiles[r][c]; if (tileType === null) return false; let hMatch = [{r,c}]; for (let i = c - 1; i >= 0 && this.tiles[r][i] === tileType; i--) hMatch.push({r, c:i}); for (let i = c + 1; i < this.gridSize && this.tiles[r][i] === tileType; i++) hMatch.push({r, c:i}); let vMatch = [{r,c}]; for (let i = r - 1; i >= 0 && this.tiles[i][c] === tileType; i--) vMatch.push({r:i, c}); for (let i = r + 1; i < this.gridSize && this.tiles[i][c] === tileType; i++) vMatch.push({r:i, c}); return hMatch.length >= 3 || vMatch.length >= 3; },
            findAndClearMatches() { let matchesFound = false; let tilesToClear = []; for (let r = 0; r < this.gridSize; r++) { for (let c = 0; c < this.gridSize - 2; c++) { if (this.tiles[r][c] !== null && this.tiles[r][c] === this.tiles[r][c+1] && this.tiles[r][c] === this.tiles[r][c+2]) { matchesFound = true; let length = 3; while (c + length < this.gridSize && this.tiles[r][c] === this.tiles[r][c+length]) length++; for (let i = 0; i < length; i++) tilesToClear.push({ r: r, c: c + i }); c += length - 1; } } } for (let c = 0; c < this.gridSize; c++) { for (let r = 0; r < this.gridSize - 2; r++) { if (this.tiles[r][c] !== null && this.tiles[r][c] === this.tiles[r+1][c] && this.tiles[r][c] === this.tiles[r+2][c]) { matchesFound = true; let length = 3; while (r + length < this.gridSize && this.tiles[r][c] === this.tiles[r+length][c]) length++; for (let i = 0; i < length; i++) { if (!tilesToClear.some(t => t.r === r + i && t.c === c)) tilesToClear.push({ r: r + i, c: c }); } r += length - 1; } } } if (matchesFound) { let pointsEarned = 0; tilesToClear.forEach(tilePos => { if (this.tiles[tilePos.r][tilePos.c] !== null) { this.tiles[tilePos.r][tilePos.c] = null; pointsEarned += 10; } }); this.score += pointsEarned * this.comboMultiplier; this.updateScoreLevelDisplay(); console.log(`Cleared ${tilesToClear.length} tiles. Score: ${this.score} (Combo x${this.comboMultiplier})`); } return matchesFound; },
            dropTiles() { this.isDropping = true; for (let c = 0; c < this.gridSize; c++) { let emptyRow = this.gridSize - 1; for (let r = this.gridSize - 1; r >= 0; r--) { if (this.tiles[r][c] !== null) { if (r !== emptyRow) { this.tiles[emptyRow][c] = this.tiles[r][c]; this.tiles[r][c] = null; } emptyRow--; } } for (let r = emptyRow; r >= 0; r--) { this.tiles[r][c] = this.getRandomTileType(); } } this.isDropping = false; },
            updateScoreLevelDisplay() { if(this.scoreLevelElement) { this.scoreLevelElement.textContent = `Nivel: ${this.level} | Puntos: ${this.score} / ${this.level * this.pointsPerLevel}`; } }
        };


        // ========== State Variables ==========
        let currentTopicTitle = null;
        let initialLockedTitles = new Set(); // Títulos bloqueados al inicio
        let countdownInterval = null; // Para el temporizador de desbloqueo


        // ========== LocalStorage Functions (Unlock Persistence) ==========
        function getUnlockedTitles() {
            try {
                const stored = localStorage.getItem(localStorageKey);
                return stored ? new Set(JSON.parse(stored)) : new Set();
            } catch (e) {
                console.error("Error reading unlocked titles from localStorage:", e);
                return new Set(); // Fallback to empty set
            }
        }
        function saveUnlockedTitles(unlockedSet) {
            try {
                localStorage.setItem(localStorageKey, JSON.stringify(Array.from(unlockedSet)));
            } catch (e) {
                console.error("Error saving unlocked titles to localStorage:", e);
            }
        }
        function isTitleUnlocked(title) {
            return getUnlockedTitles().has(title);
        }
        function unlockTitlePermanently(title) {
            if (!title) return;
            const unlocked = getUnlockedTitles();
            if (!unlocked.has(title)) {
                unlocked.add(title);
                saveUnlockedTitles(unlocked);
                console.log(`Title permanently unlocked: ${title}`);
                // Update UI immediately for the specific title item
                const titleItem = titleListContainer.querySelector(`.title-item[data-title="${CSS.escape(title)}"]`);
                if (titleItem) {
                    titleItem.classList.remove('locked');
                    titleItem.dataset.locked = 'false'; // Mark as unlocked in data attribute
                    const lockIcon = titleItem.querySelector('.lock-icon');
                    if (lockIcon) lockIcon.remove(); // Remove lock icon
                    titleItem.style.cursor = 'pointer'; // Restore cursor
                }
            }
        }

        // ========== API FUNCTIONS ==========
        // fetchTextFromApi (sin cambios lógicos, solo prompt actualizado)
        async function fetchTextFromApi(prompt, config, isChat = false) {
            const encodedPrompt = encodeURIComponent(prompt);
             const systemPromptToUse = isChat && currentTopicTitle
                 ? `Actúa como un asistente del Sensei, respondiendo preguntas específicas sobre '${currentTopicTitle}'. Céntrate en clarificar detalles, explicar términos o comparar aspectos mencionados en la descripción principal. Sé conciso, preciso y mantén el respeto y la terminología del tema marcial.`
                 : config.systemPrompt;
             const encodedSystem = encodeURIComponent(systemPromptToUse);

             const params = new URLSearchParams({ model: config.model, system: encodedSystem });
             // No seed for chat to allow conversational flow
             if (config.seed && !isChat) params.append('seed', config.seed);
             const url = `https://text.pollinations.ai/${encodedPrompt}?${params.toString()}`;
             console.log(`Fetching text from API (${config.model}, Chat: ${isChat}): ${url.substring(0, 200)}...`);

             const controller = new AbortController();
             const timeoutId = setTimeout(() => controller.abort(), config.timeoutSeconds * 1000);

             try {
                 const response = await fetch(url, { signal: controller.signal });
                 clearTimeout(timeoutId);
                 if (!response.ok) throw new Error(`(Error ${response.status}) Nuestros servidores Dojo tienen mucho tráfico. Intenta de nuevo en unos segundos, guerrero.`);
                 const text = await response.text();
                 if (!text || text.trim().length === 0) throw new Error("La respuesta de la IA llegó vacía. El Ki debe haberse disipado. Intenta de nuevo.");
                 console.log(`API Response received (${text.length} chars)`);
                 return text;
             } catch (error) {
                 clearTimeout(timeoutId);
                 console.error("API Fetch Error:", error);
                 if (error.name === 'AbortError') throw new Error(`La consulta tardó demasiado (>${config.timeoutSeconds}s). La conexión es lenta o el Sensei está meditando profundamente. Inténtalo de nuevo.`);
                 throw new Error(error.message || "Ocurrió un error inesperado contactando a los maestros digitales.");
             }
        }
        async function fetchExplanationText(conceptTitle) { return fetchTextFromApi(conceptTitle, textApiConfig, false); }
        async function fetchChatResponse(userQuery) { if (!currentTopicTitle) throw new Error("Error interno: Contexto del Dojo no establecido."); return fetchTextFromApi(userQuery, chatApiConfig, true); }
        async function fetchGeneratedTitles() { // (sin cambios lógicos)
             const randomTheme = getRandomElement(martialArtsThemes) || "artes marciales variadas";
             const specificPrompt = `Genera 40 ítems específicos sobre ${randomTheme}`;
             const configForThisRequest = { ...titleGenerationConfig, seed: Math.floor(Math.random() * 1000000) };
             return fetchTextFromApi(specificPrompt, configForThisRequest, false)
                 .then(text => {
                     const titles = text.split('\n').map(line => line.replace(/^[-\d.\s*]+/, '').trim()).filter(line => line.length > 5 && line.length < 150);
                     if (titles.length < 10) throw new Error("La IA no generó suficientes ideas de disciplinas.");
                     return titles.slice(0, 40);
                 });
        }
        // createPollinationsImageUrl (prompt actualizado)
        function createPollinationsImageUrl(promptText, options = {}) {
            const defaults = { seed: Math.floor(Math.random() * 10000000), width: 800, height: 600, nologo: true };
            const settings = { ...defaults, ...options };
            const safePromptText = typeof promptText === 'string' && promptText.trim() !== '' ? promptText : "martial arts concept";
             // Prompt más específico para artes marciales
            const enhancedPrompt = `Dynamic digital painting representing '${safePromptText}'. Martial arts theme, focus on movement, energy (Ki/Chi), discipline, traditional setting (dojo, nature). Use color palette with reds, blacks, whites, gold accents. Style like concept art, avoid photorealism. No text, logos, words.`;
            const escapedPrompt = encodeURIComponent(enhancedPrompt);
            if (!escapedPrompt) return '';
            const negativePrompt = "text, words, labels, letters, title, caption, diagram, chart, graph, UI, menu, button, watermark, signature, multiple images, collage, realistic photograph, modern elements, guns";
            const escapedNegative = encodeURIComponent(negativePrompt);
            let url = `https://image.pollinations.ai/prompt/${escapedPrompt}?seed=${settings.seed}&width=${settings.width}&height=${settings.height}&negative=${escapedNegative}`;
            if (settings.nologo) url += '&nologo=true';
            console.log("Image URL:", url);
            return url;
        }

        // ========== Text Formatting Function ========== (sin cambios)
        function formatExplanationText(rawText) { /* ... (igual que antes, manejo de #, *, etc.) ... */
            if (!rawText) return ''; let formatted = rawText.trim(); formatted = formatted.replace(/\\text\{(.*?)\}/g, '$1'); formatted = formatted.replace(/(\w)_\{?(\d+)\}?/g, '$1<sub>$2</sub>'); formatted = formatted.replace(/(\w)\^\{?([\d+\-−]+)\}?/g, (match, base, exponent) => { const cleanExponent = exponent.replace('−', '-'); return `${base}<sup>${cleanExponent}</sup>`; }); formatted = formatted.replace(/\\rightarrow/g, '&rarr;'); formatted = formatted.replace(/\\\[\s*(.*?)\s*\\\]/g, '<p class="formula">$1</p>'); formatted = formatted.replace(/^####\s+(.*)$/gm, '<h4>$1</h4>'); formatted = formatted.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>'); formatted = formatted.replace(/^##\s+(.*)$/gm, '<h2>$1</h2>'); formatted = formatted.replace(/^#\s+(.*)$/gm, '<h1>$1</h1>'); formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>'); const blocks = formatted.split(/\n\s*\n/).filter(p => p.trim().length > 0); formatted = blocks.map(block => { if (block.startsWith('<h') || block.startsWith('<p class="formula">')) return block; let content = block.replace(/\n/g, ' '); return `<p>${content}</p>`; }).join(''); return formatted;
        }

        // ========== MODAL FUNCTIONS ==========
        // Funciones showModal, hideModal, resetModalState (principal) - sin cambios lógicos
        function showModal() { storyModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideModal() { storyModal.classList.remove('active'); if (!imageFullscreenOverlay.classList.contains('active') && !unlockModal.classList.contains('active')) { document.body.style.overflow = ''; } modalTextArea.scrollTop = 0; PuzzleGame.stop(); resetModalState(); }
        function resetModalState() { modalLoadingIndicator.classList.remove('active'); modalStoryContentArea.classList.add('content-hidden'); modalError.classList.add('content-hidden'); modalTitle.textContent = ''; modalContent.innerHTML = ''; modalErrorMessage.textContent = ''; chatHistory.innerHTML = ''; chatInput.value = ''; chatLoadingIndicator.style.display = 'none'; chatSendBtn.disabled = false; currentTopicTitle = null; hideFullscreenImage(); chatSection.classList.remove('content-hidden'); /* Asegurar que el chat esté visible */ }

        // Funciones para el Modal de Desbloqueo
        function showUnlockModal(titleToUnlock) {
            unlockTargetTitleInput.value = titleToUnlock; // Guardar el título
            unlockCountdownDisplay.textContent = ''; // Limpiar cuenta atrás
            unlockStatusDisplay.textContent = ''; // Limpiar estado
            unlockAdButton.disabled = false; // Habilitar botón
            unlockModal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        function hideUnlockModal() {
            unlockModal.classList.remove('active');
            if (!storyModal.classList.contains('active') && !imageFullscreenOverlay.classList.contains('active')) {
                document.body.style.overflow = '';
            }
            // Detener cualquier cuenta atrás en progreso si se cierra manualmente
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        // ========== FULLSCREEN IMAGE FUNCTIONS ========== (sin cambios)
        function showFullscreenImage(imgSrc) { /* ... (igual que antes) ... */ if (!imageFullscreenOverlay || !fullscreenImage) return; fullscreenImage.src = imgSrc; imageFullscreenOverlay.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideFullscreenImage() { /* ... (igual que antes) ... */ if (!imageFullscreenOverlay) return; imageFullscreenOverlay.classList.remove('active'); if (!storyModal.classList.contains('active') && !unlockModal.classList.contains('active')) { document.body.style.overflow = ''; } fullscreenImage.src = ''; }

        // ========== CHAT FUNCTIONS ========== (sin cambios)
        function addChatMessage(message, sender) { /* ... (igual que antes) ... */ const msgDiv = document.createElement('div'); msgDiv.classList.add('chat-message', sender === 'user' ? 'user-message' : 'ai-message'); message = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>'); msgDiv.innerHTML = message; chatHistory.appendChild(msgDiv); chatHistory.scrollTop = chatHistory.scrollHeight; }
        function addChatError(message) { /* ... (igual que antes) ... */ const errorDiv = document.createElement('div'); errorDiv.classList.add('chat-error'); errorDiv.textContent = message; chatHistory.appendChild(errorDiv); chatHistory.scrollTop = chatHistory.scrollHeight; }
        async function handleSendMessage() { /* ... (igual que antes) ... */ const userQuery = chatInput.value.trim(); if (!userQuery || chatSendBtn.disabled) return; addChatMessage(userQuery, 'user'); chatInput.value = ''; chatSendBtn.disabled = true; chatLoadingIndicator.style.display = 'block'; try { const aiResponse = await fetchChatResponse(userQuery); addChatMessage(aiResponse, 'ai'); } catch (error) { console.error("Chat Error:", error); addChatError(`Error Sensei: ${error.message}`); } finally { chatLoadingIndicator.style.display = 'none'; chatSendBtn.disabled = false; chatInput.focus(); } }

        // ========== UI & EVENT HANDLERS ==========
        function getRandomElement(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function shuffleArray(array) { let ci=array.length,ri;while(ci>0){ri=Math.floor(Math.random()*ci);ci--;[array[ci],array[ri]]=[array[ri],array[ci]];} return array; }

        // --- Modificado: createTitleItem para manejar bloqueo ---
        function createTitleItem(title) {
            const div = document.createElement('div');
            div.className = 'title-item';
            div.setAttribute('data-title', title);

            const textSpan = document.createElement('span');
            textSpan.className = 'title-text';
            textSpan.textContent = title;
            div.appendChild(textSpan);

            // Verificar si debe estar bloqueado (inicialmente Y no desbloqueado permanentemente)
            const permanentlyUnlocked = isTitleUnlocked(title);
            const initiallyLocked = initialLockedTitles.has(title);
            const isLocked = initiallyLocked && !permanentlyUnlocked;

            if (isLocked) {
                div.classList.add('locked');
                div.setAttribute('data-locked', 'true');
                div.style.cursor = 'pointer'; // Permitir clic para abrir modal de desbloqueo

                const lockIcon = document.createElement('i');
                lockIcon.className = 'fas fa-lock lock-icon';
                div.appendChild(lockIcon);
            } else {
                 div.setAttribute('data-locked', 'false');
                 div.style.cursor = 'pointer';
            }

            div.addEventListener('click', () => handleTitleClick(title, div)); // Pasar el elemento
            return div;
        }

        // --- Modificado: displayTitles para considerar el estado de bloqueo ---
        function displayTitles(titles) {
            if (!titleListContainer || !titlesLoading) return;

            // Determinar los títulos bloqueados iniciales (solo la primera vez)
            if (initialLockedTitles.size === 0 && titles.length > 0) {
                const shuffled = shuffleArray([...titles]);
                const lockCount = Math.floor(titles.length * lockPercentage);
                for (let i = 0; i < lockCount; i++) {
                    initialLockedTitles.add(shuffled[i]);
                }
                console.log(`Initially locking ${initialLockedTitles.size} titles.`);
            }

            const sortedTitles = titles.sort((a, b) => a.localeCompare(b));
            titleListContainer.innerHTML = '';
            titlesLoading.style.display = 'none';
            if (sortedTitles.length === 0) { titleListContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center font-sans">» El Dojo está vacío por ahora «</p>'; return; }

            sortedTitles.forEach(title => titleListContainer.appendChild(createTitleItem(title)));
        }

        // --- Modificado: appendTitles para manejar bloqueo en nuevos títulos ---
        function appendTitles(newTitles) {
            if (!titleListContainer || !newTitles || newTitles.length === 0) return;
            const existingTitles = new Set(Array.from(titleListContainer.querySelectorAll('.title-item')).map(item => item.dataset.title));
            const permanentlyUnlocked = getUnlockedTitles();

            newTitles.forEach(title => {
                if (!existingTitles.has(title)) {
                     // Los nuevos títulos generados también se marcan como bloqueados inicialmente por defecto
                     // Si ya estaban desbloqueados por alguna razón (improbable aquí), se mostrarán como tal
                    if (!initialLockedTitles.has(title)) {
                        // Añadir a la lista de bloqueados iniciales si no estaba
                        // (Podría decidirse aleatoriamente si bloquearlos o no, pero por simplicidad, los nuevos generados empiezan bloqueados)
                        initialLockedTitles.add(title);
                    }
                    titleListContainer.appendChild(createTitleItem(title)); // createTitleItem maneja el estado visual
                }
            });
            filterTitles(searchInput.value);
        }


        // *** MODIFIED: handleTitleClick to check lock status ***
        function handleTitleClick(title, titleElement) { // Recibe el elemento
             const isLocked = titleElement.getAttribute('data-locked') === 'true';

             if (isLocked) {
                 // Mostrar el modal de desbloqueo
                 console.log(`Title "${title}" is locked. Showing unlock modal.`);
                 showUnlockModal(title);
             } else {
                 // Proceder con la carga normal del contenido
                 console.log(`Title "${title}" is unlocked. Proceeding to load.`);
                 loadContentForTitle(title);
             }
         }

        // *** Nueva función para cargar el contenido (separada de handleTitleClick)
        async function loadContentForTitle(title) {
            resetModalState(); // Resetear modal principal
            showModal();
            currentTopicTitle = title;
            modalTitle.textContent = title;
            modalStoryContentArea.classList.add('content-hidden');
            modalError.classList.add('content-hidden');

            modalLoadingIndicator.classList.add('active');
            PuzzleGame.start(); // Iniciar puzzle

            try {
                const rawExplanationText = await fetchExplanationText(title);
                const formattedExplanation = formatExplanationText(rawExplanationText);

                PuzzleGame.stop(); // Detener puzzle
                modalLoadingIndicator.classList.remove('active');

                modalContent.innerHTML = formattedExplanation;
                modalStoryContentArea.classList.remove('content-hidden');
                modalTextArea.scrollTop = 0; // Reset scroll

                // Cargar Imagen (igual que antes)
                const placeholderDiv = document.createElement('div');
                placeholderDiv.className = 'image-placeholder';
                placeholderDiv.innerHTML = `<div class="spinner"></div><i class="fas fa-palette placeholder-icon"></i><p style="font-size: 0.8em; margin-top: 0.5rem;">Creando imagen Zen...</p>`;
                modalContent.appendChild(placeholderDiv);

                const imgElement = document.createElement('img');
                imgElement.className = 'final-image';
                imgElement.alt = `Ilustración de ${title}`;
                imgElement.style.display = 'none';
                imgElement.onload = () => { placeholderDiv.remove(); imgElement.style.display = 'block'; imgElement.addEventListener('click', () => showFullscreenImage(imgElement.src)); };
                imgElement.onerror = () => { placeholderDiv.innerHTML = `<i class="fas fa-eye-slash placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Visualización fallida.</p>`; };

                const imageUrl = createPollinationsImageUrl(title);
                 if (imageUrl) { imgElement.src = imageUrl; modalContent.appendChild(imgElement); }
                 else { placeholderDiv.innerHTML = `<i class="fas fa-exclamation-circle placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error URL imagen.</p>`;}


            } catch (error) {
                console.error("Failed display:", error);
                PuzzleGame.stop();
                modalLoadingIndicator.classList.remove('active');
                modalErrorMessage.textContent = error.message || "Error desconocido al cargar la disciplina.";
                modalError.classList.remove('content-hidden');
                modalStoryContentArea.classList.remove('content-hidden');
                modalContent.innerHTML = '';
                chatSection.classList.add('content-hidden'); // Ocultar chat en caso de error de carga principal
            }
        }

        // --- Nueva función para manejar el clic en el botón de anuncio ---
        function handleAdButtonClick() {
            const titleToUnlock = unlockTargetTitleInput.value;
            if (!titleToUnlock || unlockAdButton.disabled) return;

            console.log(`Ad button clicked for title: ${titleToUnlock}`);

            // Abrir URL del anuncio
            window.open(adUrl, '_blank');

            // Deshabilitar botón y empezar cuenta atrás
            unlockAdButton.disabled = true;
            unlockStatusDisplay.textContent = 'Validando acceso...';
            let secondsRemaining = unlockCountdownSeconds;
            unlockCountdownDisplay.textContent = secondsRemaining;

            countdownInterval = setInterval(() => {
                secondsRemaining--;
                unlockCountdownDisplay.textContent = secondsRemaining;

                if (secondsRemaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    unlockCountdownDisplay.textContent = '¡Listo!';
                    unlockStatusDisplay.textContent = 'Contenido Desbloqueado.';

                    // Desbloquear permanentemente
                    unlockTitlePermanently(titleToUnlock);

                    // Esperar un breve momento y luego cargar el contenido
                    setTimeout(() => {
                        hideUnlockModal();
                        // Buscar el elemento actualizado y simular clic o llamar a loadContentForTitle
                         const unlockedTitleElement = titleListContainer.querySelector(`.title-item[data-title="${CSS.escape(titleToUnlock)}"]`);
                         if (unlockedTitleElement) {
                             loadContentForTitle(titleToUnlock);
                         } else {
                              console.error("Could not find the title element after unlock:", titleToUnlock);
                              // Opcional: mostrar un mensaje al usuario
                         }
                    }, 1200); // 1.2 segundos de retraso para que el usuario vea el mensaje "Listo"
                }
            }, 1000); // Actualizar cada segundo
        }


        // handleGenerateMoreTitles (sin cambios lógicos)
        async function handleGenerateMoreTitles() { /* ... (igual que antes) ... */ if (!generateMoreBtn || !generateMoreSpinner || !generateMoreContainer) return; generateMoreBtn.disabled = true; generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-2 animate-spin"></i> Buscando más Dojos...'; try { const newTitles = await fetchGeneratedTitles(); if (newTitles && newTitles.length > 0) { appendTitles(newTitles); } else { alert("No se pudieron encontrar más disciplinas en este momento."); } } catch (error) { console.error("Failed title generation:", error); alert(`Error al buscar disciplinas: ${error.message}`); } finally { generateMoreBtn.disabled = false; generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-2 animate-spin hidden"></i> Descubrir Más Disciplinas (40)'; } }

         // Search Filter Function (sin cambios)
         function filterTitles(searchTerm) { /* ... (igual que antes) ... */ const term = searchTerm.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim(); const titleItems = titleListContainer.querySelectorAll('.title-item'); let visibleCount = 0; titleItems.forEach(item => { const titleText = item.dataset.title.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""); const isVisible = titleText.includes(term); item.classList.toggle('hidden', !isVisible); if (isVisible) visibleCount++; }); noResultsMsg.classList.toggle('hidden', visibleCount > 0); }

        // ========== INITIALIZATION ==========
        function initApp() {
             // Chequeo de elementos esenciales, incluyendo los del nuevo modal
             if (!titleListContainer || !storyModal || !modalCloseBtn || !generateMoreBtn || !titlesLoading || !searchInput || !noResultsMsg || !chatInput || !chatSendBtn || !imageFullscreenOverlay || !fullscreenCloseBtn || !puzzleCanvas || !puzzleScoreLevelText || !unlockModal || !unlockModalCloseBtn || !unlockAdButton || !unlockCountdownDisplay || !unlockStatusDisplay || !unlockTargetTitleInput) {
                console.error("Initialization failed: Missing essential elements (possibly unlock modal elements).");
                document.body.innerHTML = '<p style="color: red; font-size: 1.5em; text-align: center; padding-top: 3em;">Error Crítico: Faltan componentes de la interfaz. No se puede iniciar el Dojo.</p>';
                return;
             }

            PuzzleGame.init(puzzleCanvas, puzzleScoreLevelText);

            // Event Listeners (añadir los del unlock modal)
            modalCloseBtn.addEventListener('click', hideModal);
            storyModal.addEventListener('click', (event) => { if (event.target === storyModal) hideModal(); });
            generateMoreBtn.addEventListener('click', handleGenerateMoreTitles);
            searchInput.addEventListener('input', (event) => filterTitles(event.target.value));
            searchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') event.preventDefault(); });
            chatSendBtn.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') handleSendMessage(); });
            imageFullscreenOverlay.addEventListener('click', hideFullscreenImage);
            fullscreenCloseBtn.addEventListener('click', (event) => { event.stopPropagation(); hideFullscreenImage(); });
            // Listeners del Unlock Modal
            unlockModalCloseBtn.addEventListener('click', hideUnlockModal);
            unlockModal.addEventListener('click', (event) => { if (event.target === unlockModal) hideUnlockModal(); });
            unlockAdButton.addEventListener('click', handleAdButtonClick);


            // Initial display (llamará a createTitleItem que maneja el bloqueo)
            displayTitles(predefinedTitles);
            noResultsMsg.classList.add('hidden');
        }
        document.addEventListener('DOMContentLoaded', initApp);
    </script>

</body>
</html>