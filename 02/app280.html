<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naruto x One Piece: Crónicas Crossover</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Fuentes: Una legible + una temática para títulos -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Bangers&display=swap" rel="stylesheet">
    <style>
        /* --- Estilos Adaptados para Naruto x One Piece Crossover --- */
        :root {
            --color-primary: #FF9900; /* Naranja (Naruto/Luffy) */
            --color-secondary: #005EB8; /* Azul Marino (Shinobi/Mar) */
            --color-tertiary: #FFD700; /* Dorado (Tesoro/Hokage) */
            --color-accent: #E60000; /* Rojo (Poder/Akatsuki/Marines) */
            --color-background: #1a1a2e; /* Azul noche oscuro */
            --color-text: #e0e0fc; /* Texto lavanda claro */
            --color-text-muted: #a8a8d0; /* Texto lavanda más oscuro */
            --color-modal-bg: #24243e; /* Modal azul/púrpura oscuro */
            --color-border: #4a4a6a; /* Borde púrpura/grisáceo */
            --color-error-bg: #4d0000; /* Fondo error rojo muy oscuro */
            --color-error-text: #ffb3b3; /* Texto error rojo claro */
            --color-error-border: #cc0000; /* Borde error rojo */

            --shadow-sm: 0 1px 2px 0 rgba(255, 153, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(255, 153, 0, 0.15), 0 2px 4px -2px rgba(255, 153, 0, 0.1);
            --shadow-lg: 0 0 25px -5px rgba(255, 153, 0, 0.2), 0 8px 10px -6px rgba(255, 153, 0, 0.15);
            --border-radius: 5px; /* Bordes ligeramente redondeados */
            --transition-normal: all 0.25s ease-in-out;
        }
        body { font-family: 'Poppins', sans-serif; background-color: var(--color-background); color: var(--color-text); line-height: 1.7; font-weight: 300; }
        h1, h2, h3, h4, .logo, .title-item { font-family: 'Bangers', cursive; /* Fuente temática */ letter-spacing: 1px; }
        .logo { color: var(--color-primary); text-shadow: 1px 1px 0 var(--color-accent), 2px 2px 0 var(--color-secondary); font-size: 2.5rem; /* Más grande */ }
        h1.page-title { color: var(--color-primary); font-weight: normal; text-shadow: 1px 1px 2px var(--color-background); }
        h2.section-title { color: var(--color-text); border-bottom: 3px dashed var(--color-primary); padding-bottom: 0.6rem; display: inline-block; font-weight: normal; }
        #modal-title { color: var(--color-primary); font-weight: normal; text-shadow: 1px 1px 1px rgba(0,0,0,0.4); }
        .navbar { background-color: rgba(26, 26, 46, 0.85); backdrop-filter: blur(5px); box-shadow: var(--shadow-md); position: sticky; top: 0; z-index: 20; border-bottom: 1px solid var(--color-border); }
        /* Estilos Buscador */
        #search-container { margin-bottom: 2.5rem; position: relative; }
        #search-input { width: 100%; padding: 0.9rem 1.2rem 0.9rem 3rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); font-size: 1rem; background-color: rgba(36, 36, 62, 0.8); color: var(--color-text); box-shadow: var(--shadow-sm); transition: var(--transition-normal); font-family: 'Poppins'; /* Fuente normal aquí */ }
        #search-input::placeholder { color: var(--color-text-muted); }
        #search-input:focus { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(255, 153, 0, 0.3); outline: none; background-color: var(--color-modal-bg); }
        #search-container .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--color-text-muted); font-size: 1.1rem; transition: color 0.2s ease; }
        #search-input:focus + .fa-search { color: var(--color-primary); }

        #title-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1.2rem; }
        .title-item { background-color: var(--color-modal-bg); padding: 1.3rem 1rem; border-radius: var(--border-radius); box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition-normal); text-align: center; font-weight: normal; /* Bangers ya es bold */ color: var(--color-text); border: 1px solid var(--color-border); display: flex; align-items: center; justify-content: center; min-height: 75px; font-size: 1.3rem; /* Más grande por fuente */ line-height: 1.2; border-left: 4px solid transparent; }
        .title-item:hover { transform: translateY(-4px) scale(1.02); box-shadow: var(--shadow-md); border-color: var(--color-primary); color: var(--color-primary); background-color: #303050; border-left-color: var(--color-primary); }
        #generate-more-btn { grid-column: 1 / -1; background: linear-gradient(45deg, var(--color-primary), var(--color-accent)); color: white; padding: 0.8rem 1.5rem; border: none; border-radius: var(--border-radius); font-family: 'Bangers', cursive; font-weight: normal; font-size: 1.5rem; cursor: pointer; transition: var(--transition-normal); margin-top: 2rem; letter-spacing: 1.5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        #generate-more-btn:hover:not(:disabled) { background: linear-gradient(45deg, var(--color-accent), var(--color-primary)); box-shadow: var(--shadow-lg); transform: scale(1.03); }
        #generate-more-btn:disabled { background: var(--color-border); color: var(--color-text-muted); cursor: not-allowed; opacity: 0.7; transform: none; box-shadow: none; }
        #generate-more-btn .fa-sync-alt { color: white; }

        #story-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 26, 46, 0.9); backdrop-filter: blur(3px); display: none; align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        #story-modal.active { display: flex; }
        .modal-content-wrapper {
            background-color: var(--color-modal-bg);
            border: 2px solid var(--color-primary);
            border-radius: var(--border-radius);
            padding: 1rem 1.5rem; /* Ajustar padding */
            max-width: 950px;
            width: 95%;
            max-height: 95vh; /* Aumentado un poco */
            min-height: 500px; /* Más altura para juego/chat */
            overflow: hidden;
            position: relative;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
        }
        .modal-close-btn { position: absolute; top: 8px; right: 8px; background: var(--color-border); border: none; border-radius: 50%; width: 38px; height: 38px; font-size: 1.7rem; color: var(--color-text); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); z-index: 60; }
        .modal-close-btn:hover { background-color: var(--color-primary); color: var(--color-background); transform: rotate(180deg); box-shadow: 0 0 10px var(--color-primary); }
        #modal-title { font-size: 2.2rem; text-align: center; margin-bottom: 1rem; flex-shrink: 0; padding: 0 1rem; line-height: 1.2; }

        /* --- Loading Screen & Minigame --- */
        #modal-loading { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(36, 36, 62, 0.98); display: none; /* Mostrado por JS */ flex-direction: column; align-items: center; justify-content: center; z-index: 55; border-radius: var(--border-radius); padding: 1.5rem; text-align: center; }
        #modal-loading.active { display: flex; } /* Clase para mostrar */
        #modal-loading p.loading-text { font-weight: 600; color: var(--color-primary); font-size: 1.4rem; margin-bottom: 1.5rem; font-family: 'Bangers'; letter-spacing: 1px; }
        #loading-minigame-container { width: 100%; max-width: 350px; /* O ajustar */ margin-bottom: 1rem; background-color: rgba(26, 26, 46, 0.7); padding: 1rem; border-radius: var(--border-radius); border: 1px solid var(--color-border); }
        #puzzle-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem; font-family: 'Poppins'; font-size: 0.95rem; color: var(--color-text-muted); }
        #puzzle-level, #puzzle-score, #puzzle-target { font-weight: 600; color: var(--color-text); }
        #puzzle-grid { display: grid; /* Definido por JS */ gap: 3px; border: 2px solid var(--color-border); background-color: var(--color-background); aspect-ratio: 1 / 1; } /* Grid cuadrado */
        .puzzle-tile { width: 100%; height: 100%; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; transition: transform 0.1s ease, opacity 0.2s ease; border-radius: 3px; }
        .puzzle-tile.selected { transform: scale(0.9); box-shadow: 0 0 8px 2px var(--color-primary); }
        .puzzle-tile.matched { opacity: 0; transform: scale(1.5); }
        /* Estilos específicos para iconos - usar clases o background-image */
        .tile-kunai { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23CCCCCC"><path d="M12 2L14.24 8.29L20.53 10.53L14.24 12.77L12 19L9.76 12.77L3.47 10.53L9.76 8.29L12 2Z"/></svg>'); /* Placeholder simple, usar iconos reales */ }
        .tile-shuriken { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF9900"><path d="M12 1.5l2.4 4.9 5.1.7 -3.7 3.6 .9 5.1 -4.7-2.5 -4.7 2.5 .9-5.1 -3.7-3.6 5.1-.7L12 1.5zm0 8a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5z"/></svg>'); }
        .tile-leaf { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2300FF00"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4 13.5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2 -.9-2-2-2zm-8 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2 -.9-2-2-2zm4-5c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3 -1.34-3-3-3z"/></svg>'); }
        .tile-hat { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FFCC00"><path d="M12 2C6.48 2 2 6.48 2 12h20c0-5.52-4.48-10-10-10zm0 13c-2.76 0-5 2.24-5 5h10c0-2.76-2.24-5-5-5z"/></svg>'); }
        .tile-berry { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23E60000"><path d="M12 2c-5.5 0-10 4.5-10 10s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm-1 15h2v-6h-2v6zm0-8h2V7h-2v2z"/></svg>'); }
        .tile-fruit { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23CC00CC"><path d="M12 2c-3.31 0-6 2.69-6 6 0 2.28 1.26 4.26 3.1 5.29 -1.84 1.03-3.1 3.01-3.1 5.29 0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.28-1.26-4.26-3.1-5.29 1.84-1.03 3.1-3.01 3.1-5.29 0-3.31-2.69-6-6-6zm0 16c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2 -.9 2-2 2zm0-10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2 -.9 2-2 2z"/></svg>'); }

        /* --- Main Content Area (Text + Image + Chat) --- */
        #modal-story-content-area { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; }
        /* Scrollable Area for Text + Image */
        #modal-content-area { flex-grow: 1; min-height: 0; overflow-y: auto; padding: 0 10px 1rem 5px; margin-bottom: 1rem;
            scrollbar-width: thin; scrollbar-color: var(--color-primary) rgba(74, 74, 106, 0.5);
        }
        #modal-content-area::-webkit-scrollbar { width: 8px; }
        #modal-content-area::-webkit-scrollbar-track { background: rgba(74, 74, 106, 0.5); border-radius: var(--border-radius); }
        #modal-content-area::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: var(--border-radius); border: 1px solid var(--color-border); }
        #modal-content { padding: 0 5px; font-family: 'Poppins'; /* Fuente normal aquí */ }
        #modal-content p:not(:last-child) { margin-bottom: 1.4em; }
        #modal-content strong { color: var(--color-primary); font-weight: 600; }
        #modal-content em { color: var(--color-tertiary); font-style: italic; }
        #modal-content h1, #modal-content h2, #modal-content h3, #modal-content h4 { font-family: 'Bangers', cursive; margin-top: 2.2em; margin-bottom: 1.1em; color: var(--color-primary); border-bottom: 1px solid var(--color-border); padding-bottom: 0.5em; font-weight: normal; letter-spacing: 0.5px; }
        #modal-content h1 { font-size: 1.8em; } /* Más grandes */
        #modal-content h2 { font-size: 1.6em; }
        #modal-content h3 { font-size: 1.4em; color: var(--color-tertiary); }
        #modal-content h4 { font-size: 1.3em; color: var(--color-text-muted); border-bottom: none; }
        /* Imagen final y placeholder */
        #modal-content .final-image { display: block; max-width: 85%; height: auto; margin: 2.5rem auto 1rem auto; border: 2px solid var(--color-primary); border-radius: var(--border-radius); box-shadow: 0 0 15px rgba(255, 153, 0, 0.3); cursor: pointer; transition: transform 0.2s ease; }
        #modal-content .final-image:hover { transform: scale(1.03); }
        #modal-content .image-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 150px; margin: 2.5rem auto 1rem auto; color: var(--color-text-muted); }
        #modal-content .image-placeholder .spinner { border: 4px solid rgba(74, 74, 106, 0.7); width: 40px; height: 40px; border-radius: 50%; border-left-color: var(--color-primary); animation: spin 1s linear infinite; margin-bottom: 0.5rem; }
        #modal-content .image-placeholder .placeholder-icon { font-size: 3rem; color: var(--color-primary); }

        /* Chat Section */
        #chat-section { border-top: 1px solid var(--color-border); padding-top: 1rem; margin-top: 1rem; flex-shrink: 0; display: flex; flex-direction: column; max-height: 250px; }
        #chat-history { flex-grow: 1; overflow-y: auto; margin-bottom: 0.8rem; padding: 0.5rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: rgba(26, 26, 46, 0.8); scroll-behavior: smooth; font-family: 'Poppins';
            scrollbar-width: thin; scrollbar-color: var(--color-secondary) rgba(74, 74, 106, 0.5);
        }
        #chat-history::-webkit-scrollbar { width: 6px; }
        #chat-history::-webkit-scrollbar-track { background: rgba(74, 74, 106, 0.5); }
        #chat-history::-webkit-scrollbar-thumb { background-color: var(--color-secondary); }
        .chat-message { margin-bottom: 0.6rem; padding: 0.6rem 0.9rem; border-radius: var(--border-radius); max-width: 85%; word-wrap: break-word; line-height: 1.5; }
        .user-message { background-color: var(--color-primary); color: var(--color-background); margin-left: auto; text-align: right; font-weight: 400; }
        .ai-message { background-color: var(--color-secondary); color: var(--color-text); margin-right: auto; text-align: left; font-weight: 300; }
        .chat-error { color: var(--color-error-text); font-style: italic; text-align: center; font-size: 0.9em; }
        #chat-input-area { display: flex; gap: 0.5rem; }
        #chat-input { flex-grow: 1; padding: 0.7rem 0.9rem; border: 1px solid var(--color-border); background-color: #303050; color: var(--color-text); border-radius: var(--border-radius); font-family: 'Poppins'; font-size: 0.95rem; }
        #chat-input:focus { outline: none; border-color: var(--color-primary); }
        #chat-send-btn { padding: 0.7rem 1.1rem; background-color: var(--color-primary); color: var(--color-background); border: none; border-radius: var(--border-radius); cursor: pointer; transition: background-color 0.2s ease; font-size: 1rem; }
        #chat-send-btn:hover:not(:disabled) { background-color: #ffae42; } /* Naranja más claro */
        #chat-send-btn:disabled { background-color: var(--color-text-muted); cursor: not-allowed; }
        #chat-loading { text-align: center; padding: 0.5rem; font-size: 0.9em; color: var(--color-text-muted); display: none; }
        #chat-loading .fa-spinner { margin-right: 0.5rem; }

        /* Error Message */
        .error-msg { background-color: var(--color-error-bg); color: var(--color-error-text); padding: 1.2rem; border-radius: var(--border-radius); border: 1px solid var(--color-error-border); margin-top: 1.5rem; text-align: center; flex-shrink: 0; font-weight: 400; font-family: 'Poppins'; }
        .error-msg i { margin-right: 0.7rem; color: var(--color-error-border); }
        .content-hidden { display: none !important; }
        .title-item.hidden { display: none; }

        /* Fullscreen Image Overlay */
        #image-fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 26, 46, 0.97); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 100; padding: 2rem; cursor: zoom-out; }
        #image-fullscreen-overlay.active { display: flex; }
        #fullscreen-image { max-width: 95%; max-height: 95%; object-fit: contain; border: 3px solid var(--color-primary); box-shadow: var(--shadow-lg); }
        #fullscreen-close-btn { position: absolute; top: 20px; right: 25px; background: var(--color-modal-bg); border: 1px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; font-size: 1.8rem; color: var(--color-primary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); }
        #fullscreen-close-btn:hover { background-color: var(--color-primary); color: var(--color-background); transform: scale(1.1); }
    </style>
</head>
<body>
     <!-- Header/Navbar -->
     <nav class="navbar mb-10">
         <div class="container mx-auto px-4 py-3 flex flex-col sm:flex-row justify-between items-center">
             <div class="flex items-center text-center mb-2 sm:mb-0">
                 <h1 class="logo">
                     <i class="fas fa-bolt mr-2 text-yellow-400"></i> <!-- Rayo (poder) -->
                     Naruto <span class="text-red-500 mx-1">X</span> One Piece
                     <i class="fas fa-anchor ml-2 text-blue-300"></i> <!-- Ancla (mar) -->
                 </h1>
             </div>
             <span class="text-sm text-gray-400 font-sans tracking-wider">» Crónicas Crossover «</span>
         </div>
     </nav>

     <!-- Main content -->
     <main class="container mx-auto px-4 pb-16">
         <!-- Hero section -->
         <section class="mb-12 text-center">
             <h1 class="page-title text-5xl sm:text-6xl mb-4">¡Donde Chocan los Mundos!</h1>
             <p class="text-xl text-gray-300 mb-8 max-w-3xl mx-auto font-light font-sans">Sumérgete en historias épicas donde Shinobis legendarios y Piratas audaces cruzan sus caminos. Elige una aventura o busca tu crossover soñado.</p>
         </section>

         <!-- Search Bar -->
         <section id="search-container" class="mb-10 max-w-2xl mx-auto">
             <input type="text" id="search-input" placeholder="Buscar personajes, jutsus, frutas, lugares...">
             <i class="fas fa-search"></i>
         </section>

         <!-- Title List Container -->
         <section class="mb-10">
             <h2 class="section-title text-3xl sm:text-4xl mb-8 text-center mx-auto">
                 <i class="fas fa-scroll text-yellow-300 mr-2"></i> <!-- Scroll (historia) -->
                 Pergaminos de Historias
                 <i class="fas fa-book-dead text-purple-400 ml-2"></i> <!-- Libro (poneglyph?) -->
             </h2>
             <div id="title-list">
                  <p id="titles-loading" class="text-gray-400 col-span-full text-center text-lg font-sans">Buscando pergaminos perdidos y mapas del tesoro...</p>
                  <!-- .title-item se añadirán aquí -->
             </div>
             <p id="no-results" class="text-gray-400 col-span-full text-center text-lg mt-4 hidden font-sans">» Ninguna crónica coincide con tu búsqueda «</p>
             <div id="generate-more-container" class="text-center mt-8">
                 <button id="generate-more-btn">
                      <i class="fas fa-sync-alt mr-3 animate-spin hidden"></i>
                     Invocar Más Leyendas (40)
                  </button>
             </div>
         </section>
     </main>

     <!-- Explanation Modal -->
     <div id="story-modal">
         <div class="modal-content-wrapper">
             <button class="modal-close-btn" id="modal-close" aria-label="Cerrar">&times;</button>

             <!-- Loading Indicator with Minigame -->
             <div id="modal-loading">
                 <p class="loading-text">¡Entrenando mientras se carga!</p>
                 <div id="loading-minigame-container">
                     <div id="puzzle-info">
                         <span>Nivel: <span id="puzzle-level">1</span></span>
                         <span>Puntos: <span id="puzzle-score">0</span></span>
                         <span>Meta: <span id="puzzle-target">500</span></span>
                     </div>
                     <div id="puzzle-grid">
                         <!-- Tiles generados por JS -->
                     </div>
                 </div>
                 <p class="text-gray-400 text-sm mt-2 font-sans">Conecta 3 o más iconos iguales...</p>
             </div>

             <!-- Content Area Wrapper -->
             <div id="modal-story-content-area" class="content-hidden flex flex-col flex-grow min-h-0">
                 <!-- Scrollable Text Area -->
                 <div id="modal-content-area">
                     <h2 id="modal-title" class="text-xl md:text-2xl font-bold mb-4 text-center flex-shrink-0"></h2>
                     <div id="modal-content">
                         <!-- Explanation text (HTML) -->
                         <!-- Imagen y placeholder -->
                     </div>
                 </div>
                 <!-- Chat Section -->
                 <div id="chat-section">
                     <div id="chat-history"></div>
                     <div id="chat-loading">
                         <i class="fas fa-spinner fa-spin"></i> Analizando el flujo de chakra/haki...
                     </div>
                     <div id="chat-input-area">
                         <input type="text" id="chat-input" placeholder="Pregunta sobre esta historia...">
                         <button id="chat-send-btn" aria-label="Enviar Mensaje">
                             <i class="fas fa-paper-plane"></i>
                         </button>
                     </div>
                 </div>
                 <!-- Error Display Area -->
                 <div id="modal-error" class="error-msg content-hidden mt-4 flex-shrink-0">
                      <i class="fas fa-exclamation-triangle"></i>
                      <span id="modal-error-message"></span>
                  </div>
             </div>
          </div>
      </div>

      <!-- Fullscreen Image Overlay -->
      <div id="image-fullscreen-overlay">
          <button id="fullscreen-close-btn" aria-label="Cerrar Imagen">&times;</button>
          <img id="fullscreen-image" src="" alt="Imagen Ampliada">
      </div>

      <!-- Footer -->
      <footer class="bg-gray-900 text-gray-500 py-6 mt-12 border-t border-gray-700 font-sans">
          <div class="container mx-auto px-4 text-center text-sm">
              <p>Crónicas generadas por IA, inspiradas en los universos de Masashi Kishimoto y Eiichiro Oda.</p>
              <p class="mt-1">Estas historias son fanfiction y no forman parte del canon oficial.</p>
              <p class="mt-2">© <span id="footer-year"></span> Crónicas Crossover NaruPiece</p>
          </div>
      </footer>

    <script>
        // ========== CONFIG & DATA ==========
        const predefinedTitles = [
            // Personajes en Mundo Opuesto
            "Naruto Uzumaki despierta en el East Blue", "Luffy aterriza en medio de los Exámenes Chunin", "Sasuke Uchiha se une a la tripulación de Barbablanca", "Zoro se pierde y termina en el Bosque de la Muerte", "Sakura Haruno aprende medicina con Chopper", "Nami intenta robar pergaminos secretos de Konoha", "Kakashi Hatake varado en una isla del Grand Line", "Robin investiga los Poneglyphs en ruinas Shinobi", "Itachi Uchiha se encuentra con los Revolucionarios", "Sanji es contratado como chef en Ichiraku Ramen", "Gaara y Crocodile: ¿Alianza en el desierto?", "Hinata Hyuga conoce a los Minks en Zou", "Shikamaru Nara forzado a ser estratega de una tripulación pirata", "Chopper busca hierbas medicinales en el País del Fuego", "Rock Lee desafía a Sanji a un duelo (solo patadas)", "Trafalgar Law intenta 'operar' el chakra", "Akainu persigue a ninjas renegados que entraron al Nuevo Mundo", "Kizaru vs Minato: Duelo de velocidad y luz", "Orochimaru busca la inmortalidad a través de las Frutas del Diablo", "Jiraiya investiga rumores de 'Piratas Sabios'",
            // Poderes y Habilidades Cruzadas
            "¿Qué pasaría si Luffy comiera una 'Fruta Gomu Gomu' de Chakra?", "Naruto aprende a usar Haki del Rey", "Sasuke despierta el Haki de Observación con su Sharingan", "Zoro intenta cortar un Susanoo", "Sakura desarrolla Haki de Armadura en sus puños", "Kakashi copia una técnica Rokushiki con su Sharingan", "La Fruta Kage Kage (Moria) roba la sombra de un usuario de Kagemane", "Naruto (Modo Sabio) vs Luffy (Gear 4)", "El Amaterasu contra la Fruta Mera Mera (Ace/Sabo)", "Control de Arena de Gaara vs Fruta Suna Suna (Crocodile)", "Chopper intenta analizar una Píldora de Soldado", "Franky intenta construir un 'Ninja Cyborg'", "Brook (alma) interactúa con el Jutsu del Segador de Almas", "Usopp crea 'Pop Greens' con semillas de plantas ninja", "Sanji aprende el Shunshin no Jutsu para su 'Sky Walk'", "Comparación: Rasengan vs Gum-Gum Pistol", "Comparación: Chidori vs Electro", "Comparación: Byakugan vs Haki de Observación", "Comparación: Jutsu de Invocación vs Frutas Zoan", "El poder de una Fruta Logia en el mundo Shinobi",
            // Equipo / Alianzas / Conflictos
            "Equipo 7 (Naruto, Sasuke, Sakura) vs Los Tres Almirantes", "Los Sombrero de Paja ayudan a defender Konoha de Pain", "Akatsuki intenta reclutar a un Shichibukai", "La Marina captura a un Kage", "Naruto y Luffy se unen para derrotar a un enemigo común", "Sasuke y Zoro: Rivales de espada definitivos", "Alianza Ninja-Pirata-Mink-Samurai... ¡contra Kaido y Madara!", "Konoha 11 varados en Thriller Bark", "Los Supernovas irrumpen en la Cuarta Guerra Ninja", "Una Fruta del Diablo aparece en medio de Konoha", "Un Bijuu es liberado en el Grand Line", "Luffy intenta 'liberar' a los Bijuu", "Batalla por un Road Poneglyph escondido en el País del Rayo", "Naruto intenta razonar con Doflamingo", "Los Kages se reúnen con los Gorosei", "Guerra Total: La Alianza Shinobi vs El Gobierno Mundial", "CP9 vs ANBU: Espionaje y asesinato", "Shanks visita Konoha", "Barbablanca reconoce el 'espíritu' de Naruto", "Buggy el Payaso intenta estafar a los ninjas",
            // Escenarios 'What If'
            "¿Y si Haku hubiera comido la Fruta Hie Hie (Aokiji)?", "¿Y si Minato pudiera usar Haki de Armadura?", "¿Y si Ace tuviera afinidad con el Katon?", "¿Y si Orochimaru consiguiera el cuerpo de Kaido?", "¿Y si Sakura comiera la Fruta Ope Ope?", "¿Y si Kakashi comiera una Fruta Logia?", "¿Y si Big Mom quisiera un Bijuu para su colección?", "¿Y si Kaguya fuera una usuaria de Fruta del Diablo?", "¿Y si el Clan Uzumaki conociera el Haki?", "¿Y si Roger hubiera sido un ninja?", "¿Y si Zabuza se uniera a los Shichibukai?", "¿Y si Hinata comiera la Fruta Suke Suke (Absalom)?", "¿Y si Jiraiya escribiera sobre las sirenas?", "¿Y si Tsunade apostara contra los Nobles Mundiales?", "¿Y si el One Piece fuera un Pergamino Ninja Legendario?",
            // Historias Cortas / Momentos
            "El primer encuentro incómodo entre Naruto y Luffy", "Zoro y Sasuke compiten por quién se pierde más", "Nami y Sakura discutiendo sobre dinero y deudas", "Sanji y Rock Lee compitiendo por el favor de una dama", "Chopper y Gaara compartiendo un momento tranquilo", "Usopp contando historias exageradas a los niños de la Academia Ninja", "Franky 'SUPERRR' impresionando a los constructores de Konoha", "Brook pidiendo ver las bragas de Kurenai", "Robin descifrando un jutsu antiguo", "Luffy compartiendo ramen con Naruto", "El choque cultural: Comida Shinobi vs Comida Pirata", "Entrenamiento conjunto: Ninjas y Piratas", "Fiesta en el Thousand Sunny con invitados de Konoha", "Naruto enseña el Kage Bunshin a Luffy", "Luffy intenta estirar un kunai",
             // Aumentar con más ideas específicas... El botón "Generar Más" ayudará a llegar a la meta.
             // Es difícil llegar a 400 títulos únicos y significativos sin repetición. Esta lista (~100) es un buen comienzo.
        ];
        const crossoverThemes = [
            "personajes de Naruto en One Piece", "personajes de One Piece en el mundo Naruto", "Naruto conoce a Luffy", "Sasuke vs Zoro", "Akatsuki y Piratas", "Marina vs Ninjas", "Frutas del Diablo vs Jutsu", "Haki vs Chakra", "Equipo 7 con los Sombrero de Paja", "Guerra Ninja-Pirata", "Bijuu en el Grand Line", "Poneglyphs en el mundo Shinobi", "alianzas inesperadas", "enfrentamientos de poder", "escenarios 'what if' crossover", "romance o amistad inter-universal", "villanos colaborando", "búsqueda de artefactos cruzados"
        ];
        const textApiConfig = {
            model: "mistral", // O el modelo que prefieras
            systemPrompt: "Eres un talentoso escritor de fanfiction especializado en crossovers épicos entre los universos de Naruto y One Piece. Tu tarea es crear una historia corta (aproximadamente 1200-1300 palabras) basada en el título/premisa proporcionado. Captura la esencia de los personajes, sus habilidades y personalidades, y cómo interactuarían en este escenario crossover. Describe la acción, el diálogo y el ambiente de forma vívida y coherente con ambos mundos. Enfócate en desarrollar la premisa del título. ¡Sé creativo y fiel al espíritu de ambas series!",
            timeoutSeconds: 180 // Aumentado ligeramente por posible complejidad
        };
        const chatApiConfig = {
            model: "mistral-tiny", // Más rápido para chat
             systemPrompt: "Actúa como un analista de historias de fanfiction, enfocado únicamente en el crossover Naruto/One Piece que se está mostrando actualmente. Responde preguntas sobre los personajes implicados, los puntos clave de la trama generada, posibles desarrollos futuros de esta historia específica, o cómo las habilidades de un universo afectan al otro DENTRO de esta narrativa. Sé conciso y mantente dentro del contexto de la historia actual.",
            timeoutSeconds: 50
        };
        const titleGenerationConfig = {
            model: "mistral",
            systemPrompt: "Eres un generador de ideas para fanfiction crossover Naruto/One Piece. Genera exactamente 40 nuevas y emocionantes premisas o títulos para historias que mezclen personajes, poderes o situaciones de ambos universos. Sé variado (acción, comedia, drama, 'what if'). Devuelve *solo* la lista, una premisa por línea, sin números, guiones ni introducciones.",
            timeoutSeconds: 60 // Más tiempo para generar 40
        };

        // ========== DOM ELEMENTS ==========
        // (Igual que antes, pero añadiendo los del minijuego)
        const searchInput = document.getElementById('search-input');
        const titleListContainer = document.getElementById('title-list');
        const titlesLoading = document.getElementById('titles-loading');
        const noResultsMsg = document.getElementById('no-results');
        const generateMoreContainer = document.getElementById('generate-more-container');
        const generateMoreBtn = document.getElementById('generate-more-btn');
        // Modal Elements
        const storyModal = document.getElementById('story-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const modalLoadingIndicator = document.getElementById('modal-loading'); // Contenedor de carga/juego
        const modalStoryContentArea = document.getElementById('modal-story-content-area'); // Wrapper contenido principal
        const modalTextArea = document.getElementById('modal-content-area'); // Área texto+imagen scrollable
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content'); // Div para texto HTML
        const modalError = document.getElementById('modal-error');
        const modalErrorMessage = document.getElementById('modal-error-message');
        // Chat Elements
        const chatSection = document.getElementById('chat-section');
        const chatHistory = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatLoadingIndicator = document.getElementById('chat-loading');
        // Fullscreen Image Elements
        const imageFullscreenOverlay = document.getElementById('image-fullscreen-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
        // Minigame Elements
        const minigameContainer = document.getElementById('loading-minigame-container');
        const puzzleGridElement = document.getElementById('puzzle-grid');
        const puzzleLevelElement = document.getElementById('puzzle-level');
        const puzzleScoreElement = document.getElementById('puzzle-score');
        const puzzleTargetElement = document.getElementById('puzzle-target');
        const footerYear = document.getElementById('footer-year');

        // ========== State Variables ==========
        let currentStoryTitle = null; // Contexto para el chat
        let puzzleGameInterval = null; // Para detener el loop del juego
        let isPuzzleActive = false; // Flag para controlar el juego

        // ========== API FUNCTIONS ==========
        // fetchTextFromApi, fetchExplanationText, fetchChatResponse (sin cambios funcionales, excepto timeouts y prompts)
        async function fetchTextFromApi(prompt, config, isChat = false) {
             const encodedPrompt = encodeURIComponent(prompt);
             const systemPromptToUse = isChat && currentStoryTitle
                 ? `Eres un analista de fanfiction especializado únicamente en la historia crossover Naruto/One Piece titulada '${currentStoryTitle}'. Responde preguntas sobre sus personajes, trama, poderes tal como se presentan en ESTA historia. Sé conciso y relevante al tema actual.`
                 : config.systemPrompt;
             const encodedSystem = encodeURIComponent(systemPromptToUse);
             const params = new URLSearchParams({ model: config.model, system: encodedSystem });
             if (config.seed && !isChat) params.append('seed', config.seed);
             const url = `https://text.pollinations.ai/${encodedPrompt}?${params.toString()}`;
             console.log(`Fetching text from API (${config.model}, Chat: ${isChat}): ${url.substring(0, 150)}...`);
             const controller = new AbortController();
             const timeoutId = setTimeout(() => controller.abort(), config.timeoutSeconds * 1000);
             try {
                 const response = await fetch(url, { signal: controller.signal });
                 clearTimeout(timeoutId);
                 if (!response.ok) throw new Error(`(Error ${response.status}) ¡Ups! Nuestros servidores de invocación están ocupados. Intenta en unos momentos.`);
                 const text = await response.text();
                 if (!text || text.trim().length === 0) throw new Error("La respuesta del pergamino dimensional llegó en blanco. Intenta de nuevo.");
                 console.log(`API Response received (${text.length} chars)`);
                 return text;
             } catch (error) {
                 clearTimeout(timeoutId);
                 console.error("API Fetch Error:", error);
                 if (error.name === 'AbortError') throw new Error(`La conexión con el otro universo tardó demasiado (>${config.timeoutSeconds}s). Revisa tu conexión o intenta más tarde.`);
                 throw new Error(error.message || "Ocurrió un error inesperado al cruzar las dimensiones.");
             }
        }
        async function fetchExplanationText(conceptTitle) { return fetchTextFromApi(conceptTitle, textApiConfig, false); }
        async function fetchChatResponse(userQuery) { if (!currentStoryTitle) throw new Error("Error interno: No se ha establecido el contexto de la historia para el chat."); return fetchTextFromApi(userQuery, chatApiConfig, true); }
        // *** MODIFIED: fetchGeneratedTitles to request 40 ***
        async function fetchGeneratedTitles() {
            const randomTheme = getRandomElement(crossoverThemes) || "crossover Naruto One Piece general";
            // *** UPDATED PROMPT FOR 40 TITLES ***
            const specificPrompt = `Genera 40 ideas/títulos para fanfiction crossover Naruto/One Piece sobre ${randomTheme}`;
            const config = { ...titleGenerationConfig, seed: Math.floor(Math.random() * 1000000) }; // Add seed
            return fetchTextFromApi(specificPrompt, config, false)
                 .then(text => {
                     const titles = text.split('\n').map(line => line.replace(/^[-\d.\s*]+/, '').trim()).filter(line => line.length > 10 && line.length < 200); // Ajustar longitud mínima/máxima si es necesario
                     if (titles.length < 15) throw new Error("La IA no generó suficientes ideas de crossovers esta vez."); // Reducir umbral mínimo de éxito
                     return titles.slice(0, 40); // Devolver hasta 40
                 });
        }
        function createPollinationsImageUrl(promptText, options = {}) {
             const defaults = { seed: Math.floor(Math.random() * 10000000), width: 800, height: 600, nologo: true };
             const settings = { ...defaults, ...options };
             const safePromptText = typeof promptText === 'string' && promptText.trim() !== '' ? promptText : "Naruto and Luffy meet";
             // Prompt más específico para el crossover
             const enhancedPrompt = `Epic anime crossover art style, dynamic scene inspired by '${safePromptText}', blending Naruto and One Piece elements (characters, environments, powers). Focus on action or key interaction. Vibrant colors. Avoid text, labels, UI.`;
             const escapedPrompt = encodeURIComponent(enhancedPrompt);
             if (!escapedPrompt) return '';
             const negativePrompt = "text, words, labels, letters, title, caption, diagram, chart, graph, UI, menu, button, watermark, signature, multiple images, collage, realistic photograph, blurry, low quality, deformed";
             const escapedNegative = encodeURIComponent(negativePrompt);
             let url = `https://image.pollinations.ai/prompt/${escapedPrompt}?seed=${settings.seed}&width=${settings.width}&height=${settings.height}&negative=${escapedNegative}`;
             if (settings.nologo) url += '&nologo=true';
             console.log("Image URL:", url);
             return url;
         }

        // ========== Text Formatting Function ========== (sin cambios)
        function formatExplanationText(rawText) { /* ... (copy from previous version) ... */
            if (!rawText) return '';
            let formatted = rawText.trim();
            formatted = formatted.replace(/\\text\{(.*?)\}/g, '$1');
            formatted = formatted.replace(/(\w)_\{?(\d+)\}?/g, '$1<sub>$2</sub>');
            formatted = formatted.replace(/(\w)\^\{?([\d+\-−]+)\}?/g, (match, base, exponent) => { const cleanExponent = exponent.replace('−', '-'); return `${base}<sup>${cleanExponent}</sup>`; });
            formatted = formatted.replace(/\\rightarrow/g, '&rarr;');
            formatted = formatted.replace(/\\\[\s*(.*?)\s*\\\]/g, '<p class="formula">$1</p>');
            formatted = formatted.replace(/^####\s+(.*)$/gm, '<h4>$1</h4>');
            formatted = formatted.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>');
            formatted = formatted.replace(/^##\s+(.*)$/gm, '<h2>$1</h2>');
            formatted = formatted.replace(/^#\s+(.*)$/gm, '<h1>$1</h1>');
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
            const blocks = formatted.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            formatted = blocks.map(block => {
                if (block.startsWith('<h') || block.startsWith('<p class="formula">')) return block;
                let content = block.replace(/\n/g, ' ');
                return `<p>${content}</p>`;
            }).join('');
            return formatted;
        }

        // ========== MODAL FUNCTIONS ==========
        function showModal() { storyModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideModal() {
            storyModal.classList.remove('active');
            if (!imageFullscreenOverlay.classList.contains('active')) { document.body.style.overflow = ''; }
            modalTextArea.scrollTop = 0;
            stopPuzzleGame(); // Detener el juego al cerrar
            resetModalState();
        }
        function resetModalState() {
             // No mostramos el loading indicator por defecto, el juego lo reemplaza
             modalLoadingIndicator.classList.remove('active'); // Asegurarse que esté oculto inicialmente
             minigameContainer.style.display = 'none'; // Ocultar contenedor del juego
             puzzleGridElement.innerHTML = ''; // Limpiar grid

             modalStoryContentArea.classList.add('content-hidden');
             modalError.classList.add('content-hidden');
             modalTitle.textContent = '';
             modalContent.innerHTML = '';
             modalErrorMessage.textContent = '';
             chatHistory.innerHTML = '';
             chatInput.value = '';
             chatLoadingIndicator.style.display = 'none';
             chatSendBtn.disabled = false;
             currentStoryTitle = null;
             hideFullscreenImage();
             stopPuzzleGame(); // Asegurarse de detener cualquier intervalo
        }

        // ========== FULLSCREEN IMAGE FUNCTIONS ========== (sin cambios)
        function showFullscreenImage(imgSrc) { /* ... (copy from previous version) ... */
            if (!imageFullscreenOverlay || !fullscreenImage) return;
            fullscreenImage.src = imgSrc;
            imageFullscreenOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        function hideFullscreenImage() { /* ... (copy from previous version) ... */
            if (!imageFullscreenOverlay) return;
            imageFullscreenOverlay.classList.remove('active');
            if (!storyModal.classList.contains('active')) { document.body.style.overflow = ''; }
            fullscreenImage.src = '';
        }

        // ========== CHAT FUNCTIONS ========== (sin cambios funcionales)
        function addChatMessage(message, sender) { /* ... (copy from previous version) ... */
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('chat-message', sender === 'user' ? 'user-message' : 'ai-message');
            message = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            message = message.replace(/\*(.*?)\*/g, '<em>$1</em>');
            msgDiv.innerHTML = message;
            chatHistory.appendChild(msgDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        function addChatError(message) { /* ... (copy from previous version) ... */
             const errorDiv = document.createElement('div');
             errorDiv.classList.add('chat-error');
             errorDiv.textContent = message;
             chatHistory.appendChild(errorDiv);
             chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        async function handleSendMessage() { /* ... (copy from previous version, check variable names) ... */
            const userQuery = chatInput.value.trim();
            if (!userQuery || chatSendBtn.disabled || !currentStoryTitle) return; // Added check for context
            addChatMessage(userQuery, 'user');
            chatInput.value = '';
            chatSendBtn.disabled = true;
            chatLoadingIndicator.style.display = 'block';
            try {
                const aiResponse = await fetchChatResponse(userQuery);
                addChatMessage(aiResponse, 'ai');
            } catch (error) {
                console.error("Chat Error:", error);
                addChatError(`Error IA: ${error.message}`);
            } finally {
                chatLoadingIndicator.style.display = 'none';
                chatSendBtn.disabled = false;
                chatInput.focus();
            }
        }

        // ========== PUZZLE MINIGAME LOGIC ==========
        const TILE_TYPES = ['kunai', 'shuriken', 'leaf', 'hat', 'berry', 'fruit'];
        const GRID_SIZE = 7; // 7x7 grid, por ejemplo
        let puzzleState = {
            grid: [], // Array 2D de tipos de tile
            score: 0,
            level: 1,
            targetScore: 500,
            selectedTile: null, // { row, col }
            isSwapping: false,
            isCheckingMatches: false,
        };

        function getTileClass(type) { return `tile-${type}`; }
        function getRandomTileType() { return TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)]; }

        function initPuzzleGame() {
            console.log("Initializing Puzzle Game...");
            if (!modalLoadingIndicator || !minigameContainer || !puzzleGridElement) return;

            modalLoadingIndicator.classList.add('active'); // Mostrar el contenedor de carga/juego
            minigameContainer.style.display = 'block'; // Mostrar el juego dentro
            modalStoryContentArea.classList.add('content-hidden'); // Ocultar contenido principal
            modalError.classList.add('content-hidden'); // Ocultar errores

            puzzleState.score = 0;
            puzzleState.level = 1;
            puzzleState.targetScore = 500;
            puzzleState.selectedTile = null;
            puzzleState.isSwapping = false;
            puzzleState.isCheckingMatches = false;
            updatePuzzleInfo();

            puzzleGridElement.innerHTML = ''; // Limpiar grid
            puzzleGridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            puzzleGridElement.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;
            puzzleState.grid = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                puzzleState.grid[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    // Evitar matches iniciales (simple check)
                    let tileType;
                    do {
                        tileType = getRandomTileType();
                    } while (
                        (c >= 2 && puzzleState.grid[r][c-1] === tileType && puzzleState.grid[r][c-2] === tileType) ||
                        (r >= 2 && puzzleState.grid[r-1][c] === tileType && puzzleState.grid[r-2][c] === tileType)
                    );
                    puzzleState.grid[r][c] = tileType;
                    const tileElement = createTileElement(r, c, tileType);
                    puzzleGridElement.appendChild(tileElement);
                }
            }
            isPuzzleActive = true;
            // Opcional: Iniciar un loop suave para animaciones o checks pasivos si es necesario
            // puzzleGameInterval = setInterval(puzzleGameLoop, 1000 / 10); // 10 FPS
            console.log("Puzzle Game Initialized and Active");
        }

        function stopPuzzleGame() {
            console.log("Stopping Puzzle Game...");
            isPuzzleActive = false;
            if (puzzleGameInterval) {
                clearInterval(puzzleGameInterval);
                puzzleGameInterval = null;
            }
            // Opcional: Limpiar grid visualmente o ocultar contenedor
            if (minigameContainer) minigameContainer.style.display = 'none';
            if (modalLoadingIndicator) modalLoadingIndicator.classList.remove('active');
            console.log("Puzzle Game Stopped");
        }

        function createTileElement(row, col, type) {
            const tile = document.createElement('div');
            tile.classList.add('puzzle-tile', getTileClass(type));
            tile.dataset.row = row;
            tile.dataset.col = col;
            tile.dataset.type = type;
            tile.addEventListener('click', handleTileClick);
            return tile;
        }

        function updatePuzzleInfo() {
            puzzleLevelElement.textContent = puzzleState.level;
            puzzleScoreElement.textContent = puzzleState.score;
            puzzleTargetElement.textContent = puzzleState.targetScore;
        }

        function handleTileClick(event) {
            if (!isPuzzleActive || puzzleState.isSwapping || puzzleState.isCheckingMatches) return;
            const clickedRow = parseInt(event.target.dataset.row);
            const clickedCol = parseInt(event.target.dataset.col);

            if (puzzleState.selectedTile) {
                // Segunda selección
                const prevRow = puzzleState.selectedTile.row;
                const prevCol = puzzleState.selectedTile.col;

                // Deseleccionar si es el mismo tile
                if (prevRow === clickedRow && prevCol === clickedCol) {
                    event.target.classList.remove('selected');
                    puzzleState.selectedTile = null;
                    return;
                }

                // Verificar si es adyacente
                if (Math.abs(prevRow - clickedRow) + Math.abs(prevCol - clickedCol) === 1) {
                    // Es adyacente, intentar swap
                    swapTiles(prevRow, prevCol, clickedRow, clickedCol);
                } else {
                    // No es adyacente, seleccionar el nuevo
                    const prevTileElement = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${prevRow}'][data-col='${prevCol}']`);
                    if(prevTileElement) prevTileElement.classList.remove('selected');
                    event.target.classList.add('selected');
                    puzzleState.selectedTile = { row: clickedRow, col: clickedCol };
                }
            } else {
                // Primera selección
                event.target.classList.add('selected');
                puzzleState.selectedTile = { row: clickedRow, col: clickedCol };
            }
        }

        async function swapTiles(r1, c1, r2, c2) {
            if (puzzleState.isSwapping) return;
            puzzleState.isSwapping = true;

            const tile1Element = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${r1}'][data-col='${c1}']`);
            const tile2Element = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${r2}'][data-col='${c2}']`);

            if (!tile1Element || !tile2Element) {
                console.error("Error finding tiles to swap");
                puzzleState.isSwapping = false;
                return;
            }

            // Deseleccionar visualmente
            tile1Element.classList.remove('selected');
            tile2Element.classList.remove('selected');
            puzzleState.selectedTile = null;

            // Intercambiar tipos en el estado lógico
            const tempType = puzzleState.grid[r1][c1];
            puzzleState.grid[r1][c1] = puzzleState.grid[r2][c2];
            puzzleState.grid[r2][c2] = tempType;

            // Intercambiar clases y datasets en el DOM (para reflejo visual inmediato)
            const type1 = tile1Element.dataset.type;
            const type2 = tile2Element.dataset.type;
            tile1Element.className = `puzzle-tile ${getTileClass(type2)}`;
            tile1Element.dataset.type = type2;
            tile2Element.className = `puzzle-tile ${getTileClass(type1)}`;
            tile2Element.dataset.type = type1;


            // Verificar si el swap crea matches
            await new Promise(resolve => setTimeout(resolve, 50)); // Pequeña pausa visual
            const matches = findMatches();

            if (matches.length > 0) {
                // Swap válido, procesar matches
                await processMatches(matches);
                puzzleState.isSwapping = false;
                 // Iniciar ciclo de check/fill hasta que no haya más matches
                await checkAndFillGrid();

            } else {
                // Swap inválido, revertir
                await new Promise(resolve => setTimeout(resolve, 200)); // Pausa para ver el swap fallido

                 // Revertir tipos en el estado lógico
                puzzleState.grid[r2][c2] = puzzleState.grid[r1][c1];
                puzzleState.grid[r1][c1] = tempType;

                 // Revertir clases y datasets en el DOM
                tile1Element.className = `puzzle-tile ${getTileClass(tempType)}`;
                tile1Element.dataset.type = tempType;
                tile2Element.className = `puzzle-tile ${getTileClass(puzzleState.grid[r2][c2])}`;
                 tile2Element.dataset.type = puzzleState.grid[r2][c2];

                puzzleState.isSwapping = false;
            }
        }

       function findMatches() {
            const matches = [];
            // Horizontal
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    if (puzzleState.grid[r][c] && puzzleState.grid[r][c] === puzzleState.grid[r][c+1] && puzzleState.grid[r][c] === puzzleState.grid[r][c+2]) {
                        matches.push({ row: r, col: c }, { row: r, col: c+1 }, { row: r, col: c+2 });
                         // Check for longer matches
                         let k = c + 3;
                         while (k < GRID_SIZE && puzzleState.grid[r][k] === puzzleState.grid[r][c]) {
                             matches.push({ row: r, col: k });
                             k++;
                         }
                         c = k - 1; // Skip checked tiles
                    }
                }
            }
            // Vertical
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                     if (puzzleState.grid[r][c] && puzzleState.grid[r][c] === puzzleState.grid[r+1][c] && puzzleState.grid[r][c] === puzzleState.grid[r+2][c]) {
                         matches.push({ row: r, col: c }, { row: r+1, col: c }, { row: r+2, col: c });
                          // Check for longer matches
                         let k = r + 3;
                         while (k < GRID_SIZE && puzzleState.grid[k][c] === puzzleState.grid[r][c]) {
                             matches.push({ row: k, col: c });
                             k++;
                         }
                         r = k - 1; // Skip checked tiles
                    }
                }
            }
             // Remove duplicates (tiles part of both horizontal and vertical matches)
             const uniqueMatches = matches.filter((match, index, self) =>
                 index === self.findIndex((m) => (m.row === match.row && m.col === match.col))
             );
            return uniqueMatches;
        }

        async function processMatches(matches) {
            if (matches.length === 0) return;

            puzzleState.score += matches.length * 10 * puzzleState.level; // Puntuación simple
            updatePuzzleInfo();

            // Animar desaparición
            matches.forEach(match => {
                const tileElement = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${match.row}'][data-col='${match.col}']`);
                if (tileElement) {
                    tileElement.classList.add('matched');
                    puzzleState.grid[match.row][match.col] = null; // Marcar como vacío en el estado lógico
                }
            });

            await new Promise(resolve => setTimeout(resolve, 300)); // Tiempo para animación de desaparición

            // Eliminar elementos del DOM (o reutilizar si se optimiza)
            matches.forEach(match => {
                 const tileElement = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${match.row}'][data-col='${match.col}']`);
                 if (tileElement) tileElement.remove();
            });

            await dropNewTiles();
            checkLevelUp();
        }

        async function dropNewTiles() {
             for (let c = 0; c < GRID_SIZE; c++) {
                 let emptyRow = GRID_SIZE - 1;
                 // Mover tiles existentes hacia abajo
                 for (let r = GRID_SIZE - 1; r >= 0; r--) {
                     if (puzzleState.grid[r][c] !== null) {
                         if (r !== emptyRow) {
                             // Mover tile lógico
                             puzzleState.grid[emptyRow][c] = puzzleState.grid[r][c];
                             puzzleState.grid[r][c] = null;
                             // Mover tile visual
                             const tileElement = puzzleGridElement.querySelector(`.puzzle-tile[data-row='${r}'][data-col='${c}']`);
                             if (tileElement) {
                                 tileElement.dataset.row = emptyRow;
                                 // ¡IMPORTANTE! Necesitas recalcular la posición CSS (top/left o grid-row)
                                 // Para simplicidad con CSS grid, podrías eliminar y recrear en la nueva posición,
                                 // pero eso es menos eficiente. Una mejor opción es usar posicionamiento absoluto
                                 // o recalcular el orden en el contenedor grid.
                                 // Simplificación: asumimos que CSS grid se reordena o usamos re-creación.
                                 // Aquí solo actualizamos el data attribute. La posición visual se 'arreglará'
                                 // al añadir los nuevos tiles o al re-renderizar.
                             }
                         }
                         emptyRow--;
                     }
                 }
                 // Añadir nuevos tiles en la parte superior
                 for (let r = emptyRow; r >= 0; r--) {
                     const newType = getRandomTileType();
                     puzzleState.grid[r][c] = newType;
                     const newTileElement = createTileElement(r, c, newType);
                     // Insertar en la posición correcta del grid DOM
                     // Esto es complejo con appendChild. Se requiere insertBefore o reordenar.
                     // Simplificación: Añadir al final y confiar en que CSS grid lo coloque,
                     // o re-renderizar todo el grid (menos eficiente).
                     // Solución más robusta: calcular el índice correcto y usar insertBefore.
                     const nextSiblingIndex = (r + 1) * GRID_SIZE + c; // Aproximado, puede fallar
                     const nextSibling = puzzleGridElement.children[nextSiblingIndex];
                     if(nextSibling) {
                          puzzleGridElement.insertBefore(newTileElement, nextSibling);
                     } else {
                          puzzleGridElement.appendChild(newTileElement); // Añadir al final si no hay siguiente
                     }
                    // Aplicar animación de caída (ej. con CSS)
                    newTileElement.style.opacity = 0;
                    await new Promise(resolve => setTimeout(resolve, 20)); // Stagger fall
                    newTileElement.style.transition = 'opacity 0.3s ease';
                    newTileElement.style.opacity = 1;
                 }
             }
             // Re-renderizar visualmente el grid basado en puzzleState.grid (alternativa más simple pero menos performante)
             // renderGrid(); // Función hipotética que limpia y recrea todos los tiles

              await new Promise(resolve => setTimeout(resolve, 300)); // Esperar que caigan visualmente
         }

         async function checkAndFillGrid() {
             if (puzzleState.isCheckingMatches) return;
             puzzleState.isCheckingMatches = true;
             let newMatches;
             do {
                 await new Promise(resolve => setTimeout(resolve, 100)); // Pausa entre checks
                 newMatches = findMatches();
                 if (newMatches.length > 0) {
                     await processMatches(newMatches);
                 }
             } while (newMatches.length > 0 && isPuzzleActive); // Continuar solo si el juego está activo

              puzzleState.isCheckingMatches = false;
         }


        function checkLevelUp() {
            if (puzzleState.score >= puzzleState.targetScore) {
                puzzleState.level++;
                puzzleState.score = 0; // O continuar puntuación? Reiniciar es más tipo nivel
                puzzleState.targetScore = Math.floor(puzzleState.targetScore * 1.5); // Aumentar dificultad
                console.log(`Level Up! Reached Level ${puzzleState.level}`);
                // Opcional: Añadir breve animación/mensaje de level up
                 updatePuzzleInfo(); // Actualizar la info mostrada
            }
        }

        // ========== UI & EVENT HANDLERS ==========
        function getRandomElement(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function shuffleArray(array) { let ci=array.length,ri;while(ci>0){ri=Math.floor(Math.random()*ci);ci--;[array[ci],array[ri]]=[array[ri],array[ci]];} return array; }
        function createTitleItem(title) { const div=document.createElement('div'); div.className='title-item'; div.textContent=title; div.setAttribute('data-title', title); div.addEventListener('click', () => handleTitleClick(title)); return div; }
        function displayTitles(titles) {
             if (!titleListContainer || !titlesLoading) return;
             // Ordenar podría ser menos relevante para títulos de historias creativas
             // const sortedTitles = titles.sort((a, b) => a.localeCompare(b));
             titleListContainer.innerHTML = ''; // Limpiar antes de añadir
             titlesLoading.style.display = 'none';
             if (titles.length === 0) { titleListContainer.innerHTML = '<p class="text-gray-400 col-span-full text-center font-sans">» No se encontraron crónicas perdidas. «</p>'; return; }
             titles.forEach(title => titleListContainer.appendChild(createTitleItem(title)));
         }
        function appendTitles(newTitles) {
             if (!titleListContainer || !newTitles || newTitles.length === 0) return;
             const existingTitles = new Set(Array.from(titleListContainer.querySelectorAll('.title-item')).map(item => item.dataset.title));
             let addedCount = 0;
             newTitles.forEach(title => { if (!existingTitles.has(title)) { titleListContainer.appendChild(createTitleItem(title)); addedCount++; } });
             console.log(`Added ${addedCount} new titles.`);
             filterTitles(searchInput.value); // Re-aplicar filtro
         }

        // *** MODIFIED: handleTitleClick to integrate minigame ***
        async function handleTitleClick(title) {
            resetModalState(); // Limpia todo, incluido el juego anterior si lo hubiera
            showModal();
            modalTitle.textContent = title;
            currentStoryTitle = title;
            modalContent.innerHTML = '';
            chatHistory.innerHTML = '';
            modalError.classList.add('content-hidden');
            modalStoryContentArea.classList.add('content-hidden'); // Ocultar contenido principal

            // *** START MINIGAME ***
            initPuzzleGame();

            try {
                // Iniciar ambas tareas (texto e imagen) casi en paralelo
                const textPromise = fetchExplanationText(title);
                const imageUrl = createPollinationsImageUrl(title); // Generar URL síncrono

                // Crear placeholder y elemento imagen (aún no se añade src)
                const placeholderDiv = document.createElement('div');
                placeholderDiv.className = 'image-placeholder';
                placeholderDiv.innerHTML = `<div class="spinner"></div><i class="fas fa-image placeholder-icon"></i><p style="font-size: 0.8em; margin-top: 0.5rem;">Pintando la escena...</p>`;

                const imgElement = document.createElement('img');
                imgElement.className = 'final-image';
                imgElement.alt = `Ilustración crossover: ${title}`;
                imgElement.style.display = 'none'; // Oculta hasta cargar

                // Esperar a que el texto principal esté listo
                const rawExplanationText = await textPromise;
                const formattedExplanation = formatExplanationText(rawExplanationText);

                 // *** STOP MINIGAME and show content ***
                 stopPuzzleGame();
                 modalLoadingIndicator.classList.remove('active'); // Ocultar pantalla de carga/juego

                modalContent.innerHTML = formattedExplanation; // Poner texto
                modalContent.appendChild(placeholderDiv); // Añadir placeholder DESPUÉS del texto
                 modalStoryContentArea.classList.remove('content-hidden'); // Mostrar área de contenido

                modalTextArea.scrollTop = 0; // Reset scroll DESPUÉS de que el contenido es visible
                console.log("Scroll set to 0 after content visible");

                // Ahora que el texto está visible, cargar la imagen
                if (imageUrl) {
                    imgElement.onload = () => {
                        console.log("Image loaded successfully.");
                        placeholderDiv.remove();
                        imgElement.style.display = 'block';
                        imgElement.addEventListener('click', () => showFullscreenImage(imgElement.src));
                    };
                    imgElement.onerror = () => {
                        console.error("Error loading image for:", title);
                        placeholderDiv.innerHTML = `<i class="fas fa-eye-slash placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error al pintar la escena.</p>`;
                    };
                    imgElement.src = imageUrl; // Iniciar carga de imagen
                    modalContent.appendChild(imgElement); // Añadir img al final del contenido
                } else {
                     console.error("Could not create image URL for:", title);
                     placeholderDiv.innerHTML = `<i class="fas fa-exclamation-circle placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error URL de imagen.</p>`;
                }

            } catch (error) {
                console.error("Failed display:", error);
                // *** STOP MINIGAME on error ***
                 stopPuzzleGame();
                 modalLoadingIndicator.classList.remove('active'); // Ocultar pantalla de carga/juego

                modalErrorMessage.textContent = error.message || "Error desconocido al cargar la crónica.";
                modalError.classList.remove('content-hidden');
                modalStoryContentArea.classList.remove('content-hidden'); // Mostrar área para ver error
                modalContent.innerHTML = '';
                chatSection.classList.add('content-hidden');
            }
        }

        // *** MODIFIED: handleGenerateMoreTitles for 40 titles ***
        async function handleGenerateMoreTitles() {
             if (!generateMoreBtn || generateMoreBtn.disabled) return;
             generateMoreBtn.disabled = true;
             generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-3 animate-spin"></i> Buscando en los anales...';
             try {
                 const newTitles = await fetchGeneratedTitles(); // Fetching 40
                 if (newTitles && newTitles.length > 0) { appendTitles(newTitles); }
                 else { alert("No se pudieron invocar más leyendas en este momento."); }
             } catch (error) {
                 console.error("Failed title generation:", error);
                 alert(`Error al invocar leyendas: ${error.message}`);
             } finally {
                 generateMoreBtn.disabled = false;
                 generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-3 animate-spin hidden"></i> Invocar Más Leyendas (40)';
             }
         }

         // Search Filter Function (sin cambios)
         function filterTitles(searchTerm) {
             const term = searchTerm.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
             const titleItems = titleListContainer.querySelectorAll('.title-item');
             let visibleCount = 0;
             titleItems.forEach(item => {
                 const titleText = item.dataset.title.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                 const isVisible = titleText.includes(term);
                 item.classList.toggle('hidden', !isVisible);
                 if (isVisible) visibleCount++;
             });
             noResultsMsg.classList.toggle('hidden', visibleCount > 0);
         }

        // ========== INITIALIZATION ==========
        function initApp() {
             // Check all essential elements, including game elements if needed
            if (!titleListContainer || !storyModal || !modalCloseBtn || !generateMoreBtn || !titlesLoading || !searchInput || !noResultsMsg || !chatInput || !chatSendBtn || !imageFullscreenOverlay || !fullscreenCloseBtn || !modalLoadingIndicator || !minigameContainer || !puzzleGridElement) {
                console.error("Initialization failed: Missing essential elements.");
                document.body.innerHTML = '<p style="color: red; font-size: 1.5em; text-align: center; padding-top: 3em;">¡ERROR DIMENSIONAL! Faltan componentes de la interfaz.</p>';
                return;
             }
             // Listeners
             modalCloseBtn.addEventListener('click', hideModal);
             storyModal.addEventListener('click', (event) => { if (event.target === storyModal) hideModal(); });
             generateMoreBtn.addEventListener('click', handleGenerateMoreTitles);
             searchInput.addEventListener('input', (event) => filterTitles(event.target.value));
             searchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') event.preventDefault(); });
             chatSendBtn.addEventListener('click', handleSendMessage);
             chatInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') handleSendMessage(); });
             imageFullscreenOverlay.addEventListener('click', hideFullscreenImage);
             fullscreenCloseBtn.addEventListener('click', (event) => { event.stopPropagation(); hideFullscreenImage(); });

             // Initial display
             displayTitles(predefinedTitles);
             noResultsMsg.classList.add('hidden');
             if(footerYear) footerYear.textContent = new Date().getFullYear(); // Set current year in footer
        }
        document.addEventListener('DOMContentLoaded', initApp);
    </script>

</body>
</html>