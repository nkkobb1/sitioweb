<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossovers Históricos Z</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Fuentes: Una Clásica + Una DBZ/Techno -->
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Estilos Adaptados para Crossover Histórico DBZ --- */
        :root {
            --color-primary: #FF8C00; /* Naranja DBZ Gi */
            --color-secondary: #1E90FF; /* Azul Eléctrico Ki */
            --color-tertiary: #FFD700; /* Dorado Super Saiyan */
            --color-background: #FDF5E6; /* Fondo Pergamino Claro */
            --color-text: #4A4A4A; /* Texto Gris Oscuro (Legible) */
            --color-text-muted: #888888; /* Texto Gris Medio */
            --color-modal-bg: #FFF8DC; /* Crema/Maíz */
            --color-border: #D2B48C; /* Borde Tan/Madera Clara */
            --color-locked-bg: #EAE0C8; /* Fondo bloqueado más oscuro */
            --color-locked-text: #A08C78; /* Texto bloqueado */
            --color-error-bg: #fde8e8;
            --color-error-text: #9b2c2c;
            --color-error-border: #fecaca;

            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 5px 10px rgba(0, 0, 0, 0.12);
            --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1);
            --border-radius: 6px; /* Bordes suavemente redondeados */
            --transition-normal: all 0.25s ease-in-out;
        }
        body { font-family: 'EB Garamond', serif; background-color: var(--color-background); color: var(--color-text); line-height: 1.8; font-weight: 400; background-image: url("data:image/svg+xml,%3Csvg width='52' height='26' viewBox='0 0 52 26' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23d2b48c' fill-opacity='0.1'%3E%3Cpath d='M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z' /%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); /* Subtle background pattern */ }
        h1, h2, h3, h4, .logo, #generate-more-btn, #unlock-ad-button, #modal-title, #loading-text { font-family: 'Orbitron', sans-serif; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .logo { color: var(--color-primary); }
        h1.page-title { color: var(--color-primary); font-weight: 700; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        h2.section-title { color: var(--color-secondary); border-bottom: 3px dashed var(--color-primary); padding-bottom: 0.7rem; display: inline-block; font-weight: 700; }
        #modal-title { color: var(--color-primary); font-weight: 700; font-size: 1.6rem; }
        .navbar { background-color: rgba(253, 245, 230, 0.85); backdrop-filter: blur(4px); box-shadow: var(--shadow-md); position: sticky; top: 0; z-index: 20; border-bottom: 1px solid var(--color-border); }

        /* Search Bar (Sin cambios mayores) */
        #search-container { margin-bottom: 2.5rem; position: relative; }
        #search-input { width: 100%; padding: 0.8rem 1.1rem 0.8rem 2.8rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); font-size: 1rem; background-color: var(--color-modal-bg); color: var(--color-text); box-shadow: var(--shadow-sm); transition: var(--transition-normal); font-family: 'EB Garamond'; }
        #search-input::placeholder { color: var(--color-text-muted); font-style: italic;}
        #search-input:focus { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2); outline: none; background-color: #fff; }
        #search-container .fa-search { position: absolute; left: 0.9rem; top: 50%; transform: translateY(-50%); color: var(--color-text-muted); font-size: 1.1rem; transition: color 0.2s ease; }
        #search-input:focus + .fa-search { color: var(--color-primary); }

        /* Title List & Items */
        #title-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.2rem; }
        .title-item { background-color: var(--color-modal-bg); padding: 1rem 1.2rem; border-radius: var(--border-radius); box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition-normal); text-align: left; font-weight: 400; color: var(--color-text); border: 1px solid var(--color-border); display: flex; align-items: center; justify-content: space-between; min-height: 65px; font-family: 'EB Garamond', serif; font-size: 1.05rem; position: relative; overflow: hidden; border-left: 5px solid transparent; }
        .title-item:hover { transform: translateX(4px) scale(1.01); box-shadow: var(--shadow-md); border-left-color: var(--color-primary); color: var(--color-primary); background-color: #fff; border-color: var(--color-border); }
        .title-item .title-text { flex-grow: 1; margin-right: 10px; font-weight: 700;}
        .title-item .lock-icon { color: var(--color-text-muted); font-size: 1.1rem; flex-shrink: 0; }

        /* Locked Title Items */
        .title-item.locked { background-color: var(--color-locked-bg); color: var(--color-locked-text); cursor: pointer; /* Allow click for unlock modal */ border-color: #C8BBA8; border-left-color: var(--color-locked-text); opacity: 0.85; }
        .title-item.locked:hover { transform: none; box-shadow: var(--shadow-sm); background-color: var(--color-locked-bg); color: var(--color-locked-text); border-left-color: var(--color-primary); }
        .title-item.locked .title-text { font-weight: 400; }
        .title-item.locked .lock-icon { color: var(--color-primary); animation: pulse-lock 1.5s infinite ease-in-out; }
        @keyframes pulse-lock { 0%, 100% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.1); opacity: 1; } }

        /* Generate More Button */
        #generate-more-btn { grid-column: 1 / -1; background: linear-gradient(45deg, var(--color-primary), var(--color-tertiary)); color: var(--color-secondary); /* Dark blue text */ padding: 0.9rem 1.8rem; border: 1px solid rgba(0,0,0,0.1); border-radius: var(--border-radius); cursor: pointer; transition: var(--transition-normal); margin-top: 2rem; text-shadow: 1px 1px 1px rgba(255,255,255,0.3); }
        #generate-more-btn:hover:not(:disabled) { background: linear-gradient(45deg, var(--color-tertiary), var(--color-primary)); box-shadow: var(--shadow-lg); transform: scale(1.03); color: #000; }
        #generate-more-btn:disabled { background: var(--color-text-muted); color: var(--color-background); cursor: not-allowed; opacity: 0.7; transform: none; box-shadow: none; }
        #generate-more-btn .fa-sync-alt { /* Removed spin class here, managed in JS */ }

        /* Story Modal (Principal) */
        #story-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(74, 74, 74, 0.9); display: none; align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        #story-modal.active { display: flex; }
        .modal-content-wrapper { background-color: var(--color-modal-bg); border: 2px solid var(--color-border); border-radius: var(--border-radius); padding: 1.5rem 2rem; max-width: 1000px; width: 95%; max-height: 90vh; min-height: 450px; overflow: hidden; position: relative; box-shadow: var(--shadow-lg); display: flex; flex-direction: column; }
        .modal-close-btn { position: absolute; top: 12px; right: 12px; background: rgba(210, 180, 140, 0.7); border: none; border-radius: 50%; width: 38px; height: 38px; font-size: 1.7rem; color: var(--color-text); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); z-index: 60; }
        .modal-close-btn:hover { background-color: var(--color-primary); color: white; transform: rotate(90deg); }

        /* Modal Content Area (Scrollable) */
        #modal-content-area { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; overflow-y: auto; padding-right: 12px; margin-bottom: 1rem; scrollbar-width: thin; scrollbar-color: var(--color-primary) var(--color-border); }
        #modal-content-area::-webkit-scrollbar { width: 10px; }
        #modal-content-area::-webkit-scrollbar-track { background: var(--color-border); border-radius: var(--border-radius); }
        #modal-content-area::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: var(--border-radius); border: 2px solid var(--color-border); }

        #modal-content { padding: 0 8px; }
        #modal-content p:not(:last-child) { margin-bottom: 1.5em; font-size: 1.1rem; }
        #modal-content strong { color: var(--color-primary); font-weight: 700; font-family: 'Orbitron'; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.5px; }
        #modal-content em { color: var(--color-secondary); font-style: italic; }
        #modal-content h1, #modal-content h2, #modal-content h3, #modal-content h4 { font-family: 'Orbitron', sans-serif; margin-top: 2.2em; margin-bottom: 1.2em; color: var(--color-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 0.5em; font-weight: 400; letter-spacing: 0.8px;}
        #modal-content h1 { font-size: 1.5em; color: var(--color-primary); border-bottom-width: 2px; }
        #modal-content h2 { font-size: 1.3em; }
        #modal-content h3 { font-size: 1.15em; color: var(--color-primary); border-bottom: none; }
        #modal-content h4 { font-size: 1.05em; color: var(--color-text-muted); border-bottom: none; font-style: italic; font-family: 'EB Garamond'; text-transform: none; letter-spacing: normal;}
        /* Imagen Final */
        #modal-content .final-image { display: block; max-width: 80%; height: auto; margin: 2.5rem auto 1.5rem auto; border: 2px solid var(--color-border); border-radius: var(--border-radius); box-shadow: var(--shadow-md); cursor: pointer; transition: transform 0.2s ease; }
        #modal-content .final-image:hover { transform: scale(1.03); box-shadow: var(--shadow-lg); }
        #modal-content .image-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 180px; margin: 2.5rem auto 1.5rem auto; color: var(--color-text-muted); }
        #modal-content .image-placeholder .spinner { border: 5px solid rgba(210, 180, 140, 0.6); width: 45px; height: 45px; border-radius: 50%; border-left-color: var(--color-primary); animation: spin 1s linear infinite; margin-bottom: 0.8rem; }
        #modal-content .image-placeholder .placeholder-icon { font-size: 3rem; color: var(--color-tertiary);}

        /* Chat Section */
        #chat-section { border-top: 1px dashed var(--color-border); padding-top: 1.2rem; margin-top: 1.5rem; flex-shrink: 0; display: flex; flex-direction: column; max-height: 280px; }
        #chat-history { flex-grow: 1; overflow-y: auto; margin-bottom: 1rem; padding: 0.8rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: rgba(253, 245, 230, 0.5); scroll-behavior: smooth; scrollbar-width: thin; scrollbar-color: var(--color-secondary) var(--color-border); }
        #chat-history::-webkit-scrollbar { width: 8px; }
        #chat-history::-webkit-scrollbar-track { background: var(--color-border); border-radius: var(--border-radius); }
        #chat-history::-webkit-scrollbar-thumb { background-color: var(--color-secondary); border-radius: var(--border-radius); }
        .chat-message { margin-bottom: 0.7rem; padding: 0.6rem 1rem; border-radius: var(--border-radius); max-width: 88%; word-wrap: break-word; line-height: 1.6; font-size: 1rem; font-family: 'EB Garamond'; }
        .user-message { background-color: var(--color-tertiary); color: var(--color-text); margin-left: auto; text-align: right; border-radius: var(--border-radius) 0 var(--border-radius) var(--border-radius); }
        .ai-message { background-color: #E1F5FE; /* Light Blue Ki-like */ color: var(--color-text); margin-right: auto; text-align: left; border-radius: 0 var(--border-radius) var(--border-radius) var(--border-radius); }
        .chat-error { color: var(--color-error-text); font-style: italic; text-align: center; font-size: 0.9em; }
        #chat-input-area { display: flex; gap: 0.6rem; }
        #chat-input { flex-grow: 1; padding: 0.7rem 1rem; border: 1px solid var(--color-border); background-color: white; color: var(--color-text); border-radius: var(--border-radius); font-family: 'EB Garamond'; font-size: 1rem; }
        #chat-input:focus { outline: none; border-color: var(--color-secondary); box-shadow: 0 0 0 2px rgba(30, 144, 255, 0.2); }
        #chat-send-btn { padding: 0.7rem 1.2rem; background-color: var(--color-secondary); color: white; border: none; border-radius: var(--border-radius); cursor: pointer; transition: background-color 0.2s ease; font-size: 1rem; }
        #chat-send-btn:hover:not(:disabled) { background-color: #1C7ED6; }
        #chat-send-btn:disabled { background-color: var(--color-text-muted); cursor: not-allowed; }
        #chat-loading { text-align: center; padding: 0.5rem; font-size: 0.9em; color: var(--color-text-muted); display: none; font-family: 'Orbitron'; }
        #chat-loading .fa-spinner { margin-right: 0.5rem; }

        /* Loading Overlay con Puzzle */
        #modal-loading { text-align: center; padding: 1rem; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(253, 245, 230, 0.98); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 55; border-radius: var(--border-radius); }
        #modal-loading.active { display: flex; }
        #loading-status { margin-bottom: 1.5rem; }
        #loading-text { font-weight: 700; color: var(--color-primary); font-size: 1.4rem; margin-bottom: 0.6rem; }
        #puzzle-score-level { font-weight: 400; color: var(--color-secondary); font-size: 1.1rem; font-family: 'Orbitron'; }
        #puzzle-canvas { background-color: #EAE0C8; border: 3px solid var(--color-secondary); border-radius: 5px; display: block; margin-bottom: 1.5rem; box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.15); }
        #loading-final-text { font-weight: 400; color: var(--color-text-muted); font-size: 1rem; font-family: 'EB Garamond'; font-style: italic; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .error-msg { background-color: var(--color-error-bg); color: var(--color-error-text); padding: 1.2rem; border-radius: var(--border-radius); border: 1px solid var(--color-error-border); margin-top: 1.5rem; text-align: center; flex-shrink: 0; font-weight: 400; font-family: 'EB Garamond'; }
        .error-msg i { margin-right: 0.7rem; }
        .content-hidden { display: none !important; }
        .title-item.hidden { display: none; }

        /* Fullscreen Image Overlay */
        #image-fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(50, 30, 10, 0.96); /* Dark Sepia */ display: none; align-items: center; justify-content: center; z-index: 100; padding: 2rem; cursor: zoom-out; }
        #image-fullscreen-overlay.active { display: flex; }
        #fullscreen-image { max-width: 95%; max-height: 95%; object-fit: contain; border: 3px solid var(--color-tertiary); box-shadow: var(--shadow-lg); }
        #fullscreen-close-btn { position: absolute; top: 25px; right: 30px; background: var(--color-modal-bg); border: 1px solid var(--color-tertiary); border-radius: 50%; width: 45px; height: 45px; font-size: 2rem; color: var(--color-text); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); }
        #fullscreen-close-btn:hover { background-color: var(--color-tertiary); color: var(--color-secondary); transform: scale(1.1); }

        /* Unlock Modal */
        #unlock-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(74, 74, 74, 0.88); display: none; align-items: center; justify-content: center; z-index: 70; padding: 1rem; font-family: 'EB Garamond', serif; }
        #unlock-modal.active { display: flex; }
        .unlock-modal-content { background-color: var(--color-modal-bg); padding: 2.5rem 2rem 2rem 2rem; border-radius: var(--border-radius); box-shadow: var(--shadow-lg); text-align: center; max-width: 500px; width: 90%; position: relative; border: 2px solid var(--color-border); }
        .unlock-modal-close-btn { position: absolute; top: 10px; right: 10px; background: transparent; border: none; font-size: 1.8rem; color: var(--color-text-muted); cursor: pointer; line-height: 1; transition: color 0.2s ease; }
        .unlock-modal-close-btn:hover { color: var(--color-primary); }
        #unlock-modal h3 { font-family: 'Orbitron', sans-serif; color: var(--color-primary); font-size: 1.7rem; margin-bottom: 1rem; }
        #unlock-modal p { color: var(--color-text); margin-bottom: 1.8rem; line-height: 1.7; font-size: 1.1rem; }
        #unlock-ad-button { background: linear-gradient(45deg, var(--color-primary), var(--color-secondary)); color: white; padding: 0.9rem 2.2rem; border: none; border-radius: var(--border-radius); font-family: 'Orbitron', sans-serif; font-size: 1.2rem; cursor: pointer; transition: var(--transition-normal); margin-bottom: 1.8rem; display: inline-block; box-shadow: var(--shadow-md); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #unlock-ad-button:hover:not(:disabled) { background: linear-gradient(45deg, var(--color-secondary), var(--color-primary)); box-shadow: var(--shadow-lg); transform: translateY(-2px); }
        #unlock-ad-button:disabled { background: var(--color-text-muted); cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none; }
        #unlock-countdown { font-size: 2rem; font-weight: 700; color: var(--color-secondary); font-family: 'Orbitron', sans-serif; min-height: 35px; }
        #unlock-status { font-size: 1rem; color: var(--color-text-muted); margin-top: 0.6rem; font-style: italic; }

    </style>
</head>
<body>
     <!-- Header/Navbar -->
     <nav class="navbar mb-12">
         <div class="container mx-auto px-4 py-4 flex flex-col sm:flex-row justify-between items-center">
             <div class="flex items-center text-center mb-3 sm:mb-0">
                  <h1 class="logo text-3xl sm:text-4xl">
                      <i class="fas fa-atom mr-2 text-blue-500"></i> <!-- Átomo (ciencia/historia) -->
                      <i class="fas fa-bolt mx-1 text-yellow-400"></i> <!-- Rayo (DBZ Ki) -->
                      <i class="fas fa-landmark mr-3 text-orange-500"></i> <!-- Landmark (historia) -->
                      Crossovers Z
                 </h1>
             </div>
             <span class="text-xs text-gray-600 font-sans tracking-wider uppercase">» ¡Líneas Temporales Alteradas! «</span>
         </div>
     </nav>

     <!-- Main content -->
     <main class="container mx-auto px-4 pb-16">
         <!-- Hero section -->
         <section class="mb-12 text-center">
             <h1 class="page-title text-5xl sm:text-6xl mb-5">Historia & Ki Infinito</h1>
             <p class="text-xl text-gray-700 mb-8 max-w-4xl mx-auto font-light italic">¿Qué pasaría si las figuras más grandes de la historia dominaran las técnicas de Dragon Ball? ¡Explora estos escenarios imposibles!</p>
         </section>

         <!-- Search Bar -->
         <section id="search-container" class="mb-10 max-w-2xl mx-auto">
             <input type="text" id="search-input" placeholder="Buscar figura histórica, técnica DBZ, evento...">
             <i class="fas fa-search"></i>
         </section>

         <!-- Title List Container -->
         <section class="mb-10">
             <h2 class="section-title text-3xl sm:text-4xl mb-8 text-center mx-auto">
                 <i class="fas fa-scroll text-orange-600 mr-2"></i> <!-- Scroll histórico -->
                 Crónicas Interdimensionales
             </h2>
             <div id="title-list">
                  <p id="titles-loading" class="text-gray-500 col-span-full text-center text-lg font-sans">Consultando los archivos de Trunks del Futuro...</p>
                  <!-- Los .title-item se añadirán aquí -->
             </div>
             <p id="no-results" class="text-gray-500 col-span-full text-center text-lg mt-4 hidden font-sans">» Esa línea temporal no existe... ¡aún! «</p>
             <div id="generate-more-container" class="text-center mt-8">
                 <button id="generate-more-btn">
                      <!-- Icon managed dynamically via JS -->
                     Descubrir Más Crossovers (40)
                  </button>
             </div>
         </section>
     </main>

     <!-- Explanation Modal (Principal) -->
     <div id="story-modal">
         <div class="modal-content-wrapper">
             <button class="modal-close-btn" id="modal-close" aria-label="Cerrar">&times;</button>
             <!-- Loading Overlay con Puzzle -->
             <div id="modal-loading">
                 <div id="loading-status">
                     <p id="loading-text">Calculando Poder de Pelea...</p>
                     <p id="puzzle-score-level">Nivel: 1 | Puntos: 0 / 1000</p>
                 </div>
                 <canvas id="puzzle-canvas" width="300" height="300"></canvas> <!-- Puzzle temático -->
                 <p id="loading-final-text">Mientras la línea temporal carga, ¡fusiona los iconos!</p>
             </div>
             <!-- Content Area Wrapper -->
             <div id="modal-story-content-area" class="content-hidden flex flex-col flex-grow min-h-0">
                 <!-- Scrollable Text Area -->
                 <div id="modal-content-area">
                     <h2 id="modal-title" class="text-xl md:text-2xl font-bold mb-4 text-center flex-shrink-0"></h2>
                     <div id="modal-content"></div>
                 </div>
                 <!-- Chat Section -->
                 <div id="chat-section">
                      <h3 class="text-lg font-semibold text-center mb-2 text-secondary font-orbitron">Pregúntale al Cronista Z</h3>
                     <div id="chat-history"></div>
                     <div id="chat-loading"><i class="fas fa-spinner fa-spin"></i> Consultando a Whis...</div>
                     <div id="chat-input-area">
                         <input type="text" id="chat-input" placeholder="Más detalles sobre este crossover...">
                         <button id="chat-send-btn" aria-label="Enviar Consulta"><i class="fas fa-paper-plane"></i></button>
                     </div>
                 </div>
                 <!-- Error Display Area -->
                 <div id="modal-error" class="error-msg content-hidden mt-4 flex-shrink-0">
                     <i class="fas fa-exclamation-triangle"></i>
                     <span id="modal-error-message"></span>
                 </div>
             </div>
         </div>
     </div>

      <!-- Unlock Modal -->
      <div id="unlock-modal">
          <div class="unlock-modal-content">
              <button class="unlock-modal-close-btn" id="unlock-modal-close" aria-label="Cerrar">&times;</button>
              <h3><i class="fas fa-dragon mr-2 text-green-600"></i> Desbloquear Línea Temporal</h3>
              <p>¡Este evento requiere energía! Haz clic en "ANUNCIO" y espera 5 segundos para canalizarla y acceder.</p>
              <button id="unlock-ad-button">
                  <i class="fas fa-bolt mr-2"></i> ANUNCIO (Canalizar Ki)
              </button>
              <div id="unlock-countdown"></div>
              <div id="unlock-status"></div>
              <input type="hidden" id="unlock-target-title" value="">
          </div>
      </div>

      <!-- Fullscreen Image Overlay (sin cambios) -->
      <div id="image-fullscreen-overlay">
          <button id="fullscreen-close-btn" aria-label="Cerrar Imagen">&times;</button>
          <img id="fullscreen-image" src="" alt="Imagen Ampliada del Crossover">
      </div>

      <!-- Footer -->
      <footer class="bg-gray-900 text-gray-400 py-6 mt-12 border-t border-gray-700 font-sans">
          <div class="container mx-auto px-4 text-center text-sm">
              <p>Narrativas hipotéticas generadas por IA fusionando figuras históricas y el universo Dragon Ball.</p>
              <p class="mt-1">Estos crossovers son puramente especulativos y para entretenimiento. Disfruta la fusión.</p>
              <p class="mt-2">© 2025 Corporación Cápsula Histórica</p>
          </div>
      </footer>

    <script>
        // ========== CONFIG & DATA ==========
        const adUrl = 'https://increasingbelieveabonnement.com/pcmu77j4?key=1f38fa224b5ecf757563a32d2d8ac126';
        const unlockCountdownSeconds = 5;
        const lockPercentage = 0.7; // 70% initially locked
        const themePrefix = 'HistDBZ'; // Unique prefix for this theme
        const userUnlockedKey = `unlockedTitles_${themePrefix}`;
        const initialLockStateSetFlagKey = `initialLockStateSet_${themePrefix}`;
        const initialLockedSetKey = `initialLockedSet_${themePrefix}`;

        const predefinedTitles = [
            // Super Saiyan History
            "Napoleón Bonaparte alcanza el Super Saiyan en Waterloo", "Reina Victoria como Super Saiyan 2: El Imperio Indomable", "Julio César declara 'Veni, Vidi, Super Saiyan!'", "Genghis Khan aprende el Kaioken x10 para unificar las tribus", "Juana de Arco recibe una visión... y poder Super Saiyan Divino", "Abraham Lincoln: El Super Saiyan Honesto contra la división", "Winston Churchill: 'Lucharemos en las playas... ¡en Super Saiyan!'", "Cleopatra usa el Super Saiyan 3 para seducir a Cell", "Mozart compone la 'Sinfonía del Super Saiyan'", "Shakespeare escribe 'Hamlet: Príncipe de los Saiyans'",
            // Ki & Techniques
            "Albert Einstein calcula la fórmula del Kamehameha", "Isaac Newton descubre la gravedad... en el Planeta Kaio", "Leonardo da Vinci diseña un Scouter mejorado", "Nikola Tesla desarrolla la Genkidama Eléctrica", "Marie Curie investiga la radiación... del Ki Divino", "Arquímedes grita '¡Eureka!' al dominar la Teletransportación Instantánea", "Hipatia de Alejandría enseña Matemáticas y Control de Ki", "Galileo Galilei observa las lunas de Júpiter... y el Planeta Vegeta", "Beethoven queda sordo pero siente las vibraciones del Ultra Instinto", "Charles Darwin teoriza sobre la evolución Saiyan",
            // Fusion & Potara
            "Fusión Metamoru: ¡Carlomagno y Roland forman a 'Carloland'!", "Pendientes Potara: Reina Isabel I y Francis Drake se fusionan", "Alejandro Magno y Hefestión: La Fusión Conquistadora", "Los hermanos Wright realizan la Fusión para el primer vuelo Saiyan", "Karl Marx y Friedrich Engels: La Fusión Comunista Definitiva", "Simón Bolívar y San Martín: Fusión Libertadora 'Bolivartín'", "Marco Polo trae la técnica de Fusión de Oriente", "Lewis y Clark exploran el Oeste... ¡fusionados!", "Marie Antoinette y Luis XVI: Fusión 'Que coman Pastel Final Flash!'", "Ada Lovelace programa el algoritmo de la Fusión Perfecta",
            // Villanos y Desafíos
            "Rasputín sobrevive a todo... ¿es un Majin?", "Barbanegra el Pirata busca las Esferas del Dragón", "Jack el Destripador usa la Teletransportación para escapar", "Hernán Cortés enfrenta a los Aztecas... ¿y a Nappa?", "Nerón toca la lira mientras Roma arde... ¿bajo ataque de Freezer?", "Calígula nombra cónsul a su caballo... ¿poseído por Babidi?", "Atila el Huno: ¿El Dios de la Destrucción original?", "Vlad el Empalador aprende técnicas de Ki para torturar", "Lucrecia Borgia usa venenos... ¿y el Makankosappo?", "Billy the Kid desafía a Goku a un duelo al mediodía",
            // Shen Long & Deseos
            "Cristóbal Colón pide a Shen Long encontrar las Indias... y termina en Namek", "La Reina de Saba pide sabiduría a Shen Long... y obtiene un Scouter", "Moisés pide a Shen Long separar el Mar Rojo... con un Kamehameha", "El Rey Midas pide que todo lo que toque sea Katchin", "Ponce de León busca la Fuente de la Juventud... pide la inmortalidad a Porunga", "Nostradamus predice la llegada de los Saiyans", "Tutankamón es revivido por las Esferas del Dragón... ¡otra vez!", "Confucio pide armonía universal a Shen Long", "Platón pide conocer la 'Forma' del Super Saiyan", "Juana de Arco pide la victoria para Francia... Shen Long le da una Espada de Ki",
            // Entrenamiento y Maestros
            "Sócrates enseña filosofía... y el Método Kaio", "Buda alcanza la iluminación... y el Ultra Instinto", "Sun Tzu escribe 'El Arte de la Guerra Z'", "Maquiavelo aconseja a Vegeta sobre cómo ser Príncipe", "Hipócrates jura proteger la vida... y curar con Semillas del Ermitaño", "Miguel Ángel esculpe a David... en pose de ataque de Ki", "Homero narra la 'Odisea Saiyan'", "Virgilio guía a Dante por el Infierno... y el Otro Mundo de DBZ", "Emily Dickinson escribe poemas sobre la soledad del entrenamiento hiperbólico", "Jane Austen describe bailes de sociedad... y Torneos de Poder",
            // Tecnología Capsule Corp
            "Benjamin Franklin inventa el pararrayos... y la Cápsula Corp.", "Los hermanos Montgolfier usan una Cápsula Corp para su globo", "Henry Ford produce coches en masa... y Naves Saiyan", "Thomas Edison inventa la bombilla... y el Scouter", "Alexander Graham Bell inventa el teléfono... para llamar a Bulma", "Guglielmo Marconi transmite radio... y mensajes telepáticos Kaio", "Steve Jobs presenta el 'iScouter'", "Bill Gates desarrolla 'Microsoft Ki-nergy'", "Elon Musk planea colonizar Marte... y Namek", "Jeff Bezos entrega paquetes con la Nube Kinton",
            // Escenarios Absurdos
            "La Mona Lisa sonríe... ¿al ver un combate Z?", "Van Gogh pinta 'Noche Estrellada sobre el Planeta Vegeta'", "El Grito de Munch... al sentir el Ki de Broly", "Picasso pinta 'Guernica'... después de un ataque Saiyan", "La Revolución Francesa... ¿iniciada por un Oozaru?", "La Fiebre del Oro de California... ¿buscando Esferas del Dragón?", "El hundimiento del Titanic... ¿chocó con una Nave de Freezer?", "El primer alunizaje... ¿interrumpido por Pilaf?", "Stonehenge... ¿una plataforma de aterrizaje Saiyan?", "Las pirámides de Egipto... ¿construidas con ayuda de Ki?",
            //... (Más ejemplos)
            "Gandhi practica la Resistencia Pacífica... ¿contra Raditz?", "Martin Luther King tiene un sueño... de igualdad Saiyan y Humana", "Nelson Mandela lucha contra el Apartheid... y el Imperio de Freezer?", "Malala Yousafzai defiende la educación... y el entrenamiento con Piccolo?", "Florence Nightingale cura heridos... con magia Namekiana?", "Amelia Earhart desaparece... ¿en otra dimensión del Torneo?", "Frida Kahlo pinta sus heridas... y cicatrices de batalla Z?", "Simone de Beauvoir analiza el 'Segundo Sexo'... Saiyan?", "Rosa Parks se niega a ceder su asiento... en una Nave Saiyan?", "Harriet Tubman guía esclavos a la libertad... ¿con la Teletransportación?",
            "Copérnico revoluciona la astronomía... el Sistema Solar y los 12 Universos?", "Kepler calcula órbitas planetarias... ¿incluyendo Namek?", "Lavoisier funda la química moderna... ¿analiza el Ki?", "Mendel estudia la genética... ¿de híbridos Saiyan-Humanos?", "Pasteur desarrolla vacunas... ¿contra virus del corazón Saiyan?", "Los hermanos Lumière filman la primera película... ¿'La Llegada de Goku'?", "Alfred Nobel inventa la dinamita... ¿y el Kikohō?", "Orwell escribe '1984'... ¿sobre el Gran Patriarca?", "Huxley escribe 'Un Mundo Feliz'... ¿con Cápsulas Corp?", "Tolstoi escribe 'Guerra y Paz'... ¿entre Saiyans y Terrícolas?",
            "Marco Aurelio medita sobre el Estoicismo... y el Ki", "Séneca escribe sobre la brevedad de la vida... antes de que Cell lo absorba", "Epicteto enseña control interno... útil contra Babidi", "Diógenes busca un hombre honesto... ¿o un Super Saiyan?", "Heráclito dice que todo fluye... como el Ki", "Demócrito teoriza sobre átomos... y partículas de Ki", "Pitágoras descubre teoremas... ¿y la geometría de las poses de Fusión?", "Euclides sistematiza la geometría... ¿del Espacio y Tiempo Hiperbólico?", "Zaratustra habla del Bien y del Mal... ¿Goku vs. Freezer?", "Lao Tse habla del Tao... ¿el flujo del Ki universal?"
        ];
        const crossoverThemes = [
            "Super Saiyan historia", "Ki control histórico", "Fusión histórica", "Shen Long deseos históricos", "Villanos DBZ historia", "Entrenamiento histórico DBZ", "Tecnología Capsule Corp historia", "Ciencia histórica DBZ", "Filosofía histórica DBZ", "Arte histórico DBZ", "Conquista histórica Saiyan", "Revolución histórica Ki", "Mitología DBZ historia", "Exploración espacial histórica DBZ", "Política histórica Saiyan"
        ];
        const textApiConfig = { model: "mistral", systemPrompt: "Eres un Cronista Interdimensional Z, un narrador erudito con acceso a líneas temporales alternativas donde figuras históricas interactúan con el universo Dragon Ball. Describe el escenario crossover consultado con un estilo épico y entretenido. Mezcla detalles 'históricos' (adaptados) con el lore, poderes y tecnología de Dragon Ball. Sé imaginativo, detalla las interacciones, los choques culturales/poder, y las consecuencias de esta fusión temporal. Usa terminología de ambos mundos. Extensión objetivo: 1200-1300 palabras. Describe el crossover:", timeoutSeconds: 180 };
        const chatApiConfig = { model: "mistral-tiny", systemPrompt: "Actúa como el asistente del Cronista Z. Responde preguntas específicas sobre el crossover histórico-DBZ recién narrado. Clarifica detalles sobre los poderes adaptados, las reacciones de los personajes, las alteraciones históricas o la terminología Z utilizada. Sé conciso, mantén el tono del crossover y céntrate estrictamente en la línea temporal descrita.", timeoutSeconds: 45 };
        const titleGenerationConfig = { model: "mistral", systemPrompt: "Genera una lista concisa de 40 ideas creativas para crossovers entre figuras/eventos históricos y el universo Dragon Ball (personajes, poderes, objetos, situaciones). Devuelve *solo* la lista de ítems, uno por línea. Sin números, guiones, introducciones ni despedidas.", timeoutSeconds: 60 };

        // Puzzle Colors (Crossover Theme)
        const puzzleColors = ['#FF8C00', '#1E90FF', '#FFD700', '#FDF5E6', '#8B4513', '#4CAF50']; // Naranja, Azul, Dorado, Pergamino, Marrón (Historia), Verde (Namek/Shenlong)
        // *** CORRECTION: Use Unicode characters for Font Awesome, not HTML tags ***
        const puzzleSymbols = [
            '\uf66f', // fas fa-landmark
            '\uf0e7', // fas fa-bolt (Ki)
            '\uf6d5', // fas fa-dragon
            '\uf70e', // fas fa-scroll
            '\uf5d2', // fas fa-atom
            '\uf46b'  // fas fa-capsules
        ];

        // ========== DOM ELEMENTS ==========
        const searchInput = document.getElementById('search-input');
        const titleListContainer = document.getElementById('title-list');
        const titlesLoading = document.getElementById('titles-loading');
        const noResultsMsg = document.getElementById('no-results');
        const generateMoreContainer = document.getElementById('generate-more-container');
        const generateMoreBtn = document.getElementById('generate-more-btn');
        const storyModal = document.getElementById('story-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const modalLoadingIndicator = document.getElementById('modal-loading');
        const modalStoryContentArea = document.getElementById('modal-story-content-area');
        const modalTextArea = document.getElementById('modal-content-area');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalError = document.getElementById('modal-error');
        const modalErrorMessage = document.getElementById('modal-error-message');
        const chatSection = document.getElementById('chat-section');
        const chatHistory = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatLoadingIndicator = document.getElementById('chat-loading');
        const imageFullscreenOverlay = document.getElementById('image-fullscreen-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
        const puzzleCanvas = document.getElementById('puzzle-canvas');
        const loadingText = document.getElementById('loading-text');
        const puzzleScoreLevelText = document.getElementById('puzzle-score-level');
        const unlockModal = document.getElementById('unlock-modal');
        const unlockModalCloseBtn = document.getElementById('unlock-modal-close');
        const unlockAdButton = document.getElementById('unlock-ad-button');
        const unlockCountdownDisplay = document.getElementById('unlock-countdown');
        const unlockStatusDisplay = document.getElementById('unlock-status');
        const unlockTargetTitleInput = document.getElementById('unlock-target-title');

        // ========== PUZZLE GAME LOGIC ==========
        const PuzzleGame = {
            canvas: null, ctx: null, scoreLevelElement: null,
            gridSize: 8, tileTypes: 6, // Number of different symbols/colors
            tileSize: 36, // Auto-calculated in init
            tiles: [], selectedTile: null,
            isSwapping: false, isDropping: false, isRunning: false,
            score: 0, level: 1, pointsPerLevel: 1000,
            comboMultiplier: 1, gameLoopInterval: null, lastFrameTime: 0,
            // Using the colors/symbols defined above
            tileColors: puzzleColors,
            tileSymbols: puzzleSymbols,

            init(canvasElement, scoreLevelElementRef) {
                if (!canvasElement || !scoreLevelElementRef) {
                    console.error("PuzzleGame Init Error: Canvas or Score element not found.");
                    return;
                }
                this.canvas = canvasElement;
                this.scoreLevelElement = scoreLevelElementRef;
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error("PuzzleGame Init Error: Could not get 2D context.");
                    return;
                }
                // Calculate tileSize based on canvas size and gridSize
                this.tileSize = this.canvas.width / this.gridSize;
                this.canvas.height = this.tileSize * this.gridSize; // Ensure aspect ratio

                // Add click listener
                this.canvas.removeEventListener('click', this.boundHandleClick); // Prevent duplicates
                this.boundHandleClick = this.handleClick.bind(this); // Store bound function
                this.canvas.addEventListener('click', this.boundHandleClick);

                console.log("Puzzle Game Initialized. TileSize:", this.tileSize);
            },

             // --- CORRECTION: Corrected draw method ---
             draw() {
                 if (!this.ctx || !this.canvas) return;
                 this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                 for (let r = 0; r < this.gridSize; r++) {
                     for (let c = 0; c < this.gridSize; c++) {
                         if (this.tiles[r] && this.tiles[r][c] !== null) {
                             const x = c * this.tileSize;
                             const y = r * this.tileSize;
                             const tileType = this.tiles[r][c]; // Should be an index (0-5)

                             if (tileType < 0 || tileType >= this.tileColors.length) {
                                 //console.warn(`Invalid tileType ${tileType} at ${r},${c}`);
                                 continue; // Skip drawing invalid tiles
                             }

                             // Draw background color
                             this.ctx.fillStyle = this.tileColors[tileType];
                             this.ctx.fillRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);
                             this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                             this.ctx.strokeRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);

                             // Set font for Font Awesome *BEFORE* drawing text
                             // Ensure Font Awesome 6 Free is used as linked in <head>
                             this.ctx.font = `normal normal normal ${this.tileSize * 0.6}px "Font Awesome 6 Free"`;
                             this.ctx.textAlign = 'center';
                             this.ctx.textBaseline = 'middle';

                             // Determine icon color based on background
                             const bgColor = this.tileColors[tileType].toUpperCase();
                             // Simple check: White for dark, Black for light (adjust hex codes as needed)
                             if (bgColor === '#FDF5E6' || bgColor === '#FFD700' || bgColor === '#4CAF50') {
                                  this.ctx.fillStyle = '#000000'; // Black icon on light backgrounds
                             } else {
                                  this.ctx.fillStyle = '#FFFFFF'; // White icon on dark backgrounds
                             }

                             // Get the Unicode character from the puzzleSymbols array
                             const symbolChar = this.tileSymbols[tileType];
                             this.ctx.fillText(symbolChar, x + this.tileSize / 2, y + this.tileSize / 2 + 1); // Adjust y slightly if needed

                             // Draw highlight if selected
                             if (this.selectedTile && this.selectedTile.r === r && this.selectedTile.c === c) {
                                 this.ctx.strokeStyle = '#00FF00'; // Green highlight
                                 this.ctx.lineWidth = 3;
                                 this.ctx.strokeRect(x + 1, y + 1, this.tileSize - 2, this.tileSize - 2);
                                 this.ctx.lineWidth = 1; // Reset line width
                             }
                         }
                     }
                 }
             },

             start() {
                if (this.isRunning || !this.ctx) return;
                console.log("Starting Puzzle Game");
                this.isRunning = true;
                this.score = 0;
                this.level = 1;
                this.comboMultiplier = 1;
                this.selectedTile = null;
                this.isSwapping = false;
                this.isDropping = false;
                this.updateScoreLevelDisplay();
                this.initBoard();
                // Initial check and fill
                while(this.findAndClearMatches(false)){ // Don't add score on initial clear
                     this.dropTiles();
                }
                this.score = 0; // Reset score after initial clear
                this.updateScoreLevelDisplay();

                this.lastFrameTime = performance.now();
                // Cancel previous frame request if any
                if (this.gameLoopInterval) cancelAnimationFrame(this.gameLoopInterval);
                this.gameLoopInterval = requestAnimationFrame(this.gameLoop.bind(this));
             },

            stop() {
                if (!this.isRunning) return;
                console.log("Stopping Puzzle Game");
                this.isRunning = false;
                if (this.gameLoopInterval) {
                    cancelAnimationFrame(this.gameLoopInterval);
                    this.gameLoopInterval = null;
                }
                // Optionally clear the canvas on stop
                if(this.ctx) this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },

            gameLoop(currentTime) {
                if (!this.isRunning) return;
                const deltaTime = (currentTime - this.lastFrameTime) / 1000; // Delta time in seconds
                this.lastFrameTime = currentTime;

                this.update(deltaTime); // Update game state
                this.draw(); // Render the game

                this.gameLoopInterval = requestAnimationFrame(this.gameLoop.bind(this));
            },

            update(deltaTime) {
                // Core game logic update loop
                if (this.isSwapping || this.isDropping) {
                    // Waiting for animations/actions to complete (if we add them)
                    // For now, just prevent further actions
                    return;
                }

                // Find and clear matches
                if (this.findAndClearMatches()) {
                    this.isDropping = true; // Set flag before dropping
                    this.dropTiles();
                    this.isDropping = false; // Clear flag after dropping
                    this.comboMultiplier++; // Increase combo for consecutive matches
                } else {
                     if (!this.checkForPossibleMoves()) {
                        console.log("No possible moves! Reshuffling board (implement if needed)... or ending game?");
                        // Optionally: Reshuffle board here if no moves are left
                     }
                    this.comboMultiplier = 1; // Reset combo if no matches were found
                }

                 // Level up check
                if (this.score >= this.level * this.pointsPerLevel) {
                    this.level++;
                    console.log("Level Up! Reached Level", this.level);
                    // Maybe increase difficulty slightly? (e.g., faster drops, fewer points per match)
                    this.updateScoreLevelDisplay();
                }
            },

            initBoard() {
                this.tiles = [];
                for (let r = 0; r < this.gridSize; r++) {
                    this.tiles[r] = [];
                    for (let c = 0; c < this.gridSize; c++) {
                         do {
                              this.tiles[r][c] = this.getRandomTileType();
                          } while ( // Ensure no initial matches are created horizontally or vertically
                              (c >= 2 && this.tiles[r][c] === this.tiles[r][c-1] && this.tiles[r][c] === this.tiles[r][c-2]) ||
                              (r >= 2 && this.tiles[r][c] === this.tiles[r-1][c] && this.tiles[r][c] === this.tiles[r-2][c])
                          );
                    }
                }
                console.log("Board Initialized");
            },

            // Simplified initial match check used within initBoard
            // checkForInitialMatches() { ... } // Not needed if initBoard prevents them directly

            getRandomTileType() {
                return Math.floor(Math.random() * this.tileTypes); // Returns 0 to tileTypes-1
            },

            handleClick(event) {
                if (!this.isRunning || this.isSwapping || this.isDropping) return; // Ignore clicks during transitions

                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Convert click coordinates to grid coordinates
                const c = Math.floor(x / this.tileSize);
                const r = Math.floor(y / this.tileSize);

                // Check if click is within bounds
                if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) {
                     this.selectedTile = null; // Click outside bounds deselects
                     this.draw(); // Redraw to remove highlight
                     return;
                 }

                if (!this.selectedTile) {
                    // First click: Select the tile
                    this.selectedTile = { r, c };
                    console.log("Selected:", r, c);
                } else {
                    // Second click: Attempt a swap or deselect
                    const dr = Math.abs(r - this.selectedTile.r);
                    const dc = Math.abs(c - this.selectedTile.c);

                    if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                        // Adjacent tile clicked: Attempt swap
                        this.attemptSwap(this.selectedTile.r, this.selectedTile.c, r, c);
                    } else {
                        // Non-adjacent tile or same tile clicked
                         if(this.selectedTile.r === r && this.selectedTile.c === c) {
                             this.selectedTile = null; // Deselect if clicking the same tile
                         } else {
                              this.selectedTile = { r, c }; // Select the new tile
                              console.log("Selected new:", r, c);
                          }
                    }
                }
                this.draw(); // Redraw to show selection highlight changes
            },

            attemptSwap(r1, c1, r2, c2) {
                if (!this.tiles[r1] || !this.tiles[r2] || this.tiles[r1][c1] === null || this.tiles[r2][c2] === null) return; // Prevent swapping empty space

                this.isSwapping = true; // Prevent other actions during swap logic
                // Swap tiles in the grid data
                [this.tiles[r1][c1], this.tiles[r2][c2]] = [this.tiles[r2][c2], this.tiles[r1][c1]];

                // Check if the swap resulted in any matches involving the swapped tiles
                const matchFound = this.checkForMatchesAfterSwap(r1, c1) || this.checkForMatchesAfterSwap(r2, c2);

                if (matchFound) {
                    console.log("Valid Swap - Match found!");
                    // Keep the swap, clear matches immediately
                    this.findAndClearMatches(); // Clear all matches on board
                    // Initiate tile drop AFTER clearing
                    this.isDropping = true;
                    this.dropTiles();
                    this.isDropping = false;

                    this.selectedTile = null; // Deselect after successful swap
                } else {
                    console.log("Invalid Swap - No match formed");
                    // Swap back immediately
                    [this.tiles[r1][c1], this.tiles[r2][c2]] = [this.tiles[r2][c2], this.tiles[r1][c1]];
                    this.selectedTile = null; // Deselect after failed swap
                }
                this.isSwapping = false; // Allow actions again
                this.draw(); // Redraw the board with the result of the swap attempt
            },

             // Check if the tile at (r, c) is part of a horizontal or vertical match of 3 or more
             checkForMatchesAfterSwap(r, c) {
                if (!this.tiles[r] || this.tiles[r][c] === null) return false;
                const tileType = this.tiles[r][c];

                // Check Horizontal
                let hCount = 1;
                // Check left
                for (let i = c - 1; i >= 0 && this.tiles[r][i] === tileType; i--) hCount++;
                // Check right
                for (let i = c + 1; i < this.gridSize && this.tiles[r][i] === tileType; i++) hCount++;
                if (hCount >= 3) return true; // Found horizontal match

                // Check Vertical
                let vCount = 1;
                // Check up
                for (let i = r - 1; i >= 0 && this.tiles[i] && this.tiles[i][c] === tileType; i--) vCount++;
                // Check down
                for (let i = r + 1; i < this.gridSize && this.tiles[i] && this.tiles[i][c] === tileType; i++) vCount++;
                if (vCount >= 3) return true; // Found vertical match

                return false; // No match found involving this tile
            },

             // Finds *all* matches on the board, marks them for clearing, adds score
            findAndClearMatches(addScore = true) {
                let matchesFound = false;
                const tilesToClear = new Set(); // Use a Set to avoid duplicates

                // Find Horizontal Matches
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize - 2; c++) {
                        if (this.tiles[r][c] !== null && this.tiles[r][c] === this.tiles[r][c+1] && this.tiles[r][c] === this.tiles[r][c+2]) {
                             matchesFound = true;
                             let length = 3;
                             while (c + length < this.gridSize && this.tiles[r][c] === this.tiles[r][c+length]) {
                                 length++;
                             }
                             for (let i = 0; i < length; i++) {
                                 tilesToClear.add(`${r}-${c + i}`); // Store coords as string key
                             }
                             c += length - 1; // Skip checked tiles
                        }
                    }
                }

                 // Find Vertical Matches
                 for (let c = 0; c < this.gridSize; c++) {
                     for (let r = 0; r < this.gridSize - 2; r++) {
                         if (this.tiles[r][c] !== null && this.tiles[r][c] === this.tiles[r+1][c] && this.tiles[r][c] === this.tiles[r+2][c]) {
                             matchesFound = true;
                             let length = 3;
                              while (r + length < this.gridSize && this.tiles[r+length] && this.tiles[r][c] === this.tiles[r+length][c]) {
                                 length++;
                             }
                              for (let i = 0; i < length; i++) {
                                 tilesToClear.add(`${r + i}-${c}`); // Store coords as string key
                              }
                              r += length - 1; // Skip checked tiles
                         }
                     }
                 }

                if (matchesFound) {
                    let pointsEarned = 0;
                     tilesToClear.forEach(key => {
                         const [r, c] = key.split('-').map(Number);
                         if (this.tiles[r] && this.tiles[r][c] !== null) {
                             this.tiles[r][c] = null; // Clear the tile
                             pointsEarned += 10; // Base points per tile
                         }
                    });

                    if (addScore) {
                        this.score += pointsEarned * this.comboMultiplier;
                        this.updateScoreLevelDisplay();
                        console.log(`Cleared ${tilesToClear.size} tiles. Score: ${this.score} (Combo x${this.comboMultiplier})`);
                    }
                }
                return matchesFound; // Return true if any matches were cleared
            },

            // Moves tiles down to fill empty spaces and generates new tiles at the top
            dropTiles() {
                this.isDropping = true;
                for (let c = 0; c < this.gridSize; c++) {
                    let emptyRow = this.gridSize - 1; // Start checking from the bottom row

                    // Move existing tiles down
                    for (let r = this.gridSize - 1; r >= 0; r--) {
                        if (this.tiles[r][c] !== null) {
                            // If this tile is not null, move it to the lowest available emptyRow
                            if (r !== emptyRow) {
                                // Swap only if needed
                                this.tiles[emptyRow][c] = this.tiles[r][c];
                                this.tiles[r][c] = null;
                            }
                            emptyRow--; // Move the next 'target' empty row up
                        }
                    }

                    // Fill remaining empty rows from the top
                    for (let r = emptyRow; r >= 0; r--) {
                        this.tiles[r][c] = this.getRandomTileType();
                    }
                }
                 this.isDropping = false;
                 // It's crucial to check for new matches *after* dropping is complete
                 // This is handled in the update() loop, which will call findAndClearMatches again
                 // Don't recursively call find/clear/drop here to avoid infinite loops/stack overflow
            },

            // --- Helper to check if ANY move is possible (for game end / reshuffle) ---
            checkForPossibleMoves() {
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        // Check swap right
                        if (c < this.gridSize - 1) {
                            [this.tiles[r][c], this.tiles[r][c+1]] = [this.tiles[r][c+1], this.tiles[r][c]]; // Tentative swap
                            if (this.checkForMatchesAfterSwap(r, c) || this.checkForMatchesAfterSwap(r, c + 1)) {
                                [this.tiles[r][c], this.tiles[r][c+1]] = [this.tiles[r][c+1], this.tiles[r][c]]; // Swap back
                                return true; // Found a possible move
                            }
                            [this.tiles[r][c], this.tiles[r][c+1]] = [this.tiles[r][c+1], this.tiles[r][c]]; // Swap back
                        }
                        // Check swap down
                        if (r < this.gridSize - 1) {
                           [this.tiles[r][c], this.tiles[r+1][c]] = [this.tiles[r+1][c], this.tiles[r][c]]; // Tentative swap
                            if (this.checkForMatchesAfterSwap(r, c) || this.checkForMatchesAfterSwap(r + 1, c)) {
                                [this.tiles[r][c], this.tiles[r+1][c]] = [this.tiles[r+1][c], this.tiles[r][c]]; // Swap back
                                return true; // Found a possible move
                            }
                           [this.tiles[r][c], this.tiles[r+1][c]] = [this.tiles[r+1][c], this.tiles[r][c]]; // Swap back
                        }
                    }
                }
                return false; // No possible moves found
            },

            updateScoreLevelDisplay() {
                if(this.scoreLevelElement) {
                    this.scoreLevelElement.textContent = `Nivel: ${this.level} | Puntos: ${this.score} / ${this.level * this.pointsPerLevel}`;
                }
            },

             boundHandleClick: null // To store the bound event handler reference
        };

        // ========== State Variables ==========
        let currentTopicTitle = null;
        let initialLockedTitles = loadInitialLockedSet(); // Load persistent set
        let countdownInterval = null;

        // ========== LocalStorage Functions (Unlock Persistence & Initial Lock State) ==========
        function getJsonFromStorage(key) { /* ... (no change) ... */ try { const stored = localStorage.getItem(key); return stored ? JSON.parse(stored) : null; } catch (e) { console.error(`Error reading key ${key} from localStorage:`, e); return null; } }
        function setJsonInStorage(key, value) { /* ... (no change) ... */ try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error(`Error saving key ${key} to localStorage:`, e); } }
        function getUnlockedTitles() { /* ... (no change) ... */ const unlockedArray = getJsonFromStorage(userUnlockedKey); return new Set(unlockedArray || []); }
        function saveUnlockedTitles(unlockedSet) { /* ... (no change) ... */ setJsonInStorage(userUnlockedKey, Array.from(unlockedSet)); }
        function isTitleUnlockedByUser(title) { /* ... (no change) ... */ return getUnlockedTitles().has(title); }
        function unlockTitlePermanentlyByUser(title) { /* ... (no change) ... */ if (!title) return; const unlockedByUser = getUnlockedTitles(); if (!unlockedByUser.has(title)) { unlockedByUser.add(title); saveUnlockedTitles(unlockedByUser); console.log(`Title permanently unlocked by user: ${title}`); updateTitleItemLockStatus(title, false); } }
        function loadInitialLockedSet() { /* ... (no change) ... */ const lockedArray = getJsonFromStorage(initialLockedSetKey); return new Set(lockedArray || []); }
        function saveInitialLockedSet(lockedSet) { /* ... (no change) ... */ setJsonInStorage(initialLockedSetKey, Array.from(lockedSet)); }
        function isInitialLockStateSet() { /* ... (no change) ... */ return localStorage.getItem(initialLockStateSetFlagKey) === 'true'; }
        function setInitialLockStateFlag() { /* ... (no change) ... */ localStorage.setItem(initialLockStateSetFlagKey, 'true'); }
        function isTitleInitiallyLocked(title) { /* ... (no change) ... */ return initialLockedTitles.has(title); }

        // ========== API FUNCTIONS ==========
        async function fetchTextFromApi(prompt, config, isChat = false) { /* ... (no change - maybe increase timeout for title generation?) ... */ const encodedPrompt = encodeURIComponent(prompt); const systemPromptToUse = isChat && currentTopicTitle ? `Actúa como el asistente del Cronista Z. Responde preguntas específicas sobre el crossover '${currentTopicTitle}'. Clarifica detalles, poderes, alteraciones históricas o terminología Z. Sé conciso y mantén el tono.` : config.systemPrompt; const encodedSystem = encodeURIComponent(systemPromptToUse); const params = new URLSearchParams({ model: config.model, system: encodedSystem }); if (config.seed && !isChat) params.append('seed', config.seed); const url = `https://text.pollinations.ai/${encodedPrompt}?${params.toString()}`; console.log(`Fetching text from API (${config.model}, Chat: ${isChat}): ${url.substring(0, 200)}...`); const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), config.timeoutSeconds * 1000); try { const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); if (!response.ok) throw new Error(`(Error ${response.status}) ¡Interferencia en la línea temporal! Los servidores Z están ocupados. Intenta de nuevo.`); const text = await response.text(); if (!text || text.trim().length === 0) throw new Error("El Cronista Z se quedó sin palabras (respuesta vacía). Intenta de nuevo."); console.log(`API Response received (${text.length} chars)`); return text; } catch (error) { clearTimeout(timeoutId); console.error("API Fetch Error:", error); if (error.name === 'AbortError') throw new Error(`La consulta tardó demasiado (>${config.timeoutSeconds}s). La conexión es inestable o Zeno-sama está jugando. Inténtalo de nuevo.`); throw new Error(error.message || "Error desconocido contactando al Otro Mundo digital."); } }
        async function fetchExplanationText(conceptTitle) { return fetchTextFromApi(conceptTitle, textApiConfig, false); }
        async function fetchChatResponse(userQuery) { if (!currentTopicTitle) throw new Error("Error interno: Contexto del Crossover perdido."); return fetchTextFromApi(userQuery, chatApiConfig, true); }
        async function fetchGeneratedTitles() { /* ... (no change) ... */ const randomTheme = getRandomElement(crossoverThemes) || "crossovers históricos aleatorios"; const specificPrompt = `Genera 40 ideas creativas para crossovers entre figuras/eventos históricos y Dragon Ball sobre ${randomTheme}`; const configForThisRequest = { ...titleGenerationConfig, seed: Math.floor(Math.random() * 1000000) }; return fetchTextFromApi(specificPrompt, configForThisRequest, false) .then(text => { const titles = text.split('\n').map(line => line.replace(/^[-\d.\s*]+/, '').trim()).filter(line => line.length > 5 && line.length < 150); if (titles.length < 10) throw new Error("La IA no generó suficientes ideas de líneas temporales."); return titles.slice(0, 40); }); }
        function createPollinationsImageUrl(promptText, options = {}) { /* ... (no change) ... */ const defaults = { seed: Math.floor(Math.random() * 10000000), width: 800, height: 600, nologo: true }; const settings = { ...defaults, ...options }; const safePromptText = typeof promptText === 'string' && promptText.trim() !== '' ? promptText : "Historical figure meets Dragon Ball"; const enhancedPrompt = `Epic digital painting depicting the crossover '${safePromptText}'. Fusion of historical elements (clothing, setting) and Dragon Ball Z style (Ki energy, dynamic poses, iconic visuals like scouters or Dragon Balls if relevant). Use a vibrant color palette mixing historical tones with DBZ energy colors (orange, blue, yellow). Style: dramatic, anime-influenced concept art. No text, logos, words.`; const escapedPrompt = encodeURIComponent(enhancedPrompt); if (!escapedPrompt) return ''; const negativePrompt = "text, words, labels, letters, title, caption, diagram, chart, graph, UI, menu, button, watermark, signature, multiple images, collage, realistic photograph, modern clothing, simple background"; const escapedNegative = encodeURIComponent(negativePrompt); let url = `https://image.pollinations.ai/prompt/${escapedPrompt}?seed=${settings.seed}&width=${settings.width}&height=${settings.height}&negative=${escapedNegative}`; if (settings.nologo) url += '&nologo=true'; console.log("Image URL:", url); return url; }

        // ========== Text Formatting Function ==========
        function formatExplanationText(rawText) { /* ... (no change) ... */ if (!rawText) return ''; let formatted = rawText.trim(); formatted = formatted.replace(/\\text\{(.*?)\}/g, '$1'); formatted = formatted.replace(/(\w)_\{?(\d+)\}?/g, '$1<sub>$2</sub>'); formatted = formatted.replace(/(\w)\^\{?([\d+\-−]+)\}?/g, (match, base, exponent) => { const cleanExponent = exponent.replace('−', '-'); return `${base}<sup>${cleanExponent}</sup>`; }); formatted = formatted.replace(/\\rightarrow/g, '&rarr;'); formatted = formatted.replace(/\\\[\s*(.*?)\s*\\\]/g, '<p class="formula" style="text-align: center; margin: 1em 0;">$1</p>'); formatted = formatted.replace(/^####\s+(.*)$/gm, '<h4>$1</h4>'); formatted = formatted.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>'); formatted = formatted.replace(/^##\s+(.*)$/gm, '<h2>$1</h2>'); formatted = formatted.replace(/^#\s+(.*)$/gm, '<h1>$1</h1>'); formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>'); const blocks = formatted.split(/\n\s*\n/).filter(p => p.trim().length > 0); formatted = blocks.map(block => { if (block.startsWith('<h') || block.startsWith('<p class="formula"')) return block; let content = block.replace(/\n/g, ' '); return `<p>${content}</p>`; }).join(''); return formatted; }

        // ========== MODAL FUNCTIONS ==========
        function showModal() { /* ... (no change) ... */ storyModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideModal() { /* ... (no change) ... */ storyModal.classList.remove('active'); if (!imageFullscreenOverlay.classList.contains('active') && !unlockModal.classList.contains('active')) { document.body.style.overflow = ''; } modalTextArea.scrollTop = 0; PuzzleGame.stop(); resetModalState(); }
        function resetModalState() { /* ... (no change) ... */ modalLoadingIndicator.classList.remove('active'); modalStoryContentArea.classList.add('content-hidden'); modalError.classList.add('content-hidden'); modalTitle.textContent = ''; modalContent.innerHTML = ''; modalErrorMessage.textContent = ''; chatHistory.innerHTML = ''; chatInput.value = ''; chatLoadingIndicator.style.display = 'none'; chatSendBtn.disabled = false; currentTopicTitle = null; hideFullscreenImage(); chatSection.classList.remove('content-hidden'); }
        function showUnlockModal(titleToUnlock) { /* ... (no change) ... */ unlockTargetTitleInput.value = titleToUnlock; unlockCountdownDisplay.textContent = ''; unlockStatusDisplay.textContent = ''; unlockAdButton.disabled = false; unlockModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideUnlockModal() { /* ... (no change) ... */ unlockModal.classList.remove('active'); if (!storyModal.classList.contains('active') && !imageFullscreenOverlay.classList.contains('active')) { document.body.style.overflow = ''; } if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; } }

        // ========== FULLSCREEN IMAGE FUNCTIONS ==========
        function showFullscreenImage(imgSrc) { /* ... (no change) ... */ if (!imageFullscreenOverlay || !fullscreenImage) return; fullscreenImage.src = imgSrc; imageFullscreenOverlay.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideFullscreenImage() { /* ... (no change) ... */ if (!imageFullscreenOverlay) return; imageFullscreenOverlay.classList.remove('active'); if (!storyModal.classList.contains('active') && !unlockModal.classList.contains('active')) { document.body.style.overflow = ''; } fullscreenImage.src = ''; }

        // ========== CHAT FUNCTIONS ==========
        function addChatMessage(message, sender) { /* ... (no change) ... */ const msgDiv = document.createElement('div'); msgDiv.classList.add('chat-message', sender === 'user' ? 'user-message' : 'ai-message'); message = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>'); msgDiv.innerHTML = message; chatHistory.appendChild(msgDiv); chatHistory.scrollTop = chatHistory.scrollHeight; }
        function addChatError(message) { /* ... (no change) ... */ const errorDiv = document.createElement('div'); errorDiv.classList.add('chat-error'); errorDiv.textContent = message; chatHistory.appendChild(errorDiv); chatHistory.scrollTop = chatHistory.scrollHeight; }
        async function handleSendMessage() { /* ... (no change) ... */ const userQuery = chatInput.value.trim(); if (!userQuery || chatSendBtn.disabled) return; addChatMessage(userQuery, 'user'); chatInput.value = ''; chatSendBtn.disabled = true; chatLoadingIndicator.style.display = 'block'; try { const aiResponse = await fetchChatResponse(userQuery); addChatMessage(aiResponse, 'ai'); } catch (error) { console.error("Chat Error:", error); addChatError(`Error Cronista Z: ${error.message}`); } finally { chatLoadingIndicator.style.display = 'none'; chatSendBtn.disabled = false; chatInput.focus(); } }

        // ========== UI & EVENT HANDLERS ==========
        function getRandomElement(arr) { /* ... (no change) ... */ return arr[Math.floor(Math.random() * arr.length)]; }
        function shuffleArray(array) { /* ... (no change) ... */ let ci=array.length,ri;while(ci>0){ri=Math.floor(Math.random()*ci);ci--;[array[ci],array[ri]]=[array[ri],array[ci]];} return array; }

        function createTitleItem(title) { /* ... (no change) ... */ const div = document.createElement('div'); div.className = 'title-item'; div.setAttribute('data-title', title); const textSpan = document.createElement('span'); textSpan.className = 'title-text'; textSpan.textContent = title; div.appendChild(textSpan); const initiallyLocked = isTitleInitiallyLocked(title); const unlockedByUser = isTitleUnlockedByUser(title); const isEffectivelyLocked = initiallyLocked && !unlockedByUser; div.setAttribute('data-locked', isEffectivelyLocked ? 'true' : 'false'); div.style.cursor = 'pointer'; if (isEffectivelyLocked) { div.classList.add('locked'); const lockIcon = document.createElement('i'); lockIcon.className = 'fas fa-lock lock-icon'; div.appendChild(lockIcon); } else { div.classList.remove('locked'); } div.addEventListener('click', () => handleTitleClick(title, div)); return div; }
        function updateTitleItemLockStatus(title, isLocked) { /* ... (no change) ... */ const titleItem = titleListContainer.querySelector(`.title-item[data-title="${CSS.escape(title)}"]`); if (titleItem) { titleItem.setAttribute('data-locked', isLocked ? 'true' : 'false'); titleItem.classList.toggle('locked', isLocked); let lockIcon = titleItem.querySelector('.lock-icon'); if (isLocked && !lockIcon) { lockIcon = document.createElement('i'); lockIcon.className = 'fas fa-lock lock-icon'; titleItem.appendChild(lockIcon); } else if (!isLocked && lockIcon) { lockIcon.remove(); } } }
        function displayTitles(titles) { /* ... (no change) ... */ if (!titleListContainer || !titlesLoading) return; if (!isInitialLockStateSet() && titles.length > 0) { console.log("Setting initial lock state for the first time..."); const shuffled = shuffleArray([...titles]); const lockCount = Math.floor(titles.length * lockPercentage); const newInitialLockedSet = new Set(); for (let i = 0; i < lockCount; i++) { newInitialLockedSet.add(shuffled[i]); } saveInitialLockedSet(newInitialLockedSet); setInitialLockStateFlag(); initialLockedTitles = newInitialLockedSet; console.log(`Initially locked ${initialLockedTitles.size} titles and saved state.`); } else { console.log(`Initial lock state already set. Loaded ${initialLockedTitles.size} initially locked titles.`); } const sortedTitles = titles.sort((a, b) => a.localeCompare(b)); titleListContainer.innerHTML = ''; titlesLoading.style.display = 'none'; if (sortedTitles.length === 0) { titleListContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center font-sans">» El Radar del Dragón no encuentra crossovers... «</p>'; return; } sortedTitles.forEach(title => titleListContainer.appendChild(createTitleItem(title))); }
        function appendTitles(newTitles) { /* ... (no change) ... */ if (!titleListContainer || !newTitles || newTitles.length === 0) return; const existingTitles = new Set(Array.from(titleListContainer.querySelectorAll('.title-item')).map(item => item.dataset.title)); let newTitlesAddedToInitialLock = false; newTitles.forEach(title => { if (!existingTitles.has(title)) { titleListContainer.appendChild(createTitleItem(title)); if (!initialLockedTitles.has(title)) { initialLockedTitles.add(title); newTitlesAddedToInitialLock = true; } } }); if (newTitlesAddedToInitialLock) { saveInitialLockedSet(initialLockedTitles); console.log("Added new generated titles to the persistent initial locked set."); } filterTitles(searchInput.value); }
        function handleTitleClick(title, titleElement) { /* ... (no change) ... */ const isLocked = titleElement.getAttribute('data-locked') === 'true'; if (isLocked) { console.log(`Title "${title}" is locked. Showing unlock modal.`); showUnlockModal(title); } else { console.log(`Title "${title}" is unlocked. Proceeding to load.`); loadContentForTitle(title); } }

        async function loadContentForTitle(title) { // Modified to use PuzzleGame
            resetModalState(); showModal(); currentTopicTitle = title;
            modalTitle.textContent = title;
            modalStoryContentArea.classList.add('content-hidden'); // Hide content area initially
            modalError.classList.add('content-hidden');
            modalLoadingIndicator.classList.add('active'); // Show loading overlay

            // *** START PUZZLE GAME ***
            PuzzleGame.start();

            try {
                const rawExplanationText = await fetchExplanationText(title);
                const formattedExplanation = formatExplanationText(rawExplanationText);

                // *** STOP PUZZLE GAME (content loaded) ***
                PuzzleGame.stop();
                modalLoadingIndicator.classList.remove('active'); // Hide loading overlay

                // Display content
                modalContent.innerHTML = formattedExplanation;
                modalStoryContentArea.classList.remove('content-hidden'); // Show content area
                modalTextArea.scrollTop = 0;

                // Load Image (after main content)
                const placeholderDiv = document.createElement('div');
                placeholderDiv.className = 'image-placeholder';
                placeholderDiv.innerHTML = `<div class="spinner"></div><i class="fas fa-palette placeholder-icon"></i><p style="font-size: 0.8em; margin-top: 0.5rem;">Pintando el Crossover...</p>`;
                modalContent.appendChild(placeholderDiv); // Append placeholder initially

                const imgElement = document.createElement('img');
                imgElement.className = 'final-image';
                imgElement.alt = `Ilustración del crossover: ${title}`;
                imgElement.style.display = 'none'; // Hide until loaded
                imgElement.onload = () => {
                    placeholderDiv.remove(); // Remove placeholder
                    imgElement.style.display = 'block'; // Show image
                    imgElement.addEventListener('click', () => showFullscreenImage(imgElement.src));
                };
                imgElement.onerror = () => {
                    placeholderDiv.innerHTML = `<i class="fas fa-eye-slash placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error al visualizar.</p>`; // Show error in placeholder
                };

                const imageUrl = createPollinationsImageUrl(title);
                if (imageUrl) {
                     imgElement.src = imageUrl;
                     // Important: Append the img element to the DOM so the browser starts loading it
                     modalContent.appendChild(imgElement);
                } else {
                    placeholderDiv.innerHTML = `<i class="fas fa-exclamation-circle placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error URL imagen Z.</p>`;
                }

            } catch (error) {
                console.error("Failed to load or display content:", error);
                // *** STOP PUZZLE GAME (error occurred) ***
                PuzzleGame.stop();
                modalLoadingIndicator.classList.remove('active');

                // Display error message within the modal content area
                modalErrorMessage.textContent = error.message || "Error desconocido al cargar esta línea temporal.";
                modalError.classList.remove('content-hidden');
                modalStoryContentArea.classList.remove('content-hidden'); // Still show the wrapper
                modalContent.innerHTML = ''; // Clear any partial content
                chatSection.classList.add('content-hidden'); // Hide chat on error
            }
        }

        function handleAdButtonClick() { /* ... (no change) ... */ const titleToUnlock = unlockTargetTitleInput.value; if (!titleToUnlock || unlockAdButton.disabled) return; console.log(`Ad button clicked for title: ${titleToUnlock}`); window.open(adUrl, '_blank'); unlockAdButton.disabled = true; unlockStatusDisplay.textContent = 'Canalizando Ki...'; let secondsRemaining = unlockCountdownSeconds; unlockCountdownDisplay.textContent = secondsRemaining; countdownInterval = setInterval(() => { secondsRemaining--; unlockCountdownDisplay.textContent = secondsRemaining; if (secondsRemaining <= 0) { clearInterval(countdownInterval); countdownInterval = null; unlockCountdownDisplay.textContent = '¡KA!'; unlockStatusDisplay.textContent = '¡Línea Temporal Desbloqueada!'; unlockTitlePermanentlyByUser(titleToUnlock); setTimeout(() => { hideUnlockModal(); loadContentForTitle(titleToUnlock); }, 1200); } }, 1000); }

        async function handleGenerateMoreTitles() { // Modified spinner logic
            if (!generateMoreBtn || !generateMoreContainer) return;
            const icon = generateMoreBtn.querySelector('i'); // Get potential icon

            generateMoreBtn.disabled = true;
             // Create spinner if it doesn't exist, or ensure it's visible and spinning
             let spinnerIcon = generateMoreBtn.querySelector('.fa-sync-alt');
             if (!spinnerIcon) {
                 spinnerIcon = document.createElement('i');
                 spinnerIcon.className = 'fas fa-sync-alt mr-2';
                 generateMoreBtn.prepend(spinnerIcon); // Add icon at the beginning
             }
             spinnerIcon.classList.add('animate-spin');
             spinnerIcon.classList.remove('hidden'); // Ensure visible
             // Adjust button text while loading
             const originalText = 'Descubrir Más Crossovers (40)';
             const loadingTextNode = document.createTextNode(' Buscando en otras dimensiones...');
             // Clear previous text content (carefully, keeping the icon)
             while (generateMoreBtn.childNodes.length > 1 && generateMoreBtn.lastChild !== spinnerIcon) {
                 generateMoreBtn.removeChild(generateMoreBtn.lastChild);
             }
              generateMoreBtn.appendChild(loadingTextNode);


             try {
                 const newTitles = await fetchGeneratedTitles();
                 if (newTitles && newTitles.length > 0) {
                     appendTitles(newTitles); // appendTitles handles logic
                 } else {
                     alert("El Radar del Dragón no encontró más crossovers ahora.");
                 }
             } catch (error) {
                 console.error("Failed title generation:", error);
                 alert(`Error buscando crossovers: ${error.message}`);
             } finally {
                 generateMoreBtn.disabled = false;
                  // Restore original button text and hide/remove spinner
                 spinnerIcon.classList.remove('animate-spin');
                 spinnerIcon.classList.add('hidden');
                 // Remove loading text and restore original text
                  if (loadingTextNode && loadingTextNode.parentNode === generateMoreBtn) {
                       generateMoreBtn.removeChild(loadingTextNode);
                  }
                   // Make sure original text isn't duplicated
                   const textNodes = Array.from(generateMoreBtn.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                   if (textNodes.length === 0) {
                       generateMoreBtn.appendChild(document.createTextNode(originalText));
                   } else {
                      // If text is already there somehow, ensure it's correct
                      textNodes[0].textContent = originalText;
                  }
             }
         }

        function filterTitles(searchTerm) { /* ... (no change) ... */ const term = searchTerm.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim(); const titleItems = titleListContainer.querySelectorAll('.title-item'); let visibleCount = 0; titleItems.forEach(item => { const titleText = item.dataset.title.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""); const isVisible = titleText.includes(term); item.classList.toggle('hidden', !isVisible); if (isVisible) visibleCount++; }); noResultsMsg.classList.toggle('hidden', visibleCount > 0 || searchTerm.trim() === ''); /* Hide if visible items OR empty search */ }


        // ========== INITIALIZATION ==========
        function initApp() {
             // Check essential elements
              if (!titleListContainer || !storyModal || !modalCloseBtn || !generateMoreBtn || !titlesLoading || !searchInput || !noResultsMsg || !chatInput || !chatSendBtn || !imageFullscreenOverlay || !fullscreenCloseBtn || !puzzleCanvas || !puzzleScoreLevelText || !unlockModal || !unlockModalCloseBtn || !unlockAdButton || !unlockCountdownDisplay || !unlockStatusDisplay || !unlockTargetTitleInput) {
                console.error("Initialization failed: Missing essential UI elements.");
                document.body.innerHTML = '<p style="color: red; font-size: 1.5em; text-align: center; padding-top: 3em;">Error Crítico: ¡La Máquina del Tiempo está averiada! Faltan componentes.</p>';
                return;
             }

             // Initialize Puzzle Game with Canvas and Score elements
            PuzzleGame.init(puzzleCanvas, puzzleScoreLevelText);

            // Event Listeners
            modalCloseBtn.addEventListener('click', hideModal);
            storyModal.addEventListener('click', (event) => { if (event.target === storyModal) hideModal(); });
            generateMoreBtn.addEventListener('click', handleGenerateMoreTitles);
            searchInput.addEventListener('input', (event) => filterTitles(event.target.value));
            searchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') event.preventDefault(); }); // Prevent form submit if wrapped
            chatSendBtn.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') handleSendMessage(); });
            imageFullscreenOverlay.addEventListener('click', hideFullscreenImage);
            fullscreenCloseBtn.addEventListener('click', (event) => { event.stopPropagation(); hideFullscreenImage(); }); // Stop propagation is important
            unlockModalCloseBtn.addEventListener('click', hideUnlockModal);
            unlockModal.addEventListener('click', (event) => { if (event.target === unlockModal) hideUnlockModal(); });
            unlockAdButton.addEventListener('click', handleAdButtonClick);

            // Initial display: Calls displayTitles which now handles persistent initial lock state
            displayTitles(predefinedTitles);
            filterTitles(''); // Apply empty filter initially to potentially hide "no results" message
        }

        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', initApp);
    </script>

</body>
</html>