<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MK vs Naruto - Crónicas Crossover</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Fuentes Temáticas -->
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@400;600&family=Noto+Sans+JP:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Estilos MK vs Naruto --- */
        :root {
            --color-mk-red: #d00000; /* Rojo Sangre MK */
            --color-naruto-orange: #ff8c00; /* Naranja Naruto */
            --color-subzero-blue: #00a8ff; /* Azul Hielo Sub-Zero */
            --color-scorpion-yellow: #ffcc00; /* Amarillo Scorpion */
            --color-raiden-electric: #00ffff; /* Cyan Eléctrico Raiden */
            --color-chakra-green: #39ff14; /* Verde Chakra/Reptile */

            --color-background: #1a1a1a; /* Negro/Gris Muy Oscuro */
            --color-text: #e5e7eb; /* Gris Claro */
            --color-text-muted: #9ca3af; /* Gris Medio */
            --color-modal-bg: #2a2a2a; /* Gris Oscuro para Modal */
            --color-border: #4b5563; /* Borde Gris */
            --color-primary-accent: var(--color-mk-red); /* Acento Principal */
            --color-secondary-accent: var(--color-naruto-orange); /* Acento Secundario */

            --color-error-bg: #450a0a; /* Fondo error rojo oscuro */
            --color-error-text: #fecaca; /* Texto error claro */
            --color-error-border: var(--color-mk-red); /* Borde error rojo */

            --shadow-sm: 0 1px 2px 0 rgba(208, 0, 0, 0.15);
            --shadow-md: 0 4px 6px -1px rgba(208, 0, 0, 0.2), 0 2px 4px -2px rgba(208, 0, 0, 0.15);
            --shadow-lg: 0 0 25px -5px rgba(208, 0, 0, 0.3), 0 8px 10px -6px rgba(255, 140, 0, 0.2);
            --border-radius: 4px;
            --transition-normal: all 0.25s ease-in-out;
        }
        body { font-family: 'Noto Sans JP', sans-serif; background-color: var(--color-background); color: var(--color-text); line-height: 1.7; font-weight: 400; }
        h1, h2, h3, h4, .logo, button { font-family: 'Teko', sans-serif; font-weight: 600; letter-spacing: 1px; }
        .logo { color: var(--color-primary-accent); text-shadow: 0 0 8px var(--color-mk-red); }
        .logo .naruto-part { color: var(--color-secondary-accent); text-shadow: 0 0 8px var(--color-naruto-orange); margin-left: -5px;}
        h1.page-title { color: var(--color-primary-accent); font-weight: 600; text-shadow: 0 0 5px rgba(208, 0, 0, 0.7); }
        h2.section-title { color: var(--color-text); border-bottom: 3px solid var(--color-primary-accent); padding-bottom: 0.6rem; display: inline-block; font-weight: 600; font-size: 2.5rem; }
        #modal-title { color: var(--color-secondary-accent); font-weight: 600; text-shadow: 0 0 4px rgba(255, 140, 0, 0.6); }
        .navbar { background-color: rgba(26, 26, 26, 0.85); backdrop-filter: blur(7px); box-shadow: var(--shadow-md); position: sticky; top: 0; z-index: 20; border-bottom: 1px solid var(--color-border); }
        /* Search Bar */
        #search-input { width: 100%; padding: 0.9rem 1.2rem 0.9rem 3rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); font-size: 1.1rem; background-color: rgba(42, 42, 42, 0.9); color: var(--color-text); box-shadow: var(--shadow-sm); transition: var(--transition-normal); font-family: 'Noto Sans JP'; }
        #search-input::placeholder { color: var(--color-text-muted); font-family: 'Teko'; letter-spacing: 0.5px;}
        #search-input:focus { border-color: var(--color-primary-accent); box-shadow: 0 0 0 3px rgba(208, 0, 0, 0.3); outline: none; background-color: var(--color-modal-bg); }
        #search-container .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--color-text-muted); font-size: 1.2rem; transition: color 0.2s ease; }
        #search-input:focus + .fa-search { color: var(--color-primary-accent); }

        #title-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.3rem; }
        .title-item { background-color: var(--color-modal-bg); padding: 1.4rem 1.1rem; border-radius: var(--border-radius); box-shadow: var(--shadow-sm); cursor: pointer; transition: var(--transition-normal); text-align: center; font-weight: 400; color: var(--color-text); border: 1px solid var(--color-border); display: flex; align-items: center; justify-content: center; min-height: 75px; font-family: 'Noto Sans JP'; font-size: 1rem; border-left: 4px solid var(--color-border); }
        .title-item:hover { transform: translateY(-5px) scale(1.02); box-shadow: var(--shadow-md); border-color: var(--color-primary-accent); color: var(--color-secondary-accent); background-color: #333; border-left-color: var(--color-primary-accent); }
        #generate-more-btn { grid-column: 1 / -1; background: linear-gradient(135deg, var(--color-mk-red), var(--color-naruto-orange)); color: #ffffff; padding: 0.9rem 1.8rem; border: none; border-radius: var(--border-radius); font-size: 1.5rem; cursor: pointer; transition: var(--transition-normal); margin-top: 2.5rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); }
        #generate-more-btn:hover:not(:disabled) { background: linear-gradient(135deg, var(--color-naruto-orange), var(--color-mk-red)); box-shadow: var(--shadow-lg); transform: scale(1.03); }
        #generate-more-btn:disabled { background: var(--color-border); color: var(--color-text-muted); cursor: not-allowed; opacity: 0.6; transform: none; box-shadow: none; }
        #generate-more-btn .fa-sync-alt { color: #ffffff; }

        #story-modal { /* Modal styles similar to previous, maybe adjust background opacity */ position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 26, 26, 0.92); display: none; align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        #story-modal.active { display: flex; }
        .modal-content-wrapper { /* Wrapper styles similar */ background-color: var(--color-modal-bg); border: 1px solid var(--color-primary-accent); border-radius: var(--border-radius); padding: 1.5rem 2rem; max-width: 950px; width: 95%; max-height: 90vh; min-height: 500px; /* Increased min-height for puzzle/chat */ overflow: hidden; position: relative; box-shadow: var(--shadow-lg); display: flex; flex-direction: column; }
        .modal-close-btn { /* Close button styles similar */ position: absolute; top: 10px; right: 10px; background: var(--color-border); border: none; border-radius: 50%; width: 38px; height: 38px; font-size: 1.7rem; color: var(--color-text); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); z-index: 60; }
        .modal-close-btn:hover { background-color: var(--color-primary-accent); color: #ffffff; transform: rotate(90deg); box-shadow: 0 0 10px var(--color-primary-accent); }
        #modal-title { font-size: 2.2rem; text-align: center; margin-bottom: 1.2rem; flex-shrink: 0; padding: 0 1rem; line-height: 1.3; }

        /* Area Contenido Principal (Texto + Imagen + Chat) */
        #modal-story-content-area { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; /* Wrapper no scrollea */ }
        /* Area Scrollable (Texto + Imagen al final) */
        #modal-content-area { flex-grow: 1; min-height: 0; overflow-y: auto; padding-right: 10px; margin-bottom: 1rem;
            scrollbar-width: thin; scrollbar-color: var(--color-primary-accent) rgba(75, 85, 99, 0.5);
        }
        #modal-content-area::-webkit-scrollbar { width: 8px; }
        #modal-content-area::-webkit-scrollbar-track { background: rgba(75, 85, 99, 0.5); border-radius: var(--border-radius); }
        #modal-content-area::-webkit-scrollbar-thumb { background-color: var(--color-primary-accent); border-radius: var(--border-radius); border: 1px solid var(--color-border); }

        #modal-content { /* Text content styles */ padding: 0 5px; font-family: 'Noto Sans JP', sans-serif; font-weight: 400; }
        #modal-content p:not(:last-child) { margin-bottom: 1.5em; }
        #modal-content strong { color: var(--color-secondary-accent); font-weight: 700; }
        #modal-content em { color: var(--color-subzero-blue); font-style: italic; font-weight: 400;}
        #modal-content h1, #modal-content h2, #modal-content h3, #modal-content h4 { font-family: 'Teko', sans-serif; margin-top: 2.3em; margin-bottom: 1.2em; color: var(--color-primary-accent); border-bottom: 1px solid var(--color-border); padding-bottom: 0.5em; font-weight: 600; letter-spacing: 0.5px;}
        #modal-content h1 { font-size: 1.6em; }
        #modal-content h2 { font-size: 1.45em; }
        #modal-content h3 { font-size: 1.3em; color: var(--color-secondary-accent); }
        #modal-content h4 { font-size: 1.2em; color: var(--color-text-muted); border-bottom: none;}
        /* Imagen Final */
        #modal-content .final-image { display: block; max-width: 85%; height: auto; margin: 3rem auto 1rem auto; border: 2px solid var(--color-primary-accent); border-radius: var(--border-radius); box-shadow: 0 0 18px rgba(208, 0, 0, 0.3); cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        #modal-content .final-image:hover { transform: scale(1.04); box-shadow: 0 0 25px rgba(255, 140, 0, 0.4); }
        #modal-content .image-placeholder { /* Placeholder styles similar */ display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 150px; margin: 3rem auto 1rem auto; color: var(--color-text-muted); }
        #modal-content .image-placeholder .spinner { border: 4px solid rgba(75, 85, 99, 0.7); width: 40px; height: 40px; border-radius: 50%; border-left-color: var(--color-primary-accent); animation: spin 1s linear infinite; margin-bottom: 0.7rem; }
        #modal-content .image-placeholder .placeholder-icon { font-size: 3rem; }

        /* Chat Section Styles (similar to previous) */
        #chat-section { border-top: 2px solid var(--color-border); padding-top: 1rem; margin-top: 1rem; flex-shrink: 0; display: flex; flex-direction: column; max-height: 220px; /* Slightly reduced height */ }
        #chat-history { flex-grow: 1; overflow-y: auto; margin-bottom: 0.8rem; padding: 0.7rem; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: rgba(26, 26, 26, 0.8); scroll-behavior: smooth; }
        /* Chat message styles (user/ai) similar */
        .chat-message { margin-bottom: 0.7rem; padding: 0.6rem 0.9rem; border-radius: var(--border-radius); max-width: 88%; word-wrap: break-word; line-height: 1.5; font-family: 'Noto Sans JP'; font-size: 0.95rem;}
        .user-message { background: linear-gradient(to right, var(--color-naruto-orange), #e67e00); color: #111; margin-left: auto; text-align: left; border-top-right-radius: 0; box-shadow: -2px 2px 3px rgba(0,0,0,0.2);}
        .ai-message { background: linear-gradient(to right, var(--color-mk-red), #a00); color: var(--color-text); margin-right: auto; text-align: left; border-top-left-radius: 0; box-shadow: 2px 2px 3px rgba(0,0,0,0.2);}
        .chat-error { color: var(--color-error-text); font-style: italic; text-align: center; font-size: 0.9em; font-family: 'Teko';}
        #chat-input-area { display: flex; gap: 0.5rem; }
        #chat-input { flex-grow: 1; padding: 0.7rem 0.9rem; border: 1px solid var(--color-border); background-color: #333; color: var(--color-text); border-radius: var(--border-radius); font-family: 'Noto Sans JP'; font-size: 1rem; }
        #chat-input:focus { outline: none; border-color: var(--color-secondary-accent); box-shadow: 0 0 5px rgba(255, 140, 0, 0.3); }
        #chat-send-btn { padding: 0.7rem 1.1rem; background-color: var(--color-primary-accent); color: white; border: none; border-radius: var(--border-radius); cursor: pointer; transition: background-color 0.2s ease; font-size: 1.1rem; }
        #chat-send-btn:hover:not(:disabled) { background-color: #f00; }
        #chat-send-btn:disabled { background-color: var(--color-text-muted); cursor: not-allowed; }
        #chat-loading { text-align: center; padding: 0.5rem; font-size: 1rem; color: var(--color-text-muted); display: none; font-family: 'Teko'; }
        #chat-loading .fa-spinner { margin-right: 0.5rem; }

        /* Loading Indicator (Replaced by Puzzle) */
        #modal-loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 26, 26, 0.98);
            display: none; /* Hidden by default, shown via JS */
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 55; border-radius: var(--border-radius);
            padding: 2rem;
        }
        #modal-loading.active { display: flex; } /* Show loading */
        #modal-loading p.loading-text {
            font-family: 'Teko'; font-size: 1.8rem; color: var(--color-secondary-accent);
            margin-bottom: 1.5rem; text-shadow: 0 0 5px var(--color-naruto-orange);
        }

        /* Puzzle Game Styles */
        #puzzle-game-container {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; max-width: 400px; /* Adjust as needed */
        }
        #puzzle-info {
            display: flex; justify-content: space-between; width: 100%;
            font-family: 'Teko'; color: var(--color-text-muted); font-size: 1.2rem;
            margin-bottom: 1rem; padding: 0 10px;
        }
        #puzzle-info span { color: var(--color-raiden-electric); } /* Highlight level/moves */
        #puzzle-grid {
            display: grid;
            border: 3px solid var(--color-primary-accent);
            background-color: var(--color-background);
            position: relative; /* For absolute positioning of tiles if needed */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 1rem; /* Space below puzzle */
        }
        .puzzle-tile {
            border: 1px solid var(--color-border);
            background-size: cover;
            background-position: center;
            cursor: pointer;
            transition: transform 0.3s ease-in-out, opacity 0.3s;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; /* For number display if no image */
            font-family: 'Teko';
            color: rgba(255,255,255,0.1); /* Hide number visually if image used */
            user-select: none; /* Prevent text selection */
            position: relative; /* For potential overlay effects */
        }
        .puzzle-tile.empty {
            background-color: var(--color-background);
            opacity: 0.5;
            cursor: default;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        .puzzle-tile:not(.empty):hover {
             /* Slightly lift tile on hover if movable */
             transform: scale(1.05);
             z-index: 10;
             border-color: var(--color-secondary-accent);
        }
        #puzzle-message {
            font-family: 'Teko'; font-size: 1.5rem; color: var(--color-chakra-green);
            margin-top: 1rem; height: 2em; /* Reserve space */
            text-align: center;
            text-shadow: 0 0 5px var(--color-chakra-green);
        }


        /* Error Message Styles (similar) */
        .error-msg { background-color: var(--color-error-bg); color: var(--color-error-text); padding: 1.2rem; border-radius: var(--border-radius); border: 1px solid var(--color-error-border); margin-top: 1.5rem; text-align: center; flex-shrink: 0; font-weight: 400; font-family: 'Noto Sans JP'; }
        .error-msg i { margin-right: 0.7rem; color: var(--color-error-border); }
        .content-hidden { display: none !important; }
        .title-item.hidden { display: none; }

        /* Fullscreen Image Overlay Styles (similar) */
        #image-fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 26, 26, 0.97); display: none; align-items: center; justify-content: center; z-index: 100; padding: 2rem; cursor: zoom-out; }
        #image-fullscreen-overlay.active { display: flex; }
        #fullscreen-image { max-width: 95%; max-height: 95%; object-fit: contain; border: 3px solid var(--color-secondary-accent); box-shadow: 0 0 30px var(--color-naruto-orange); }
        #fullscreen-close-btn { position: absolute; top: 20px; right: 25px; background: var(--color-modal-bg); border: 1px solid var(--color-secondary-accent); border-radius: 50%; width: 40px; height: 40px; font-size: 1.8rem; color: var(--color-secondary-accent); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: var(--transition-normal); }
        #fullscreen-close-btn:hover { background-color: var(--color-secondary-accent); color: var(--color-background); transform: scale(1.1); }
    </style>
</head>
<body>
     <!-- Header/Navbar -->
     <nav class="navbar mb-10">
         <div class="container mx-auto px-4 py-3 flex flex-col sm:flex-row justify-between items-center">
             <div class="flex items-center text-center mb-2 sm:mb-0">
                 <h1 class="logo text-4xl sm:text-5xl">
                     <i class="fas fa-bolt mr-2 text-yellow-400"></i> <!-- Icono rayo -->
                     MK <span class="naruto-part">vs Naruto</span>
                 </h1>
             </div>
             <span class="text-sm text-gray-400 font-sans tracking-wider uppercase">» Crónicas Crossover «</span>
         </div>
     </nav>

     <!-- Main content -->
     <main class="container mx-auto px-4 pb-16">
         <section class="mb-12 text-center">
             <h1 class="page-title text-5xl sm:text-6xl mb-5 uppercase">Choque de Universos</h1>
             <p class="text-xl text-gray-300 mb-8 max-w-3xl mx-auto font-light">Explora historias donde los ninjas de Konoha se enfrentan a los guerreros de Mortal Kombat. ¿Quién prevalecerá?</p>
         </section>

         <section id="search-container" class="mb-10 max-w-2xl mx-auto">
             <input type="text" id="search-input" placeholder="Buscar personaje, jutsu, fatality, escenario...">
             <i class="fas fa-search"></i>
         </section>

         <section class="mb-10">
             <h2 class="section-title text-3xl sm:text-4xl mb-8 text-center mx-auto">
                 <i class="fas fa-scroll text-red-600 mr-2"></i> <!-- Icono pergamino -->
                 Archivos de Historias
             </h2>
             <div id="title-list">
                  <p id="titles-loading" class="text-gray-400 col-span-full text-center text-lg font-sans">Accediendo a los registros interdimensionales...</p>
                  <!-- .title-item aquí -->
             </div>
             <p id="no-results" class="text-gray-400 col-span-full text-center text-lg mt-4 hidden font-sans">» Ninguna crónica coincide con la búsqueda «</p>
             <div id="generate-more-container" class="text-center mt-8">
                 <button id="generate-more-btn">
                      <i class="fas fa-sync-alt mr-2 animate-spin hidden"></i>
                     Invocar Más Crónicas (40)
                  </button>
             </div>
         </section>
     </main>

     <!-- Explanation Modal -->
     <div id="story-modal">
         <div class="modal-content-wrapper">
             <button class="modal-close-btn" id="modal-close" aria-label="Cerrar">&times;</button>

             <!-- *** Loading Indicator with Puzzle *** -->
             <div id="modal-loading">
                 <p class="loading-text">Forjando la crónica... ¡Resuelve el puzzle mientras esperas!</p>
                 <div id="puzzle-game-container">
                     <div id="puzzle-info">
                         <span>Nivel: <span id="puzzle-level">1</span></span>
                         <span>Mov.: <span id="puzzle-moves">0</span></span>
                     </div>
                     <div id="puzzle-grid">
                         <!-- Tiles are generated here by JS -->
                     </div>
                     <div id="puzzle-message"></div> <!-- For win/feedback messages -->
                 </div>
             </div>

             <!-- Content Area Wrapper (Must be hidden initially) -->
             <div id="modal-story-content-area" class="content-hidden flex flex-col flex-grow min-h-0">
                 <!-- Scrollable Text + Image Area -->
                 <div id="modal-content-area">
                     <h2 id="modal-title"></h2>
                     <div id="modal-content">
                         <!-- Story text here -->
                         <!-- Image and placeholder here -->
                     </div>
                 </div>
                 <!-- Chat Section -->
                 <div id="chat-section">
                     <div id="chat-history"></div>
                     <div id="chat-loading"><i class="fas fa-spinner fa-spin"></i> Consultando al Oráculo...</div>
                     <div id="chat-input-area">
                         <input type="text" id="chat-input" placeholder="Pregunta más sobre esta crónica...">
                         <button id="chat-send-btn" aria-label="Enviar"><i class="fas fa-paper-plane"></i></button>
                     </div>
                 </div>
                 <!-- Error Display -->
                 <div id="modal-error" class="error-msg content-hidden mt-4 flex-shrink-0">
                      <i class="fas fa-exclamation-triangle"></i>
                      <span id="modal-error-message"></span>
                  </div>
             </div>
          </div>
      </div>

      <!-- Fullscreen Image Overlay -->
      <div id="image-fullscreen-overlay">
          <button id="fullscreen-close-btn" aria-label="Cerrar Imagen">&times;</button>
          <img id="fullscreen-image" src="" alt="Imagen Ampliada">
      </div>

      <!-- Footer -->
      <footer class="bg-gray-900 text-gray-500 py-6 mt-12 border-t border-gray-700 font-sans">
          <div class="container mx-auto px-4 text-center text-sm">
              <p>Historias generadas por IA como ejercicios creativos de 'qué pasaría si'.</p>
              <p class="mt-1">Mortal Kombat © Warner Bros. Entertainment Inc. Naruto © Masashi Kishimoto/Shueisha.</p>
              <p class="mt-2">© 2025 Crónicas Crossover</p>
          </div>
      </footer>

    <script>
        // ========== CONFIG & DATA ==========
        const predefinedTitles = [
            // Character vs Character
            "Scorpion vs Sasuke Uchiha: Duelo de Venganza", "Sub-Zero vs Kakashi Hatake: Maestros Elementales", "Raiden vs Naruto Uzumaki (Modo Sabio): Poder Divino y Natural", "Liu Kang vs Rock Lee: Combate de Artes Marciales Puras", "Kitana vs Sakura Haruno (Byakugou): Fuerza y Habilidad", "Johnny Cage vs Might Guy (8 Puertas): Espectáculo vs Poder Absoluto", "Sonya Blade vs Tsunade: Leyendas del Combate", "Kano vs Orochimaru: Científicos Dementes", "Shang Tsung vs Itachi Uchiha: Ladrones de Almas y Ojos", "Shao Kahn vs Madara Uchiha: Tiranos Conquistadores", "Goro vs Cuarto Raikage A: Fuerza Bruta Colosal", "Reptile vs Kisame Hoshigaki: Depredadores Acuáticos", "Ermac vs Gaara: Control Telequinético y de Arena", "Noob Saibot vs Shikamaru Nara: Sombras Estratégicas", "Smoke vs Zabuza Momochi: Niebla y Sigilo", "Cyrax vs Deidara: Explosiones Tecnológicas y Artísticas", "Sektor vs Sasori: Marionetas y Cibernética", "Kenshi vs Neji Hyuga: Espada Psíquica vs Byakugan", "Mileena vs Anko Mitarashi: Ferocidad y Serpientes", "Baraka vs Kimimaro: Cuchillas y Huesos", "Sindel vs Konan: Grito Sónico y Papel Explosivo", "Nightwolf vs Jiraiya: Espíritus Ancestrales y Sapos", "Stryker vs Ibiki Morino: Autoridad y Tácticas", "Kabal vs Minato Namikaze: Velocidad Extrema", "Jade vs Tenten: Armas y Proyectiles", "Sheeva vs Choji Akimichi (Modo Mariposa): Poder de Cuatro Brazos y Calorías", "Motaro vs Killer B: Centauro vs Jinchuriki", "Quan Chi vs Danzo Shimura: Hechicería Oscura y Secretos", "Shinnok vs Kaguya Otsutsuki: Dioses Caídos y Progenitores", "Kotal Kahn vs Hashirama Senju: Emperadores Solares y Dioses Shinobi", "D'Vorah vs Shino Aburame: Enjambres Mortales", "Cassie Cage vs Boruto Uzumaki: Nueva Generación", "Jacqui Briggs vs Sarada Uchiha: Tecnología y Sharingan", "Takeda Takahashi vs Mitsuki: Látigos y Estiramiento", "Kung Jin vs Konohamaru Sarutobi: Arco y Voluntad de Fuego", "Erron Black vs Kakuzu: Inmortalidad y Recompensa", "Ferra/Torr vs Kiba Inuzuka & Akamaru: Dúo Brutal", "Triborg vs Pain (Seis Caminos): Unidad Cibernética y Marionetas Divinas", "Rain vs Tobirama Senju: Dominio del Agua", "Fujin vs Temari: Control del Viento",

            // Scenario Based
            "El Torneo Mortal Kombat llega a Konoha", "Naruto atrapado en el Outworld", "Sasuke busca poder en el Netherrealm", "La Invasión de Shao Kahn a las Cinco Grandes Naciones Shinobi", "Los Akatsuki intentan robar el Amuleto de Shinnok", "Kakashi entrena con Sub-Zero: Fusión de Técnicas de Hielo y Rayo", "Sakura aprende medicina de combate de Sonya Blade", "El Rasengan contra el Poder de Raiden", "El Sharingan analiza los Fatalities", "Rock Lee desafía a Liu Kang en un combate cuerpo a cuerpo", "Gaara controla la arena del desierto de Outworld", "El Byakugan detecta el sigilo de Reptile", "Shikamaru atrapado en la estrategia de Quan Chi", "Itachi en una ilusión contra Ermac", "El Modo Sabio de los Sapos contra la magia de Shang Tsung", "Los Jinchurikis como armas para Shao Kahn", "Kitana busca aliados en Sunagakure", "Scorpion persigue a Orochimaru por la resurrección", "Sub-Zero encuentra un clan perdido en el País del Hielo", "Raiden consulta con los Kages sobre la amenaza de Shinnok", "Johnny Cage filma una película en el País del Fuego", "Kano intenta vender armas ninja en el mercado negro de Earthrealm", "El Chidori de Sasuke vs el Teletransporte de Scorpion", "La fuerza de Tsunade vs la brutalidad de Goro", "Might Guy abre las 8 puertas contra Shao Kahn", "Konoha defiende el Árbol del Mundo del ataque de Cetrion", "El Tsukuyomi Infinito afecta a los reinos de MK", "Boruto invoca un Fatality accidentalmente", "Sarada despierta el Mangekyo al presenciar un Brutality", "Los Lin Kuei reclutan a Haku", "El Clan Uchiha se enfrenta al Hermandad de las Sombras", "El poder de Kotal Kahn alimentado por el sol de Konoha", "D'Vorah infesta los bosques de Konoha", "El torneo Chunin con reglas de Mortal Kombat", "Naruto intenta evangelizar a Shao Kahn con el 'Talk no Jutsu'", "Sasuke y Scorpion: ¿Alianza o Traición?", "Sub-Zero y Kakashi: La Misión del Pergamino Congelado", "Raiden y Minato: Destellos de Poder", "Liu Kang aprende el Puño Suave", "Sakura realiza un 'Medical Fatality'", "El Jutsu de Sombra de Shikamaru atrapa a Noob Saibot", "Gaara vs Ermac: Tormenta de Arena y Almas", "El Modo Bijuu de Naruto contra el poder de Onaga", "Itachi atrapa a Shang Tsung en el Izanami", "Madara Uchiha vs Shinnok: Duelo de Inmortales", "Kaguya vs Kronika: Manipuladoras del Tiempo y Espacio", "Hashirama crea un bosque en el Outworld", "Tobirama inunda el Netherrealm", "Orochimaru experimenta con la sangre Tarkatana", "Jiraiya investiga los secretos de los Dioses Antiguos", "Tsunade apuesta contra Johnny Cage", "Rock Lee intenta copiar los movimientos de Liu Kang", "Neji vs Kenshi: Combate a Ciegas", "Tenten intenta dominar las armas de Kitana", "Choji come la fruta prohibida de Edenia", "Ino controla la mente de Mileena", "Kiba y Akamaru rastrean a Reptile", "Shino comanda los insectos de D'Vorah", "Hinata usa el Puño Suave contra Baraka", "Anko sobrevive a la fosa de Shang Tsung", "Danzo usa el Kotoamatsukami en Quan Chi", "Killer B rapea contra Motaro", "Deidara crea arte explosivo con Cyrax", "Sasori convierte a Sektor en una marioneta humana", "Kisame vs Rain: Duelo bajo el agua", "Kakuzu lucha contra Erron Black por dinero", "Hidan intenta sacrificar a Shinnok", "Konan usa millones de papeles bomba contra Sindel", "Pain vs Triborg: Tecnología vs Filosofía Divina", "Zabuza y Smoke: Maestros de la Niebla Asesina", "Haku une fuerzas con Sub-Zero", "Kimimaro vs Baraka: Danza de Huesos y Cuchillas", "Jugo desatado en el Outworld", "Suigetsu intenta robar la espada de Kotal Kahn", "Karin detecta el chakra de Ermac", "Kabuto fusiona ADN de guerreros MK", "Obito (Juubi) vs Blaze: Poder Apocalíptico", "Boruto usa el Karma contra la magia de Shang Tsung", "Sarada predice los movimientos de Kabal con el Sharingan", "Mitsuki se infiltra en el clan de Reptile", "Kawaki vs Geras: Inmortalidad y Regeneración", "Delta vs Frost: Combate Cibernético Femenino", "Code vs Havik: Caos y Marcas", "Eida encanta a Johnny Cage", "Daemon refleja un Fatality", "Amado crea cyborgs estilo MK", "El Árbol Divino absorbe la energía de los reinos", "Naruto (Baryon Mode) vs Liu Kang (Dios del Fuego)", "Sasuke (Rinnegan Supremo) vs Raiden (Corrompido)", "Sakura (Byakugou) vs Cetrion", "Madara (Juubi) vs Shao Kahn (Con poder de Blaze)", "Kaguya vs Kronika: Batalla por el Tejido del Tiempo",
             // Add more...
        ];
        const crossoverThemes = [
            "personajes de Mortal Kombat en el mundo de Naruto", "ninjas de Naruto en los reinos de Mortal Kombat", "torneos de lucha MK-Naruto", "duelos de poder elemental", "fusiones de técnicas (Jutsu + Special Move)", "invasiones interdimensionales", "alianzas inesperadas (Scorpion + Sasuke)", "enfrentamientos de villanos (Shao Kahn vs Madara)", "artefactos de un universo en el otro", "Akatsuki vs Netherrealm", "Konoha vs Outworld", "Lin Kuei y ninjas de hielo", "Sharingan analizando Fatalities", "Modo Sabio vs Poderes Divinos MK", "Jinchurikis en Mortal Kombat", "experimentos de Orochimaru con ADN de MK", "viajes en el tiempo (Kronika + Kaguya)", "nuevas generaciones (Boruto/Sarada en MK)", "fatalities adaptados a jutsus", "dioses contra dioses (Raiden vs Kaguya)", "estrategia ninja vs fuerza bruta MK"
        ];
        const textApiConfig = { // Config para historia principal
            model: "mistral", // O un modelo más potente si está disponible y es necesario
            systemPrompt: "Eres un 'Maestro del Lore' experto absoluto en los universos de Mortal Kombat y Naruto. Tu misión es escribir una historia crossover *ficticia* emocionante y coherente basada en el título proporcionado. Describe la interacción entre personajes, el choque de habilidades (Jutsus, Fatalities, poderes especiales), los escenarios fusionados y las posibles consecuencias de este encuentro. Mantén la esencia de ambos universos (violencia y oscuridad de MK, estrategia y emociones de Naruto). Crea diálogos creíbles y escenas de acción vívidas. La historia debe tener entre 1200 y 1300 palabras. Basa tu crónica únicamente en el siguiente título crossover:",
            timeoutSeconds: 180 // Aumentar ligeramente por complejidad
        };
        const chatApiConfig = { // Config base para chat
             model: "mistral-tiny", // Modelo rápido para chat
             systemPrompt: "Actúa como un asistente del Maestro del Lore. Estás especializado *únicamente* en la historia crossover que se está mostrando actualmente. Responde preguntas sobre los personajes involucrados en *esta* historia, detalles de la trama, 'qué pasaría si' dentro del contexto *de esta crónica específica*, o aclaraciones sobre los eventos narrados. Sé conciso y mantente enfocado en la historia actual.",
             timeoutSeconds: 50
        };
        const titleGenerationConfig = { // Config para generar MÁS títulos
             model: "mistral",
             systemPrompt: "Eres un generador de ideas para fanfiction crossover Mortal Kombat x Naruto. Genera exactamente 40 títulos intrigantes y variados para posibles historias. Incluye enfrentamientos directos, escenarios 'what if', fusiones de conceptos, y encuentros inesperados. Devuelve *solo* la lista de títulos, uno por línea. Sin números, guiones, introducciones ni despedidas.",
             timeoutSeconds: 60 // Más tiempo para generar 40
         };

        // Puzzle Game Config
        const puzzleConfig = {
            levels: [
                { size: 3, image: 'puzzle-img/mk-naruto-3x3.jpg' }, // Nivel 1: 3x3
                { size: 4, image: 'puzzle-img/mk-naruto-4x4.jpg' }, // Nivel 2: 4x4
                { size: 5, image: 'puzzle-img/mk-naruto-5x5.jpg' }  // Nivel 3: 5x5 (si se quiere más difícil)
            ],
            // URLs de imágenes para las piezas (deben ser cuadradas o aspect ratio 1:1)
            // Asegúrate de tener imágenes en una carpeta 'puzzle-img' o cambia las rutas
            tileImages: [
                'puzzle-img/tile_naruto.png', 'puzzle-img/tile_sasuke.png', 'puzzle-img/tile_sakura.png',
                'puzzle-img/tile_kakashi.png', 'puzzle-img/tile_scorpion.png', 'puzzle-img/tile_subzero.png',
                'puzzle-img/tile_raiden.png', 'puzzle-img/tile_liukang.png', 'puzzle-img/tile_kitana.png',
                'puzzle-img/tile_sharingan.png', 'puzzle-img/tile_mklogo.png', 'puzzle-img/tile_kunai.png',
                'puzzle-img/tile_rasengan.png', 'puzzle-img/tile_chidori.png', 'puzzle-img/tile_getoverhere.png',
                'puzzle-img/tile_iceball.png', 'puzzle-img/tile_konoha.png', 'puzzle-img/tile_outworld.png',
                 'puzzle-img/tile_itachi.png', 'puzzle-img/tile_gaara.png', 'puzzle-img/tile_shangtsung.png',
                 'puzzle-img/tile_shaokahn.png', 'puzzle-img/tile_rocklee.png', 'puzzle-img/tile_ermac.png'
                // Añade más imágenes si necesitas para cuadrículas más grandes (hasta 24 para 5x5)
            ]
        };

        // ========== DOM ELEMENTS ==========
        // (Igual que antes, pero añadiendo los del puzzle)
        const searchInput = document.getElementById('search-input');
        const titleListContainer = document.getElementById('title-list');
        const titlesLoading = document.getElementById('titles-loading');
        const noResultsMsg = document.getElementById('no-results');
        const generateMoreContainer = document.getElementById('generate-more-container');
        const generateMoreBtn = document.getElementById('generate-more-btn');
        const generateMoreSpinner = generateMoreBtn.querySelector('i');
        const storyModal = document.getElementById('story-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const modalLoadingIndicator = document.getElementById('modal-loading'); // Ahora contiene el puzzle
        const modalStoryContentArea = document.getElementById('modal-story-content-area');
        const modalTextArea = document.getElementById('modal-content-area');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalError = document.getElementById('modal-error');
        const modalErrorMessage = document.getElementById('modal-error-message');
        const chatSection = document.getElementById('chat-section');
        const chatHistory = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatLoadingIndicator = document.getElementById('chat-loading');
        const imageFullscreenOverlay = document.getElementById('image-fullscreen-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
        // Puzzle Elements
        const puzzleGameContainer = document.getElementById('puzzle-game-container');
        const puzzleGrid = document.getElementById('puzzle-grid');
        const puzzleLevelDisplay = document.getElementById('puzzle-level');
        const puzzleMovesDisplay = document.getElementById('puzzle-moves');
        const puzzleMessageDisplay = document.getElementById('puzzle-message');

        // ========== State Variables ==========
        let currentStoryTitle = null;
        let puzzleState = {
            level: 0,
            size: 0,
            tiles: [], // Array 1D de números o null para el vacío
            emptyIndex: -1,
            moves: 0,
            solved: false,
            imageMap: {} // Para mapear número de tile a imagen
        };

        // ========== API FUNCTIONS ==========
        // fetchTextFromApi, fetchExplanationText, fetchChatResponse (sin cambios funcionales, usan las configs nuevas)
        async function fetchTextFromApi(prompt, config, isChat = false) {
            const encodedPrompt = encodeURIComponent(prompt);
            const systemPromptToUse = isChat && currentStoryTitle
                ? `Actúa como un asistente del Maestro del Lore. Estás especializado *únicamente* en la historia crossover llamada '${currentStoryTitle}'. Responde preguntas sobre los personajes involucrados en *esta* historia, detalles de la trama, 'qué pasaría si' dentro del contexto *de esta crónica específica*, o aclaraciones sobre los eventos narrados. Sé conciso y mantente enfocado en la historia actual.`
                : config.systemPrompt;
            const encodedSystem = encodeURIComponent(systemPromptToUse);

            const params = new URLSearchParams({ model: config.model, system: encodedSystem });
            if (config.seed && !isChat) params.append('seed', config.seed);
            const url = `https://text.pollinations.ai/${encodedPrompt}?${params.toString()}`;
            console.log(`Fetching text from API (${config.model}, Chat: ${isChat}): ${url.substring(0, 200)}...`);

            const controller = new AbortController();
            // Usar el timeout de la config específica (más largo para historia, corto para chat/títulos)
            const timeoutId = setTimeout(() => controller.abort(), config.timeoutSeconds * 1000);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`(Error ${response.status}) Los portales interdimensionales están congestionados. Intenta de nuevo en unos momentos.`);
                }
                const text = await response.text();
                if (!text || text.trim().length === 0) {
                     throw new Error("La IA no pudo forjar la crónica o la respuesta llegó vacía.");
                 }
                console.log(`API Response received (${text.length} chars)`);
                return text;
            } catch (error) {
                clearTimeout(timeoutId);
                console.error("API Fetch Error:", error);
                if (error.name === 'AbortError') {
                    throw new Error(`La conexión interdimensional tardó demasiado (>${config.timeoutSeconds}s). Revisa tu conexión o intenta más tarde.`);
                }
                throw new Error(error.message || "Una fuerza desconocida impidió la comunicación con la IA.");
            }
        }
        async function fetchExplanationText(storyTitle) {
             return fetchTextFromApi(storyTitle, textApiConfig, false);
        }
        async function fetchChatResponse(userQuery) {
             if (!currentStoryTitle) throw new Error("Error interno: No se ha establecido el contexto de la crónica para el chat.");
             return fetchTextFromApi(userQuery, chatApiConfig, true);
         }
        // *** MODIFIED: fetchGeneratedTitles requests 40 ***
        async function fetchGeneratedTitles() {
             const randomTheme = getRandomElement(crossoverThemes) || "crossovers MK Naruto generales";
             const specificPrompt = `Genera 40 títulos de historias crossover sobre ${randomTheme}`;
             console.log("Generating 40 titles with prompt:", specificPrompt);
             // Usa la config de generación de títulos (con timeout ajustado)
             return fetchTextFromApi(specificPrompt, titleGenerationConfig, false)
                  .then(text => {
                      const titles = text.split('\n')
                                         .map(line => line.replace(/^[-\d.\s*]+/, '').trim())
                                         .filter(line => line.length > 10 && line.length < 150); // Ajustar filtro si es necesario
                      if (titles.length < 20) { // Esperar al menos la mitad
                          console.warn("La IA generó menos títulos de los esperados:", titles.length);
                          if (titles.length === 0) throw new Error("La IA no generó ninguna idea de crónica.");
                      }
                      return titles.slice(0, 40); // Devolver hasta 40
                  });
         }
         // createPollinationsImageUrl (adapt prompt)
         function createPollinationsImageUrl(promptText, options = {}) {
            const defaults = { seed: Math.floor(Math.random() * 10000000), width: 800, height: 600, nologo: true };
            const settings = { ...defaults, ...options };
            const safePromptText = typeof promptText === 'string' && promptText.trim() !== '' ? promptText : "Mortal Kombat vs Naruto Crossover";
            const enhancedPrompt = `Epic crossover artwork concept: '${safePromptText}'. Fusion of Mortal Kombat dark fantasy and Naruto anime styles. Dynamic action scene or character interaction. Cinematic lighting, detailed costumes and environments. Avoid text, logos, UI elements.`;
            const escapedPrompt = encodeURIComponent(enhancedPrompt);
            if (!escapedPrompt) return '';
            const negativePrompt = "text, words, labels, letters, title, caption, diagram, chart, graph, UI, menu, button, watermark, signature, multiple images, collage, realistic photograph, blurry, low quality, deformed figures, simple background";
            const escapedNegative = encodeURIComponent(negativePrompt);
            let url = `https://image.pollinations.ai/prompt/${escapedPrompt}?seed=${settings.seed}&width=${settings.width}&height=${settings.height}&negative=${escapedNegative}`;
            if (settings.nologo) url += '&nologo=true';
            console.log("Image URL:", url);
            return url;
        }

        // ========== Text Formatting Function ========== (sin cambios)
        function formatExplanationText(rawText) { /* ... (igual que antes) ... */
            if (!rawText) return '';
            let formatted = rawText.trim();
            formatted = formatted.replace(/\\text\{(.*?)\}/g, '$1');
            formatted = formatted.replace(/(\w)_\{?(\d+)\}?/g, '$1<sub>$2</sub>');
            formatted = formatted.replace(/(\w)\^\{?([\d+\-−]+)\}?/g, (match, base, exponent) => { const cleanExponent = exponent.replace('−', '-'); return `${base}<sup>${cleanExponent}</sup>`; });
            formatted = formatted.replace(/\\rightarrow/g, '&rarr;');
            formatted = formatted.replace(/\\\[\s*(.*?)\s*\\\]/g, '<p class="formula">$1</p>');
            formatted = formatted.replace(/^####\s+(.*)$/gm, '<h4>$1</h4>');
            formatted = formatted.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>');
            formatted = formatted.replace(/^##\s+(.*)$/gm, '<h2>$1</h2>');
            formatted = formatted.replace(/^#\s+(.*)$/gm, '<h1>$1</h1>');
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
            const blocks = formatted.split(/\n\s*\n/).filter(p => p.trim().length > 0);
            formatted = blocks.map(block => {
                if (block.startsWith('<h') || block.startsWith('<p class="formula">')) return block;
                let content = block.replace(/\n/g, ' ');
                return `<p>${content}</p>`;
            }).join('');
            return formatted;
        }

        // ========== MODAL FUNCTIONS ==========
        function showModal() { storyModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function hideModal() {
            storyModal.classList.remove('active');
            if (!imageFullscreenOverlay.classList.contains('active')) {
                document.body.style.overflow = '';
            }
            modalTextArea.scrollTop = 0;
            resetModalState();
        }
        function resetModalState() {
             // Hide content, show loading (which now contains puzzle placeholder)
             modalLoadingIndicator.classList.remove('active'); // Hide loading/puzzle initially
             modalStoryContentArea.classList.add('content-hidden');
             modalError.classList.add('content-hidden');
             modalTitle.textContent = '';
             modalContent.innerHTML = '';
             modalErrorMessage.textContent = '';
             chatHistory.innerHTML = '';
             chatInput.value = '';
             chatLoadingIndicator.style.display = 'none';
             chatSendBtn.disabled = false;
             currentStoryTitle = null;
             hideFullscreenImage();
             // Reset puzzle state variables and UI
             puzzleState = { level: 0, size: 0, tiles: [], emptyIndex: -1, moves: 0, solved: false, imageMap: {} };
             puzzleGrid.innerHTML = ''; // Clear old puzzle tiles
             puzzleLevelDisplay.textContent = '1';
             puzzleMovesDisplay.textContent = '0';
             puzzleMessageDisplay.textContent = '';
        }

        // ========== FULLSCREEN IMAGE FUNCTIONS ========== (sin cambios)
        function showFullscreenImage(imgSrc) { /* ... (igual que antes) ... */
             if (!imageFullscreenOverlay || !fullscreenImage) return;
            fullscreenImage.src = imgSrc;
            imageFullscreenOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        function hideFullscreenImage() { /* ... (igual que antes) ... */
            if (!imageFullscreenOverlay) return;
            imageFullscreenOverlay.classList.remove('active');
            if (!storyModal.classList.contains('active')) {
                 document.body.style.overflow = '';
            }
            fullscreenImage.src = '';
        }

        // ========== CHAT FUNCTIONS ========== (sin cambios funcionales)
        function addChatMessage(message, sender) { /* ... (igual que antes) ... */
             const msgDiv = document.createElement('div');
            msgDiv.classList.add('chat-message', sender === 'user' ? 'user-message' : 'ai-message');
            message = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            message = message.replace(/\*(.*?)\*/g, '<em>$1</em>');
            msgDiv.innerHTML = message;
            chatHistory.appendChild(msgDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        function addChatError(message) { /* ... (igual que antes) ... */
            const errorDiv = document.createElement('div');
             errorDiv.classList.add('chat-error');
             errorDiv.textContent = message;
             chatHistory.appendChild(errorDiv);
             chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        async function handleSendMessage() { /* ... (igual que antes) ... */
             const userQuery = chatInput.value.trim();
            if (!userQuery || chatSendBtn.disabled) return;
            addChatMessage(userQuery, 'user');
            chatInput.value = '';
            chatSendBtn.disabled = true;
            chatLoadingIndicator.style.display = 'block';
            try {
                const aiResponse = await fetchChatResponse(userQuery);
                addChatMessage(aiResponse, 'ai');
            } catch (error) {
                console.error("Chat Error:", error);
                addChatError(`Asistente IA: ${error.message}`);
            } finally {
                chatLoadingIndicator.style.display = 'none';
                chatSendBtn.disabled = false;
                chatInput.focus();
            }
        }

        // ========== PUZZLE GAME FUNCTIONS ==========
        function setupPuzzle(levelIndex) {
            puzzleState.level = levelIndex;
            const levelConfig = puzzleConfig.levels[levelIndex % puzzleConfig.levels.length]; // Loop levels
            puzzleState.size = levelConfig.size;
            puzzleState.moves = 0;
            puzzleState.solved = false;
            puzzleState.imageMap = {};

            puzzleGrid.innerHTML = ''; // Clear previous grid
            puzzleGrid.style.gridTemplateColumns = `repeat(${puzzleState.size}, 1fr)`;
            puzzleGrid.style.gridTemplateRows = `repeat(${puzzleState.size}, 1fr)`;
            // Adjust grid size dynamically (optional, can use fixed size)
             const gridPixelSize = Math.min(350, window.innerWidth * 0.7); // Max 350px wide
             puzzleGrid.style.width = `${gridPixelSize}px`;
             puzzleGrid.style.height = `${gridPixelSize}px`;


            puzzleLevelDisplay.textContent = puzzleState.level + 1;
            puzzleMovesDisplay.textContent = '0';
            puzzleMessageDisplay.textContent = '';

            // --- Create Solved State & Shuffle ---
            const tileCount = puzzleState.size * puzzleState.size;
            puzzleState.tiles = Array.from({ length: tileCount - 1 }, (_, i) => i + 1); // Tiles 1 to N-1
            puzzleState.tiles.push(null); // Add the empty space (null)
            puzzleState.emptyIndex = tileCount - 1;

             // Shuffle (Fisher-Yates variant that ensures solvability for sliding puzzles)
             // A simple N swaps guarantees solvability if the empty space starts at the bottom right
             let shuffleIterations = tileCount * 5; // Number of random swaps
             for (let i = 0; i < shuffleIterations; i++) {
                 const neighbors = getNeighbors(puzzleState.emptyIndex, puzzleState.size);
                 const randomIndex = Math.floor(Math.random() * neighbors.length);
                 const neighborIndex = neighbors[randomIndex];
                 swapTiles(puzzleState.emptyIndex, neighborIndex);
             }
             // Check if puzzle is already solved after shuffle (unlikely but possible)
             if (isPuzzleSolved()) {
                 // Perform one simple valid swap to unsolve it
                 const neighbors = getNeighbors(puzzleState.emptyIndex, puzzleState.size);
                 if (neighbors.length > 0) swapTiles(puzzleState.emptyIndex, neighbors[0]);
             }


            // --- Create Tile Elements & Assign Images ---
            const availableImages = [...puzzleConfig.tileImages]; // Copy image array
            shuffleArray(availableImages); // Shuffle images for variety

            puzzleState.tiles.forEach((tileValue, index) => {
                const tileElement = document.createElement('div');
                tileElement.classList.add('puzzle-tile');
                tileElement.dataset.index = index;

                if (tileValue === null) {
                    tileElement.classList.add('empty');
                    tileElement.textContent = ''; // Ensure empty has no number
                } else {
                    tileElement.textContent = tileValue; // Keep number for logic/debug
                    // Assign background image
                    const imgIndex = (tileValue - 1) % availableImages.length; // Loop through available images
                     tileElement.style.backgroundImage = `url('${availableImages[imgIndex]}')`;
                     puzzleState.imageMap[tileValue] = availableImages[imgIndex]; // Store for later use if needed

                    tileElement.addEventListener('click', handleTileClick);
                }
                puzzleGrid.appendChild(tileElement);
            });
        }

        function getNeighbors(index, size) {
            const neighbors = [];
            const row = Math.floor(index / size);
            const col = index % size;
            if (row > 0) neighbors.push(index - size); // Up
            if (row < size - 1) neighbors.push(index + size); // Down
            if (col > 0) neighbors.push(index - 1); // Left
            if (col < size - 1) neighbors.push(index + 1); // Right
            return neighbors;
        }

        function swapTiles(index1, index2) {
            // Swap in the JS array
            [puzzleState.tiles[index1], puzzleState.tiles[index2]] = [puzzleState.tiles[index2], puzzleState.tiles[index1]];

            // Update emptyIndex if it moved
            if (puzzleState.tiles[index1] === null) puzzleState.emptyIndex = index1;
            if (puzzleState.tiles[index2] === null) puzzleState.emptyIndex = index2;

            // Swap the DOM elements visually (find them by data-index)
            const tileElement1 = puzzleGrid.querySelector(`.puzzle-tile[data-index='${index1}']`);
            const tileElement2 = puzzleGrid.querySelector(`.puzzle-tile[data-index='${index2}']`);

            if (tileElement1 && tileElement2) {
                 // Simple DOM swap: Get parent, insert before the other's next sibling
                 const parent = puzzleGrid;
                 const next1 = tileElement1.nextSibling;
                 const next2 = tileElement2.nextSibling;
                 parent.insertBefore(tileElement1, next2);
                 parent.insertBefore(tileElement2, next1);
                // Re-assign dataset.index after swap to keep track
                 tileElement1.dataset.index = index2;
                 tileElement2.dataset.index = index1;
            } else {
                console.error("Could not find tile elements for swapping");
            }
        }

         function handleTileClick(event) {
            if (puzzleState.solved) return; // Don't move if already solved

            const clickedIndex = parseInt(event.target.dataset.index);
            const emptyIndex = puzzleState.emptyIndex;
            const size = puzzleState.size;

            // Check if the clicked tile is adjacent to the empty space
            const clickedRow = Math.floor(clickedIndex / size);
            const clickedCol = clickedIndex % size;
            const emptyRow = Math.floor(emptyIndex / size);
            const emptyCol = emptyIndex % size;

            const isAdjacent = (Math.abs(clickedRow - emptyRow) + Math.abs(clickedCol - emptyCol)) === 1;

            if (isAdjacent) {
                 // Find the visual tile elements before swapping in JS state
                const clickedElement = event.target;
                const emptyElement = puzzleGrid.querySelector('.puzzle-tile.empty');

                 // 1. Swap in JS state
                [puzzleState.tiles[clickedIndex], puzzleState.tiles[emptyIndex]] = [puzzleState.tiles[emptyIndex], puzzleState.tiles[clickedIndex]];
                puzzleState.emptyIndex = clickedIndex; // Update empty index
                puzzleState.moves++;
                puzzleMovesDisplay.textContent = puzzleState.moves;

                // 2. Swap visually in DOM
                if (clickedElement && emptyElement) {
                     // Swap classes and content/style
                     emptyElement.classList.remove('empty');
                     emptyElement.style.backgroundImage = clickedElement.style.backgroundImage;
                     emptyElement.textContent = clickedElement.textContent; // Swap number too
                     emptyElement.addEventListener('click', handleTileClick); // Re-add listener

                     clickedElement.classList.add('empty');
                     clickedElement.style.backgroundImage = '';
                     clickedElement.textContent = '';
                     clickedElement.removeEventListener('click', handleTileClick); // Remove listener from new empty
                }

                // 3. Check for win
                if (isPuzzleSolved()) {
                    puzzleState.solved = true;
                    puzzleMessageDisplay.textContent = `¡Nivel ${puzzleState.level + 1} Completado!`;
                    // Optional: Auto-advance after a short delay
                    setTimeout(() => {
                        if(modalLoadingIndicator.classList.contains('active')) { // Only advance if still loading
                           setupPuzzle(puzzleState.level + 1);
                        }
                    }, 1500);
                }
            }
        }

         function isPuzzleSolved() {
             for (let i = 0; i < puzzleState.tiles.length - 1; i++) {
                 if (puzzleState.tiles[i] !== i + 1) {
                     return false;
                 }
             }
             // Check if the last element is the empty one (null)
             return puzzleState.tiles[puzzleState.tiles.length - 1] === null;
         }


        // ========== UI & EVENT HANDLERS ==========
        function getRandomElement(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function shuffleArray(array) { /* ... (Fisher-Yates shuffle - same as before) ... */ let ci=array.length,ri;while(ci>0){ri=Math.floor(Math.random()*ci);ci--;[array[ci],array[ri]]=[array[ri],array[ci]];} return array; }
        function createTitleItem(title) { /* ... (same as before) ... */ const div=document.createElement('div'); div.className='title-item'; div.textContent=title; div.setAttribute('data-title', title); div.addEventListener('click', () => handleTitleClick(title)); return div; }
        function displayTitles(titles) { /* ... (same as before) ... */
            if (!titleListContainer || !titlesLoading) return;
             // Sort maybe by length or keep random? Let's sort alpha for now.
             const sortedTitles = titles.sort((a, b) => a.localeCompare(b));
             titleListContainer.innerHTML = '';
             titlesLoading.style.display = 'none';
             if (sortedTitles.length === 0) { titleListContainer.innerHTML = '<p class="text-gray-400 col-span-full text-center font-sans">» No hay crónicas disponibles en este reino «</p>'; return; }
             sortedTitles.forEach(title => titleListContainer.appendChild(createTitleItem(title)));
        }
        function appendTitles(newTitles) { /* ... (same as before) ... */
             if (!titleListContainer || !newTitles || newTitles.length === 0) return;
             const existingTitles = new Set(Array.from(titleListContainer.querySelectorAll('.title-item')).map(item => item.dataset.title));
             newTitles.forEach(title => { if (!existingTitles.has(title)) { titleListContainer.appendChild(createTitleItem(title)); } });
             filterTitles(searchInput.value);
         }

        // *** MODIFIED: handleTitleClick to manage puzzle visibility ***
        async function handleTitleClick(title) {
            resetModalState(); // Resets everything, including puzzle state vars
            showModal();
            currentStoryTitle = title; // Set context for chat and API

            // --- Start Loading Sequence ---
            modalLoadingIndicator.classList.add('active'); // Show loading container
            modalStoryContentArea.classList.add('content-hidden'); // Hide main content
            setupPuzzle(0); // Setup and display puzzle level 1

            // --- Fetch Data Asynchronously ---
            try {
                // Fetch text and image URL *concurrently* if possible, but process sequentially
                const explanationPromise = fetchExplanationText(title);
                // We need title for image, can't fetch image URL before text potentially
                 const rawExplanationText = await explanationPromise; // Wait for text
                const formattedExplanation = formatExplanationText(rawExplanationText);
                const imageUrl = createPollinationsImageUrl(title); // Generate image URL based on title


                // --- Content Ready - Switch View ---
                modalLoadingIndicator.classList.remove('active'); // Hide loading/puzzle
                modalStoryContentArea.classList.remove('content-hidden'); // Show content area

                modalTitle.textContent = title;
                modalContent.innerHTML = formattedExplanation; // Add text

                modalTextArea.scrollTop = 0; // Reset scroll

                // --- Image Handling (Placeholder -> Load -> Display/Error) ---
                const placeholderDiv = document.createElement('div');
                placeholderDiv.className = 'image-placeholder';
                placeholderDiv.innerHTML = `
                    <div class="spinner"></div>
                    <i class="fas fa-image placeholder-icon"></i>
                    <p style="font-size: 0.8em; margin-top: 0.5rem;">Invocando visión...</p>`;
                modalContent.appendChild(placeholderDiv);

                if (imageUrl) {
                    const imgElement = document.createElement('img');
                    imgElement.className = 'final-image';
                    imgElement.alt = `Ilustración: ${title}`;
                    imgElement.style.display = 'none';

                    imgElement.onload = () => {
                        console.log("Image loaded.");
                        placeholderDiv.remove();
                        imgElement.style.display = 'block';
                        imgElement.addEventListener('click', () => showFullscreenImage(imgElement.src));
                    };
                    imgElement.onerror = () => {
                        console.error("Image load error for:", title);
                         placeholderDiv.innerHTML = `<i class="fas fa-eye-slash placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Visión fallida.</p>`;
                    };
                    imgElement.src = imageUrl;
                    modalContent.appendChild(imgElement);
                } else {
                    console.error("Could not create image URL for:", title);
                    placeholderDiv.innerHTML = `<i class="fas fa-exclamation-circle placeholder-icon"></i><p style="font-size:0.8em;margin-top:0.5rem;">Error URL de imagen.</p>`;
                }

                 // Make chat visible now that content is loaded
                chatSection.classList.remove('content-hidden');


            } catch (error) {
                console.error("Failed display:", error);
                 // --- Error Handling ---
                 modalLoadingIndicator.classList.remove('active'); // Hide loading/puzzle
                 modalStoryContentArea.classList.remove('content-hidden'); // Show content area to display error
                 modalErrorMessage.textContent = error.message || "Error desconocido al cargar la crónica.";
                 modalError.classList.remove('content-hidden'); // Show error message div
                 modalContent.innerHTML = ''; // Clear any partial content
                 chatSection.classList.add('content-hidden'); // Hide chat on main error
            }
        }

        // *** MODIFIED: handleGenerateMoreTitles requests 40 ***
        async function handleGenerateMoreTitles() {
             if (!generateMoreBtn || !generateMoreSpinner || !generateMoreContainer) return;
             generateMoreBtn.disabled = true;
             // Update button text to reflect 40
             generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-2 animate-spin"></i> Invocando 40 Crónicas...';
             try {
                 const newTitles = await fetchGeneratedTitles(); // Fetches up to 40
                 if (newTitles && newTitles.length > 0) {
                     appendTitles(newTitles);
                 } else {
                     alert("No se pudieron invocar más crónicas en este momento.");
                 }
             } catch (error) {
                 console.error("Failed title generation:", error);
                 alert(`Error al invocar crónicas: ${error.message}`);
             } finally {
                 generateMoreBtn.disabled = false;
                 // Reset button text
                 generateMoreBtn.innerHTML = '<i class="fas fa-sync-alt mr-2 animate-spin hidden"></i> Invocar Más Crónicas (40)';
             }
         }

         // Search Filter Function (con normalización)
         function filterTitles(searchTerm) {
             const term = searchTerm.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
             const titleItems = titleListContainer.querySelectorAll('.title-item');
             let visibleCount = 0;
             titleItems.forEach(item => {
                 const titleText = item.dataset.title.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                 const isVisible = titleText.includes(term);
                 item.classList.toggle('hidden', !isVisible);
                 if (isVisible) visibleCount++;
             });
             noResultsMsg.classList.toggle('hidden', visibleCount > 0);
         }

        // ========== INITIALIZATION ==========
        function initApp() {
            // Check for all essential elements, including puzzle ones
            if (!titleListContainer || !storyModal || !modalCloseBtn || !generateMoreBtn || !titlesLoading || !searchInput || !noResultsMsg || !chatInput || !chatSendBtn || !imageFullscreenOverlay || !fullscreenCloseBtn || !modalLoadingIndicator || !puzzleGrid || !puzzleLevelDisplay || !puzzleMovesDisplay || !puzzleMessageDisplay) {
                console.error("Initialization failed: Missing essential elements.");
                 document.body.innerHTML = '<p style="color: red; font-size: 1.5em; text-align: center; padding-top: 3em;">FATAL ERROR: Fallo al inicializar componentes de la interfaz.</p>';
                return;
             }
            // Event Listeners (Modal, Generate More, Search, Chat, Fullscreen Image - same as before)
            modalCloseBtn.addEventListener('click', hideModal);
            storyModal.addEventListener('click', (event) => { if (event.target === storyModal) hideModal(); });
            generateMoreBtn.addEventListener('click', handleGenerateMoreTitles);
            searchInput.addEventListener('input', (event) => filterTitles(event.target.value));
            searchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') event.preventDefault(); });
            chatSendBtn.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') handleSendMessage(); });
            imageFullscreenOverlay.addEventListener('click', hideFullscreenImage);
            fullscreenCloseBtn.addEventListener('click', (event) => { event.stopPropagation(); hideFullscreenImage(); });

            // Initial display
            displayTitles(predefinedTitles);
            noResultsMsg.classList.add('hidden');
        }
        document.addEventListener('DOMContentLoaded', initApp);
    </script>

</body>
</html>