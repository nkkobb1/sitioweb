<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlowTrainer // CYBERPUNK //</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;700&display=swap" rel="stylesheet">

  <style>
    /* --- ESTILOS CSS (CON MODAL Y CORRECCIONES) --- */
    :root {
      --neon-cyan: #00ffff;
      --neon-magenta: #ff00ff;
      --neon-blue: #2a7ffb;
      --neon-green: #39ff14;
      --dark-bg: #0d0f1c;
      --dark-surface: #1a1d2e;
      --dark-surface-light: #2c2f4a;
      --text-light: #e0e0e0;
      --text-medium: #a0a0a0;
      --text-dark: #1f1f1f;
      --glow-cyan: rgba(0, 255, 255, 0.7);
      --glow-magenta: rgba(255, 0, 255, 0.7);
      --glow-blue: rgba(42, 127, 251, 0.7);
      --glow-green: rgba(57, 255, 20, 0.7);
      --error: #ff4d4d;
      --success: var(--neon-green);
      --warning: #ffaa00;

      --font-primary: 'Orbitron', sans-serif;
      --font-secondary: 'Rajdhani', sans-serif;

      --shadow-depth-1: 0 4px 15px rgba(0, 0, 0, 0.3);
      --shadow-depth-2: 0 8px 30px rgba(0, 0, 0, 0.5);
      --shadow-neon-cyan: 0 0 4px var(--neon-cyan), 0 0 8px var(--neon-cyan), 0 0 12px var(--glow-cyan);
      --shadow-neon-magenta: 0 0 4px var(--neon-magenta), 0 0 8px var(--neon-magenta), 0 0 12px var(--glow-magenta);
      --shadow-neon-blue: 0 0 4px var(--neon-blue), 0 0 8px var(--neon-blue), 0 0 12px var(--glow-blue);
      --shadow-neon-green: 0 0 4px var(--neon-green), 0 0 8px var(--neon-green), 0 0 12px var(--glow-green);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.3s ease, transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
    html { scroll-behavior: smooth; }
    body { background-color: var(--dark-bg); color: var(--text-light); min-height: 100vh; padding-bottom: 100px; font-family: var(--font-secondary); font-size: 17px; line-height: 1.7; background-image: linear-gradient(rgba(42, 127, 251, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(42, 127, 251, 0.05) 1px, transparent 1px), radial-gradient(circle at top left, rgba(0, 255, 255, 0.08), transparent 40%), radial-gradient(circle at bottom right, rgba(255, 0, 255, 0.08), transparent 50%); background-size: 30px 30px, 30px 30px, 100% 100%, 100% 100%; overflow-x: hidden; animation: pulseBg 15s infinite alternate; }
    @keyframes pulseBg { 0% { background-color: var(--dark-bg); } 100% { background-color: #101220; } }
    header { background-color: rgba(13, 15, 28, 0.6); backdrop-filter: blur(15px) saturate(120%); -webkit-backdrop-filter: blur(15px) saturate(120%); position: sticky; top: 0; z-index: 1000; padding: 12px 0; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4); border-bottom: 1px solid rgba(0, 255, 255, 0.2); animation: slideDown 0.5s ease-out; }
    @keyframes slideDown { from { transform: translateY(-100%); opacity: 0;} to { transform: translateY(0); opacity: 1;} }
    .header-container { max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; padding: 0 30px; }
    .logo { display: flex; align-items: center; gap: 15px; }
    .logo img { width: 45px; height: 45px; border-radius: 50%; border: 2px solid var(--neon-cyan); box-shadow: var(--shadow-neon-cyan); animation: spinLogo 20s linear infinite; }
    @keyframes spinLogo { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .logo-text { font-family: var(--font-primary); font-size: 28px; font-weight: 700; color: var(--text-light); text-shadow: var(--shadow-neon-magenta); letter-spacing: 2px; animation: neonFlicker 5s infinite alternate; margin-right: 15px; }
    @keyframes neonFlicker { 0%, 18%, 22%, 25%, 53%, 57%, 100% { text-shadow: 0 0 4px #fff, 0 0 10px var(--neon-magenta), 0 0 18px var(--neon-magenta), 0 0 38px var(--neon-magenta), 0 0 70px var(--glow-magenta); opacity: 1; } 20%, 24%, 55% { text-shadow: none; opacity: 0.8; } }
    .user-aka { font-family: var(--font-secondary); font-size: 18px; font-weight: 500; color: var(--neon-cyan); text-shadow: var(--shadow-neon-cyan); letter-spacing: 1px; opacity: 0.8; cursor: pointer; /* Para indicar que se puede cambiar */ transition: opacity 0.3s ease; }
    .user-aka:hover { opacity: 1; text-shadow: 0 0 6px var(--neon-cyan), 0 0 10px var(--glow-cyan);}
    nav ul { display: flex; list-style: none; gap: 35px; }
    nav ul li a { color: var(--text-medium); text-decoration: none; font-size: 18px; font-weight: 500; padding: 8px 0; position: relative; letter-spacing: 1px; transition: color 0.3s ease, text-shadow 0.3s ease; font-family: var(--font-secondary); }
    nav ul li a::before { content: '['; position: absolute; left: -10px; opacity: 0; color: var(--neon-cyan); transition: opacity 0.3s ease, left 0.3s ease; }
    nav ul li a::after { content: ']'; position: absolute; right: -10px; opacity: 0; color: var(--neon-cyan); transition: opacity 0.3s ease, right 0.3s ease; }
    nav ul li a:hover, nav ul li a.active { color: var(--neon-cyan); text-shadow: 0 0 5px var(--neon-cyan), 0 0 10px var(--glow-cyan); }
    nav ul li a:hover::before, nav ul li a.active::before { opacity: 1; left: -15px; }
    nav ul li a:hover::after, nav ul li a.active::after { opacity: 1; right: -15px; }
    main { padding: 3rem 2rem; max-width: 1400px; margin: 0 auto; }
    .container { max-width: 1400px; margin: 0 auto; padding: 0; width: 100%; }
    .section { background-color: rgba(26, 29, 46, 0.8); border-radius: 10px; padding: 2.5rem; box-shadow: var(--shadow-depth-2), inset 0 0 20px rgba(0,0,0,0.3); border: 1px solid rgba(42, 127, 251, 0.2); margin-bottom: 2.5rem; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
    @keyframes fadeInSection { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
    h2 { font-family: var(--font-primary); color: var(--neon-blue); margin-bottom: 1.8rem; font-size: 2.2rem; font-weight: 700; letter-spacing: 1px; border-bottom: 2px solid var(--neon-blue); padding-bottom: 0.8rem; text-shadow: var(--shadow-neon-blue); display: inline-block; }
    .modes { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 2rem; }
    .mode-card { background: linear-gradient(145deg, var(--dark-surface), #23263a); border-radius: 8px; padding: 2rem; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); cursor: pointer; display: flex; flex-direction: column; text-align: center; border: 1px solid transparent; position: relative; overflow: hidden; box-shadow: var(--shadow-depth-1); }
    .mode-card::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(transparent, rgba(0, 255, 255, 0.05), transparent); animation: scanline 3s linear infinite; opacity: 0; transition: opacity 0.4s ease; pointer-events: none; background-size: 100% 5px; }
    @keyframes scanline { 0% { background-position: 0 -100px; } 100% { background-position: 0 100%; } }
    .mode-card:hover { transform: translateY(-10px) scale(1.03); box-shadow: var(--shadow-depth-2), 0 0 25px var(--glow-cyan); border: 1px solid var(--neon-cyan); background: linear-gradient(145deg, var(--dark-surface-light), #2a2e45); }
    .mode-card:hover::before { opacity: 1; }
    .mode-card i { font-size: 2.8rem; margin-bottom: 1.5rem; color: var(--neon-cyan); text-shadow: var(--shadow-neon-cyan); transition: transform 0.3s ease; }
    .mode-card:hover i { transform: scale(1.1) rotate(-5deg); }
    .mode-card h3 { font-family: var(--font-primary); font-size: 1.6rem; margin-bottom: 1rem; color: var(--text-light); font-weight: 500; transition: color 0.3s ease; }
    .mode-card:hover h3 { color: var(--neon-cyan); }
    .mode-card p { font-size: 1rem; color: var(--text-medium); line-height: 1.6; flex-grow: 1; }
    .mode-card.selected-feedback { animation: pulseBorder 0.5s ease-out; border-color: var(--neon-green); box-shadow: var(--shadow-depth-2), 0 0 35px var(--glow-green); }
    @keyframes pulseBorder { 0% { transform: scale(1.03); border-width: 1px; } 50% { transform: scale(1.06); border-width: 2px; box-shadow: var(--shadow-depth-2), 0 0 45px var(--glow-green); border-color: var(--neon-green);} 100% { transform: scale(1.03); border-width: 1px; } }
    .session-area { flex-direction: column; gap: 2rem; background-color: rgba(26, 29, 46, 0.7); border-radius: 8px; padding: 2rem; box-shadow: var(--shadow-depth-1), inset 0 0 15px rgba(0,0,0,0.2); border: 1px solid rgba(255, 0, 255, 0.2); margin-top: 2rem; display: flex; position: relative; }
    .control-panel { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: center; justify-content: space-between; padding: 1.5rem; background-color: rgba(44, 47, 74, 0.5); border-radius: 6px; border: 1px solid rgba(255, 0, 255, 0.1); }
    .timer { font-family: var(--font-primary); font-size: 2.8rem; font-weight: 700; color: var(--neon-magenta); background-color: transparent; padding: 0.5rem 1rem; border-radius: 4px; min-width: 180px; text-align: center; text-shadow: var(--shadow-neon-magenta); animation: pulseTimerBase 1.5s infinite alternate; }
    @keyframes pulseTimerBase { from { opacity: 0.9; transform: scale(1); } to { opacity: 1; transform: scale(1.01); } }
    .controls { display: flex; gap: 1rem; }
    button, .btn { font-family: var(--font-secondary); background: transparent; color: var(--text-light); border: 2px solid var(--neon-blue); padding: 12px 28px; border-radius: 5px; cursor: pointer; font-weight: 700; font-size: 1rem; letter-spacing: 1px; display: inline-flex; align-items: center; justify-content: center; text-transform: uppercase; box-shadow: inset 0 0 0 0 var(--neon-blue); transition: all 0.3s ease-in-out, color 0.1s linear 0s; position: relative; overflow: hidden; }
    button i, .btn i { margin-right: 10px; font-size: 1.1em; }
    button:hover, .btn:hover { color: var(--dark-bg); box-shadow: inset 0 0 0 50px var(--neon-blue); border-color: var(--neon-blue); text-shadow: none; }
    button::before, .btn::before { content: ''; position: absolute; top: -2px; left: -2px; width: calc(100% + 4px); height: calc(100% + 4px); background: linear-gradient(45deg, var(--neon-cyan), var(--neon-magenta)); z-index: -1; opacity: 0; transition: opacity 0.3s ease; }
    button:hover::before, .btn:hover::before { opacity: 0.1; animation: glitchBorder 0.5s infinite linear alternate-reverse; }
    @keyframes glitchBorder { 0% { clip-path: inset(80% -6px -6px -6px); } 20% { clip-path: inset(-6px 80% -6px -6px); } 40% { clip-path: inset(80% -6px -6px -6px); } 60% { clip-path: inset(-6px -6px 30% 80%); } 80% { clip-path: inset(50% -6px -6px 50%); } 100% { clip-path: inset(-6px 40% 70% -6px); } }
    button:active, .btn:active { transform: scale(0.97); box-shadow: inset 0 0 0 60px var(--neon-blue); }
    button:disabled, .btn:disabled { border-color: #555 !important; color: #777 !important; cursor: not-allowed !important; box-shadow: none !important; background: transparent !important; text-shadow: none !important;}
    button:disabled:hover, .btn:disabled:hover { color: #777 !important; box-shadow: none !important; }
    button:disabled::before, .btn:disabled::before { display: none !important; }
    .btn-primary { border-color: var(--neon-cyan); box-shadow: inset 0 0 0 0 var(--neon-cyan); }
    .btn-primary:hover:not(:disabled) { box-shadow: inset 0 0 0 50px var(--neon-cyan); border-color: var(--neon-cyan); }
    .btn-primary:active:not(:disabled) { box-shadow: inset 0 0 0 60px var(--neon-cyan); }
    .btn-danger { border-color: var(--error); box-shadow: inset 0 0 0 0 var(--error); }
    .btn-danger:hover:not(:disabled) { box-shadow: inset 0 0 0 50px var(--error); border-color: var(--error); color: var(--text-light); }
    .btn-danger:active:not(:disabled) { box-shadow: inset 0 0 0 60px var(--error); }
    .btn-secondary { border-color: var(--neon-magenta); box-shadow: inset 0 0 0 0 var(--neon-magenta); }
    .btn-secondary:hover:not(:disabled) { box-shadow: inset 0 0 0 50px var(--neon-magenta); border-color: var(--neon-magenta); }
    .btn-secondary:active:not(:disabled) { box-shadow: inset 0 0 0 60px var(--neon-magenta); }
    .session-content { display: flex; flex-direction: column; align-items: center; gap: 2rem; margin-top: 1rem; }
    .word-display { font-family: var(--font-primary); font-size: 3.5rem; line-height: 1.4; font-weight: 900; min-height: 10rem; display: flex; align-items: center; justify-content: center; text-align: center; padding: 2rem 3rem; width: 100%; background-color: rgba(13, 15, 28, 0.8); border-radius: 6px; box-shadow: var(--shadow-depth-1), inset 0 0 10px rgba(0,0,0,0.4); color: var(--neon-green); text-shadow: 0 0 6px rgba(57, 255, 20, 0.6); border: 1px solid rgba(57, 255, 20, 0.3); position: relative; overflow: hidden; transition: opacity 0.2s ease-out, transform 0.2s ease-out; z-index: 1; }
    .word-display.content-changing { opacity: 0; transform: translateY(15px) scale(0.95); }
    .word-display.content-entering { opacity: 1; transform: translateY(0) scale(1); animation: fadeInContent 0.4s ease-out; transition: opacity 0.4s ease-out, transform 0.4s ease-out; }
    @keyframes fadeInContent { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
    .word-display::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(0deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px); background-size: 20px 20px; opacity: 0.5; animation: subtleGridShift 20s linear infinite; z-index: 0; pointer-events: none; }
    @keyframes subtleGridShift { from { background-position: 0 0; } to { background-position: 40px 40px; } }
    .session-area.session-active .word-display::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(transparent 50%, rgba(13, 15, 28, 0.2) 50%); background-size: 100% 4px; opacity: 0.3; animation: scanlineMove 8s linear infinite; z-index: 0; pointer-events: none; }
    @keyframes scanlineMove { from { background-position: 0 0; } to { background-position: 0 -100px; } }
    .word-display > *, .word-display .mixto-content-wrapper > * { position: relative; z-index: 1; }
    .word-display:not(:has(> *)) { position: relative; z-index: 1; }
    .mixto-content-wrapper { position: relative; z-index: 1; }
    .word-display.glitchy { animation: glitchEffect 0.3s cubic-bezier(.25,.46,.45,.94) both infinite; }
    @keyframes glitchEffect{ 0%{ transform: translate(0); } 20%{ transform: translate(-3px, 3px); text-shadow: 0 0 8px var(--neon-magenta); color: var(--neon-magenta); } 40%{ transform: translate(-3px, -3px); text-shadow: 0 0 8px var(--neon-blue); color: var(--neon-blue); } 60%{ transform: translate(3px, 3px); text-shadow: 0 0 8px var(--neon-green); color: var(--neon-green); } 80%{ transform: translate(3px, -3px); text-shadow: 0 0 8px var(--neon-cyan); color: var(--neon-cyan); } 100%{ transform: translate(0); text-shadow: 0 0 6px rgba(57, 255, 20, 0.6); color: var(--neon-green); } }
    .mode-settings, .dict-lang-panel { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: center; justify-content: center; background-color: rgba(44, 47, 74, 0.3); padding: 1.2rem; border-radius: 6px; border: 1px solid rgba(0, 255, 255, 0.1); margin-top: 2rem; }
    .control-panel .mode-settings { margin-top: 0; padding: 0; background: none; border: none; justify-content: flex-start; }
    .mode-settings label, .dict-lang-panel label { margin-right: 0.5rem; font-weight: 500; color: var(--text-medium); }
    .mode-settings span, .dict-lang-panel span { color: var(--neon-cyan); font-weight: 700; margin-left: 5px; }
    input[type="number"], select { background-color: var(--dark-surface); color: var(--text-light); border: 1px solid var(--neon-blue); border-radius: 4px; padding: 8px 12px; font-family: var(--font-secondary); font-size: 1rem; width: 80px; text-align: center; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); transition: border-color 0.3s ease, box-shadow 0.3s ease; }
    input[type="number"]:focus, select:focus { outline: none; border-color: var(--neon-cyan); box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), var(--shadow-neon-cyan); }
    select { width: auto; min-width: 150px; cursor: pointer; appearance: none; -webkit-appearance: none; padding-right: 30px; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%2300ffff'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.03a.75.75 0 0 1 1.06 0L8 8.74l2.72-2.71a.75.75 0 1 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0L4.22 7.09a.75.75 0 0 1 0-1.06Z' clip-rule='evenodd' /%3E%3C/svg%3E%0A"); background-repeat: no-repeat; background-position: right 10px center; background-size: 16px; }
    select:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23555555'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.03a.75.75 0 0 1 1.06 0L8 8.74l2.72-2.71a.75.75 0 1 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0L4.22 7.09a.75.75 0 0 1 0-1.06Z' clip-rule='evenodd' /%3E%3C/svg%3E%0A"); }
    #loading-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 700; color: var(--neon-magenta); text-shadow: var(--shadow-neon-magenta); font-family: var(--font-primary); letter-spacing: 1px; animation: loadingPulse 1.5s infinite alternate; }
    @keyframes loadingPulse { from { opacity: 0.7; text-shadow: 0 0 8px var(--glow-magenta); } to { opacity: 1; text-shadow: 0 0 12px var(--glow-magenta); } }
    #loading-indicator::before { content: ''; width: 18px; height: 18px; border: 3px solid rgba(255, 0, 255, 0.3); border-top-color: var(--neon-magenta); border-radius: 50%; animation: spinLoader 0.8s linear infinite; }
    @keyframes spinLoader { to { transform: rotate(360deg); } }
    .settings-panel { display: flex; flex-direction: column; gap: 1.8rem; }
    .setting-group { display: flex; flex-wrap: wrap; align-items: center; gap: 1rem; padding: 1rem 0; border-bottom: 1px dashed rgba(42, 127, 251, 0.2); }
    .setting-group:last-child { border-bottom: none; }
    .setting-group label { font-weight: 500; color: var(--text-medium); flex-basis: 250px; }
    .setting-group span { color: var(--neon-cyan); font-weight: 700; margin-left: 5px; }
    #info-content { margin-top: 1.5rem; padding: 1.5rem; background-color: var(--dark-surface-light); border-radius: 6px; border-left: 4px solid var(--neon-magenta); color: var(--text-medium); font-size: 0.95rem; line-height: 1.8; }
    #info-content p { margin-bottom: 1rem; }
    #info-content strong { color: var(--neon-cyan); }
    #audio-player { position: fixed; bottom: 0; left: 0; width: 100%; display: flex; flex-direction: column; background: linear-gradient(to top, rgba(13, 15, 28, 0.95), rgba(26, 29, 46, 0.85)); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.5); z-index: 1100; border-top: 2px solid var(--neon-magenta); padding: 5px 0 0 0; transition: transform 0.4s ease-in-out; }
    .player-core { display: flex; align-items: center; justify-content: space-between; padding: 8px 25px; width: 100%; }
    .player-info { display: flex; align-items: center; gap: 15px; }
    #time-indicator { font-size: 0.85rem; color: var(--text-medium); font-weight: 400; letter-spacing: 0.5px; min-width: 100px; text-align: right; }
    #audio-controls { display: flex; justify-content: center; align-items: center; gap: 12px; }
    #audio-controls button { background: transparent; border: 1px solid var(--neon-blue); color: var(--neon-blue); width: 40px; height: 40px; border-radius: 50%; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1rem; cursor: pointer; transition: all 0.2s ease; box-shadow: none; }
    #audio-controls button:hover { background-color: rgba(42, 127, 251, 0.1); color: var(--neon-cyan); border-color: var(--neon-cyan); transform: scale(1.08); box-shadow: var(--shadow-neon-cyan); }
    #audio-controls button:active { transform: scale(0.95); }
    #play-pause-btn { width: 55px; height: 55px; border-width: 2px; font-size: 1.3rem; border-color: var(--neon-magenta); color: var(--neon-magenta); }
    #play-pause-btn:hover { background-color: rgba(255, 0, 255, 0.1); color: var(--text-light); border-color: var(--neon-magenta); box-shadow: var(--shadow-neon-magenta); }
    #play-pause-btn #loading-indicator { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: rgba(13, 15, 28, 0.8); border-radius: 50%; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; pointer-events: none; }
    #play-pause-btn.loading #loading-indicator { opacity: 1; visibility: visible; }
    #play-pause-btn.loading i { opacity: 0.2; }
    #play-pause-btn #loading-indicator .spinner { width: 22px; height: 22px; border: 3px solid rgba(255, 0, 255, 0.3); border-top-color: var(--neon-magenta); border-radius: 50%; animation: spinLoader 0.8s linear infinite; }
    #play-pause-btn #loading-indicator::before { content: none; }
    .player-side-controls { }
    #repeat-toggle { font-size: 0.8rem; padding: 5px 10px; border-radius: 4px; width: auto; height: auto; border: 1px solid var(--text-medium); color: var(--text-medium); opacity: 0.7; }
    #repeat-toggle.active, #repeat-toggle:hover { opacity: 1; border-color: var(--neon-green); color: var(--neon-green); background-color: rgba(57, 255, 20, 0.1); box-shadow: 0 0 8px var(--neon-green); }
    #progress-container { width: 100%; height: 5px; background-color: rgba(44, 47, 74, 0.5); cursor: pointer; position: relative; overflow: hidden; }
    #progress-bar { height: 100%; background: linear-gradient(90deg, var(--neon-magenta), var(--neon-cyan)); width: 0; border-radius: 0; position: relative; box-shadow: var(--shadow-neon-magenta); transition: width 0.1s linear; }
    #progress-bar::after { content: ''; position: absolute; top: 0; right: -50px; width: 50px; height: 100%; background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent); transform: skewX(-30deg); animation: progressBarShine 2.5s linear infinite; opacity: 0.8; }
    @keyframes progressBarShine { from { right: -50px; } to { right: 120%; } }
    @media (max-width: 768px) { /* ... (media queries sin cambios) ... */ }
    @media (max-width: 480px) { /* ... (media queries sin cambios) ... */ }
    .hidden { display: none !important; }
    .word-display .spinner { border: 4px solid rgba(0, 255, 255, 0.2); border-left-color: var(--neon-cyan); border-radius: 50%; width: 40px; height: 40px; animation: spinLoader 1s linear infinite; z-index: 1; position: relative; }

    /* --- ESTILOS PARA EL MODAL DEL AKA --- */
    #aka-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(13, 15, 28, 0.8); /* Fondo oscuro semi-transparente */
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000; /* Muy alto para estar encima de todo */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.4s ease, visibility 0s linear 0.4s;
    }
    #aka-modal-overlay.visible {
        opacity: 1;
        visibility: visible;
        transition: opacity 0.4s ease;
    }
    .aka-modal-content {
        background: linear-gradient(145deg, var(--dark-surface), #23263a);
        padding: 2.5rem 3rem;
        border-radius: 8px;
        border: 1px solid var(--neon-magenta);
        box-shadow: var(--shadow-depth-2), 0 0 30px var(--glow-magenta);
        text-align: center;
        max-width: 450px;
        width: 90%;
        transform: scale(0.9);
        opacity: 0;
        transition: transform 0.3s ease-out 0.1s, opacity 0.3s ease-out 0.1s;
    }
     #aka-modal-overlay.visible .aka-modal-content {
         transform: scale(1);
         opacity: 1;
     }

    .aka-modal-content h3 {
        font-family: var(--font-primary);
        color: var(--neon-magenta);
        font-size: 1.8rem;
        margin-bottom: 1rem;
        text-shadow: var(--shadow-neon-magenta);
    }
    .aka-modal-content p {
        color: var(--text-medium);
        margin-bottom: 1.8rem;
        font-size: 1rem;
        line-height: 1.6;
    }
    #aka-input {
        display: block;
        width: 100%;
        padding: 12px 15px;
        margin-bottom: 1.5rem;
        background-color: var(--dark-surface);
        color: var(--text-light);
        border: 1px solid var(--neon-blue);
        border-radius: 4px;
        font-family: var(--font-secondary);
        font-size: 1.1rem;
        text-align: center;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    #aka-input:focus {
        outline: none;
        border-color: var(--neon-cyan);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), var(--shadow-neon-cyan);
    }
    #aka-error-message {
        color: var(--error);
        font-size: 0.9rem;
        min-height: 1.2em; /* Espacio para el mensaje */
        margin-bottom: 1rem;
        display: block; /* Para que ocupe espacio aunque esté vacío */
    }
    #submit-aka-btn {
        /* Usa el estilo de botón existente pero con color primario */
        border-color: var(--neon-cyan);
        color: var(--text-light);
        box-shadow: inset 0 0 0 0 var(--neon-cyan);
    }
    #submit-aka-btn:hover {
        color: var(--dark-bg);
        box-shadow: inset 0 0 0 50px var(--neon-cyan);
        border-color: var(--neon-cyan);
        text-shadow: none;
    }
    /* --- FIN ESTILOS MODAL AKA --- */

  </style>
</head>
<body>

  <!-- --- MODAL PARA EL AKA --- -->
  <div id="aka-modal-overlay">
      <div class="aka-modal-content">
          <h3><i class="fas fa-terminal" style="margin-right: 10px;"></i> Identidad Requerida</h3>
          <p>Conectando a la red... Se requiere un alias (AKA) para proceder.</p>
          <input type="text" id="aka-input" placeholder="Ingresa tu AKA" maxlength="20">
          <span id="aka-error-message"></span>
          <button id="submit-aka-btn" class="btn"><i class="fas fa-check-double"></i> Confirmar Identidad</button>
      </div>
  </div>
  <!-- --- FIN MODAL --- -->

  <header>
    <div class="header-container">
      <div class="logo">
        <img src="https://blogger.googleusercontent.com/img/a/AVvXsEiLlZXJKRUaKqGfbAM5AwvWb3BeTOA0Gxwpmy0L1AYDcB00-vzRLMA9GK9z0XY37_BOEUdE1H00aVQQhYnXnCgWWsC5FzLW0mfXpJ1qgwdWqRNcxxnwNWn8xL0bRKIML2v9gn9YgLYFDZbtb30SHV7FyNvjC_1HzPJbs2ThM5vEGS6g-oP3jZ2mi3wmaPc" alt="FlowTrainer Logo">
        <span class="logo-text">FlowTrainer</span>
        <span id="user-aka" class="user-aka" title="Click para cambiar tu AKA"></span>
      </div>
      <nav>
        <ul>
          <li><a href="#" class="nav-item active" data-section="home">Inicio</a></li>
          <li><a href="#" class="nav-item" data-section="settings">Ajustes</a></li>
        </ul>
      </nav>
    </div>
  </header>
  <main>
    <div class="container">
      <!-- Sección de Inicio -->
      <section id="home" class="section">
        <h2 id="home-title"><i class="fas fa-atom fa-spin" style="--fa-animation-duration: 5s; margin-right: 10px;"></i> Modos de Entrenamiento</h2>
        <div class="modes">
           <div class="mode-card" data-mode="palabras-aleatorias"> <i class="fas fa-dice-d20"></i> <h3>Palabras Aleatorias</h3> <p>Muestra una palabra aleatoria a intervalos ajustables.</p> </div>
           <div class="mode-card" data-mode="multi-palabras"> <i class="fas fa-cubes"></i> <h3>Multi Palabras</h3> <p>Muestra varias palabras simultáneamente.</p> </div>
           <div class="mode-card" data-mode="palabras-largas"> <i class="fas fa-ruler-combined"></i> <h3>Palabras Largas</h3> <p>Muestra solo palabras de 9 o más letras.</p> </div>
           <div class="mode-card" data-mode="libre"> <i class="fas fa-infinity"></i> <h3>Modo Libre</h3> <p>Avanza el cronómetro sin mostrar palabras.</p> </div>
           <div class="mode-card" data-mode="imagenes-aleatorias"> <i class="fas fa-camera-retro"></i> <h3>Imágenes Aleatorias</h3> <p>Elige la frecuencia, miles de imagenes a tu disposicion.</p> </div>
           <div class="mode-card" data-mode="kickback"> <i class="fas fa-question"></i> <h3>Kick Back</h3> <p>Muestra preguntas aleatorias (ES/EN).</p> </div>
           <div class="mode-card" data-mode="mixto"> <i class="fas fa-brain"></i> <h3>Mixto</h3> <p>Combina 1 imagen aleatoria y 3 palabras.</p> </div>
        </div>
        <div id="training-content" class="hidden">
            <div class="dict-lang-panel hidden" id="dict-lang-panel">
                <label for="language-select"><i class="fas fa-language" style="margin-right: 5px;"></i>Idioma:</label>
                <select id="language-select"> <option value="es" selected>Español</option> <option value="en">Inglés</option> </select>
                <div id="dictionary-group" style="display: inline-flex; align-items: center; gap: 1rem;">
                    <label for="dictionary-select"><i class="fas fa-book" style="margin-right: 5px;"></i>Diccionario:</label>
                    <select id="dictionary-select"> <option value="essential" selected>Básico (5k)</option> <option value="complete">Completo (70k)</option> </select>
                </div>
                <div id="loading-indicator" class="hidden">Cargando recursos...</div>
            </div>
            <div class="session-area">
                <div class="control-panel">
                    <div class="timer">00:00</div>
                    <div class="mode-settings">
                        <label for="mode-interval"><i class="fas fa-hourglass-half" style="margin-right: 5px;"></i>Intervalo:</label>
                        <input type="number" id="mode-interval" value="3" min="0.5" step="0.1">
                        <span id="mode-interval-value">3s</span>
                    </div>
                    <div class="controls">
                        <!-- Botón Iniciar ahora deshabilitado por defecto hasta que un modo esté listo -->
                        <button class="btn btn-primary" id="start-btn" onclick="startSession()" disabled> <i class="fas fa-play"></i> Iniciar </button>
                        <button class="btn btn-danger" id="stop-btn" disabled onclick="stopSession()"> <i class="fas fa-stop"></i> Detener </button>
                    </div>
                </div>
                <div class="session-content">
                    <div class="word-display"> [ Esperando Selección ] </div>
                </div>
            </div>
        </div>
      </section>

      <!-- Sección de Ajustes -->
      <section id="settings" class="section" style="display: none;">
         <!-- Contenido de ajustes sin cambios -->
        <h2><i class="fas fa-cogs" style="margin-right: 10px;"></i> Ajustes Generales</h2>
        <div class="settings-panel">
          <div class="setting-group">
            <label for="session-duration"><i class="fas fa-clock" style="margin-right: 5px;"></i>Duración Sesión (min):</label>
            <input type="number" id="session-duration" min="1" max="60" value="3" step="1">
            <span id="duration-value">3m</span>
          </div>
          <div class="setting-group hidden" id="multi-word-group">
            <label for="multi-word-count"><i class="fas fa-cubes" style="margin-right: 5px;"></i>Nº Palabras (Multi):</label>
            <input type="number" id="multi-word-count" min="2" max="15" value="3" step="1">
            <span id="multi-word-count-value">3</span>
          </div>
          <div class="setting-group hidden" id="mixto-word-group">
            <label for="mixto-word-count"><i class="fas fa-brain" style="margin-right: 5px;"></i>Nº Palabras (Mixto):</label>
            <input type="number" id="mixto-word-count" min="1" max="10" value="3" step="1">
            <span id="mixto-word-count-value">3</span>
          </div>
           <!-- Opción para cambiar AKA en Ajustes -->
           <div class="setting-group">
             <label for="change-aka-btn"><i class="fas fa-user-secret" style="margin-right: 5px;"></i> Cambiar AKA:</label>
             <button id="change-aka-btn" class="btn btn-secondary"><i class="fas fa-redo"></i> Cambiar</button>
             <span id="current-aka-display" style="color: var(--text-medium); font-style: italic;"></span>
           </div>
          <div class="setting-group">
             <label><i class="fas fa-info-circle" style="margin-right: 5px;"></i> Información</label>
             <button id="info-btn" class="btn btn-secondary"><i class="fas fa-eye"></i> Mostrar/Ocultar Info</button>
          </div>
          <div id="info-content" style="display:none;">
             <p><strong>FlowTrainer [CYBERPUNK] // V2.1</strong></p>
              <p>Entrena tu fluidez mental y verbal en un entorno cyberpunk inmersivo. Selecciona un modo, ajusta los parámetros y deja que la música te guíe.</p>
               <p>Tu AKA actual es: <strong class="user-aka-placeholder">Ghost</strong>. Puedes cambiarlo en Ajustes.</p>
              <p><strong>Modos:</strong> Palabras Aleatorias, Multi Palabras, Palabras Largas, Modo Libre, Imágenes Aleatorias, Kick Back (preguntas), Mixto (imagen + palabras).</p>
              <p><strong>Idiomas/Diccionarios:</strong> Español (Básico/Completo) e Inglés disponibles para palabras y Kick Back.</p>
              <p>¡Conéctate y fluye!</p>
          </div>
        </div>
      </section>
    </div>
  </main>

  <!-- Reproductor de audio Fijo (sin cambios) -->
  <div id="audio-player">
     <div id="progress-container"> <div id="progress-bar"></div> </div>
     <div class="player-core">
         <div class="player-info"> <div id="time-indicator">00:00 / 00:00</div> </div>
         <div id="audio-controls">
           <button id="prev-track" title="Pista Anterior"> <i class="fas fa-step-backward"></i> </button>
           <button id="play-pause-btn" title="Reproducir/Pausa"> <i class="fas fa-play"></i> <div id="loading-indicator"> <div class="spinner"></div> </div> </button>
           <button id="next-track" title="Siguiente Pista"> <i class="fas fa-step-forward"></i> </button>
         </div>
         <div class="player-side-controls"> <button id="repeat-toggle" title="Repetir">Repeat Off</button> </div>
     </div>
     <audio id="player" preload="metadata"></audio>
   </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    // --- VARIABLES GLOBALES ---
    let wordList = []; let wordHistory = []; let currentMode = null; let sessionActive = false;
    let wordInterval = 3000; let sessionDuration = 3 * 60 * 1000; let wordTimer = null; let sessionTimer = null; // Inicializar timers a null
    let sessionStartTime; let elapsedTime = 0; let firstImage = true;
    let kickbackQuestions = []; const demoWords = ['NEON', 'CYBER', 'FLOW', 'FUTURO', 'CODIGO', 'MATRIX', 'CIRCUITO', 'GLITCH', 'DATA', 'RED', 'IMPLANTE', 'HACK', 'PULSO', 'LASER', 'VR', 'IA', 'DROIDE', 'NAVE', 'CIUDAD', 'NOCHE', 'LLUVIA', 'SOMBRA', 'ESCAPE', 'CONTROL', 'SISTEMA'];
    let originalWords = demoWords;
    let userAKA = "Ghost"; // Valor por defecto inicial
    let isDataLoading = false; // Flag para controlar carga de datos

    // --- URLs (USANDO PROXY CORS) ---
    const proxyUrl = 'https://api.allorigins.win/raw?url=';
    const useProxy = true;
    const essentialDictionaryUrl_original = 'https://papitasfritas.com/5milcastellano.xlsx';
    const completeDictionaryUrl_original = 'https://papitasfritas.com/palabrascastellano.xlsx';
    const englishDictionaryUrl_original = 'https://papitasfritas.com/60milingles.xlsx';
    const kickbackUrl_original = 'https://papitasfritas.com/kickback.xlsx';
    const essentialDictionaryUrl = useProxy ? proxyUrl + encodeURIComponent(essentialDictionaryUrl_original) : './5milcastellano.xlsx';
    const completeDictionaryUrl = useProxy ? proxyUrl + encodeURIComponent(completeDictionaryUrl_original) : './palabrascastellano.xlsx';
    const englishDictionaryUrl = useProxy ? proxyUrl + encodeURIComponent(englishDictionaryUrl_original) : './60milingles.xlsx';
    const kickbackUrl = useProxy ? proxyUrl + encodeURIComponent(kickbackUrl_original) : './kickback.xlsx';


    // --- DOM Element Caching ---
    let startBtn, stopBtn, wordDisplay, timerDisplay, sessionArea, multiWordGroup, multiWordCountInput,
        multiWordCountValue, mixtoWordGroup, mixtoWordCountInput, mixtoWordCountValue, modeIntervalInput,
        modeIntervalValue, sessionDurationInput, durationValue, infoBtn, infoContent, dictLangPanel,
        languageSelect, dictionarySelect, dictionaryGroup, loadingIndicatorEl, homeSection, settingsSection,
        modesGrid, homeTitle, trainingContent, userAkaElement, akaModalOverlay, akaInputElement,
        submitAkaBtn, akaErrorMessage, changeAkaBtn, currentAkaDisplay; // Añadidos elementos del modal y cambio AKA

    // --- Funciones Carga Diccionarios (sin cambios) ---
    async function loadData(url) { try { const response = await fetch(url, { cache: "no-cache" }); if (!response.ok) { if (useProxy && url.startsWith(proxyUrl)) { const originalUrl = decodeURIComponent(url.substring(proxyUrl.length)); console.warn(`Proxy fetch failed for ${originalUrl}, attempting direct fetch...`); const fallbackResponse = await fetch(originalUrl); if (!fallbackResponse.ok) throw new Error(`Direct fetch failed too! HTTP error! status: ${fallbackResponse.status} for ${originalUrl}`); return await fallbackResponse.arrayBuffer(); } throw new Error(`HTTP error! status: ${response.status} for ${url}`); } return await response.arrayBuffer(); } catch (err) { console.error(`Failed to fetch data from ${url}:`, err); throw err; } }
    async function loadSpanishDictionary(fileUrl, colIndex = 0) { try { const data = await loadData(fileUrl); const workbook = XLSX.read(data, { type: 'array' }); const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName]; const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 }); const extracted = rows.map(row => row[colIndex]).filter(w => typeof w === 'string' && w.trim() !== '').map(w => w.toUpperCase()); console.log(`Loaded ${extracted.length} words from ${fileUrl}`); return (extracted.length > 0) ? extracted : demoWords; } catch (err) { console.error("Error processing Spanish dictionary:", fileUrl, err); return demoWords; } }
    async function loadEnglishDictionary() { try { const data = await loadData(englishDictionaryUrl); const workbook = XLSX.read(data, { type: 'array' }); let allWords = []; workbook.SheetNames.forEach(sheetName => { const worksheet = workbook.Sheets[sheetName]; const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 }); const extracted = rows.map(row => row[2]).filter(w => typeof w === 'string' && w.trim() !== '').map(w => w.toUpperCase()); allWords.push(...extracted); }); console.log(`Loaded ${allWords.length} English words`); return (allWords.length > 0) ? allWords : demoWords; } catch (err) { console.error("Error processing English dictionary:", err); return demoWords; } }
    async function loadKickbackQuestions(lang) { try { const data = await loadData(kickbackUrl); const workbook = XLSX.read(data, { type: 'array' }); const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName]; const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false }); let colIndex = (lang === 'es') ? 0 : 1; const extracted = rows.map(row => row[colIndex]).filter(q => typeof q === 'string' && q.trim() !== ''); console.log(`Loaded ${extracted.length} Kickback questions for ${lang}`); return extracted.length > 0 ? extracted : ["¿Pregunta no encontrada?"]; } catch (err) { console.error("Error processing Kickback questions:", err); return ["¿Error al cargar?", "¿Intentar de nuevo?"]; } }


    // --- Funciones AKA y Modal ---
    function showAkaModal(isChange = false) {
        akaErrorMessage.textContent = ''; // Limpiar errores previos
        akaInputElement.value = isChange ? userAKA : ''; // Poner AKA actual si es cambio
        akaInputElement.placeholder = isChange ? userAKA : 'Ingresa tu AKA';
        akaModalOverlay.classList.add('visible');
        akaInputElement.focus(); // Poner foco en el input
    }

    function hideAkaModal() {
        akaModalOverlay.classList.remove('visible');
    }

    function handleAKASubmit() {
        const newAka = akaInputElement.value.trim();
        if (newAka && newAka.length > 0 && newAka.length <= 20) {
            userAKA = newAka;
            localStorage.setItem('flowTrainerUserAKA', userAKA);
            updateAKADisplays();
            hideAkaModal();
             // Si era la primera vez, iniciar carga de datos ahora
             if (!localStorage.getItem('flowTrainerInitialized')) {
                  initializeAppData();
                  localStorage.setItem('flowTrainerInitialized', 'true');
             }
        } else if (newAka.length > 20) {
            akaErrorMessage.textContent = 'Error: AKA demasiado largo (máx 20).';
        } else {
            akaErrorMessage.textContent = 'Error: Ingresa un AKA válido.';
        }
    }

    function updateAKADisplays() {
        if (userAkaElement) {
            userAkaElement.textContent = `// ${userAKA}`;
        }
         // Actualizar placeholders en info y ajustes
        document.querySelectorAll('.user-aka-placeholder').forEach(el => el.textContent = userAKA);
        if(currentAkaDisplay) { // Actualizar display en ajustes
            currentAkaDisplay.textContent = `(Actual: ${userAKA})`;
        }
        // Actualizar mensajes si la sesión no está activa
        if (!sessionActive && wordDisplay) {
             resetSessionVisuals(); // Actualizará el texto [AKA // Listo]
        }
    }

     // --- Función para Carga Inicial de Datos (llamada después del AKA) ---
     async function initializeAppData() {
        console.log("Initializing app data...")
        showLoadingIndicator(true, "Conectando a la red...");
        // No mostrar el panel de idioma/dict aún
        // dictLangPanel.classList.remove('hidden');

        try {
            // Cargar recursos esenciales iniciales (Kickback ES, Diccionario ES Básico)
            const [kickbackEs, essentialEs] = await Promise.all([
                loadKickbackQuestions('es'),
                loadSpanishDictionary(essentialDictionaryUrl, 0)
            ]);
            kickbackQuestions = kickbackEs;
            wordList = essentialEs;
            originalWords = essentialEs;
            console.log("Initial essential resources loaded.");
        } catch (err) {
            console.error("FATAL: Error during initial resource load:", err);
            modesGrid.innerHTML = `<p style='color:var(--error); text-align:center; font-size: 1.2rem;'>Error crítico al cargar datos iniciales. Reinicia o revisa la conexión.</p>`;
        } finally {
            showLoadingIndicator(false);
            // dictLangPanel.classList.add('hidden'); // Mantener oculto hasta seleccionar modo
            resetSessionVisuals(); // Establecer estado inicial visual
        }
     }

    // --- Inicialización y DOMContentLoaded ---
    document.addEventListener('DOMContentLoaded', function() {
        console.log("FlowTrainer CYBERPUNK // DOM Ready - Modal AKA & Fixes");

        // --- Cacheo DOM ---
        homeSection = document.getElementById('home'); settingsSection = document.getElementById('settings'); modesGrid = homeSection.querySelector('.modes'); homeTitle = document.getElementById('home-title'); trainingContent = document.getElementById('training-content'); dictLangPanel = document.getElementById('dict-lang-panel'); sessionArea = trainingContent.querySelector('.session-area'); startBtn = document.getElementById('start-btn'); stopBtn = document.getElementById('stop-btn'); wordDisplay = sessionArea.querySelector('.word-display'); timerDisplay = sessionArea.querySelector('.timer'); multiWordGroup = document.getElementById('multi-word-group'); multiWordCountInput = document.getElementById('multi-word-count'); multiWordCountValue = document.getElementById('multi-word-count-value'); mixtoWordGroup = document.getElementById('mixto-word-group'); mixtoWordCountInput = document.getElementById('mixto-word-count'); mixtoWordCountValue = document.getElementById('mixto-word-count-value'); modeIntervalInput = sessionArea.querySelector('#mode-interval'); modeIntervalValue = sessionArea.querySelector('#mode-interval-value'); sessionDurationInput = document.getElementById('session-duration'); durationValue = document.getElementById('duration-value'); infoBtn = document.getElementById('info-btn'); infoContent = document.getElementById('info-content'); languageSelect = document.getElementById('language-select'); dictionarySelect = document.getElementById('dictionary-select'); dictionaryGroup = document.getElementById('dictionary-group'); loadingIndicatorEl = document.getElementById('loading-indicator');
        userAkaElement = document.getElementById('user-aka');
        akaModalOverlay = document.getElementById('aka-modal-overlay');
        akaInputElement = document.getElementById('aka-input');
        submitAkaBtn = document.getElementById('submit-aka-btn');
        akaErrorMessage = document.getElementById('aka-error-message');
        changeAkaBtn = document.getElementById('change-aka-btn');
        currentAkaDisplay = document.getElementById('current-aka-display');
        const navItems = document.querySelectorAll('.nav-item');
        const modeCards = document.querySelectorAll('.mode-card');
        const sections = document.querySelectorAll('main .section');

        // --- LÓGICA DEL AKA AL CARGAR ---
        let storedAKA = localStorage.getItem('flowTrainerUserAKA');
        if (!storedAKA) {
            showAkaModal(); // Mostrar modal si no hay AKA guardado
        } else {
            userAKA = storedAKA;
            updateAKADisplays();
            initializeAppData(); // Iniciar carga si ya tenemos AKA
             localStorage.setItem('flowTrainerInitialized', 'true'); // Marcar como inicializado
        }
         // Permitir cambiar AKA desde el header
        userAkaElement.addEventListener('click', () => showAkaModal(true));
         // Permitir cambiar AKA desde ajustes
         if(changeAkaBtn) {
             changeAkaBtn.addEventListener('click', () => showAkaModal(true));
         }

        // --- Listeners del Modal AKA ---
        submitAkaBtn.addEventListener('click', handleAKASubmit);
        akaInputElement.addEventListener('keypress', function(event) {
            if (event.key === "Enter") {
                event.preventDefault(); // Evitar submit de formulario si estuviera en uno
                handleAKASubmit();
            }
        });
        // Cerrar modal si se clickea fuera del contenido
        akaModalOverlay.addEventListener('click', function(event) {
          if (event.target === akaModalOverlay) {
             // Solo cerrar si no es la primera vez (para forzar ingreso inicial)
             if (localStorage.getItem('flowTrainerUserAKA')) {
                 hideAkaModal();
             }
          }
        });


        // --- Listeners Generales ---
        infoBtn.addEventListener('click', function() { const isHidden = infoContent.style.display === 'none' || infoContent.style.display === ''; infoContent.style.display = isHidden ? 'block' : 'none'; if (isHidden) { infoContent.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } });
        multiWordCountInput.addEventListener('input', () => { multiWordCountValue.textContent = multiWordCountInput.value; });
        mixtoWordCountInput.addEventListener('input', () => { mixtoWordCountValue.textContent = mixtoWordCountInput.value; });

        // --- Listener Navegación CORREGIDO ---
        navItems.forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const sectionId = this.getAttribute('data-section');
                const isActive = this.classList.contains('active');

                // Si ya está activo y es 'home', forzar reseteo por si acaso
                if (isActive && sectionId === 'home') {
                    console.log("Forcing home reset.");
                    if (sessionActive) stopSession();
                    resetSessionVisuals();
                     // Asegurar que la vista correcta está mostrada
                     modesGrid.classList.remove('hidden');
                     trainingContent.classList.add('hidden');
                     homeTitle.innerHTML = '<i class="fas fa-atom fa-spin" style="--fa-animation-duration: 5s; margin-right: 10px;"></i> Modos de Entrenamiento';
                    return; // No continuar si ya está activo y es home (ya reseteado)
                }
                 if(isActive) return; // Si ya está activo y no es home, no hacer nada

                // Detener sesión si está activa y cambiamos de sección
                if (sessionActive) {
                    stopSession();
                }

                // Actualizar estado activo del menú
                navItems.forEach(link => link.classList.remove('active'));
                this.classList.add('active');

                // Mostrar/Ocultar secciones con animación
                sections.forEach(s => {
                    const isTarget = s.id === sectionId;
                    s.style.display = isTarget ? 'block' : 'none';
                    if (isTarget) {
                        s.style.animation = 'none'; void s.offsetWidth; s.style.animation = 'fadeInSection 0.6s ease-out forwards';
                    }
                });

                // Lógica específica al ir a "Inicio"
                if (sectionId === 'home') {
                    console.log("Navigating to home.");
                    resetSessionVisuals(); // Resetea estado, timers, botones, etc.
                     modesGrid.classList.remove('hidden');
                     trainingContent.classList.add('hidden');
                     homeTitle.innerHTML = '<i class="fas fa-atom fa-spin" style="--fa-animation-duration: 5s; margin-right: 10px;"></i> Modos de Entrenamiento';
                } else if (sectionId === 'settings') {
                     // Actualizar el AKA mostrado en ajustes al navegar ahí
                     if(currentAkaDisplay) currentAkaDisplay.textContent = `(Actual: ${userAKA})`;
                }
            });
        });

        // --- Listener modeCards CORREGIDO ---
        modeCards.forEach(card => {
            card.addEventListener('click', function() {
                // Evitar selección si los datos iniciales aún no han cargado
                if (!localStorage.getItem('flowTrainerInitialized')) {
                    console.warn("Initial data not loaded yet. Cannot select mode.");
                    // Opcional: mostrar un mensaje al usuario
                    return;
                }

                const selectedCard = this;
                const selectedMode = selectedCard.getAttribute('data-mode');
                console.log("Mode selected:", selectedMode);

                // Detener sesión anterior si la hubiera al seleccionar nuevo modo
                if (sessionActive) stopSession();

                modeCards.forEach(c => c.classList.remove('selected-feedback'));
                selectedCard.classList.add('selected-feedback');

                // Deshabilitar botón Iniciar inmediatamente
                startBtn.disabled = true;

                setTimeout(() => {
                    currentMode = selectedMode; // Establecer MODO ANTES de configurar UI
                    modesGrid.classList.add('hidden');
                    configureTrainingUI(currentMode); // Configura UI específica del modo

                    // Cargar datos específicos del modo y LUEGO habilitar Iniciar
                    const needsDataLoading = ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'kickback', 'mixto'].includes(currentMode);

                    if (needsDataLoading) {
                        updateWordSource().then(() => {
                           console.log("Data loaded for mode", currentMode);
                           // Habilitar botón Iniciar SOLO si la carga fue exitosa y no hubo error
                           // El flag isDataLoading ya se habrá puesto a false en updateWordSource
                           if (!isDataLoading) { // Doble check
                               startBtn.disabled = false;
                           }
                        }).catch(err => {
                           console.error("Failed to load data for mode, start button remains disabled.", err);
                           startBtn.disabled = true; // Asegurar que sigue deshabilitado
                        });
                    } else {
                        // Modos sin carga de datos (Libre, Imágenes Aleatorias)
                        resetSessionVisuals(); // Resetear visuales (esto ahora limpia currentMode)
                        currentMode = selectedMode; // Re-establecer modo después de reset
                        configureTrainingUI(currentMode); // Re-configurar UI por si reset la afectó
                        wordDisplay.textContent = (currentMode === 'libre') ? `[ ${userAKA} // MODO LIBRE ]` : '[ Listo para Iniciar ]';
                        startBtn.disabled = false; // Habilitar directamente
                    }

                    setTimeout(() => selectedCard.classList.remove('selected-feedback'), 500);
                }, 300); // Delay para feedback visual
            });
        });

        languageSelect.addEventListener('change', handleLanguageChange);
        dictionarySelect.addEventListener('change', handleDictionaryChange);
        modeIntervalInput.addEventListener('input', function() { /* ... (sin cambios) ... */ let val = parseFloat(this.value); const minVal = 0.5; if (isNaN(val) || val < minVal) { val = minVal; this.value = minVal; } modeIntervalValue.textContent = val.toFixed(1) + "s"; wordInterval = val * 1000; console.log("Interval updated:", wordInterval); if (sessionActive && wordTimer && !['libre', 'imagenes-aleatorias', 'mixto'].includes(currentMode)) { clearInterval(wordTimer); wordTimer = setInterval(showNextContent, wordInterval); } });
        sessionDurationInput.addEventListener('input', function() { /* ... (sin cambios) ... */ const value = parseInt(this.value, 10); const minDuration = 1, maxDuration = 60; let finalValue = value; if (isNaN(value) || value < minDuration) finalValue = minDuration; else if (value > maxDuration) finalValue = maxDuration; this.value = finalValue; sessionDuration = finalValue * 60 * 1000; durationValue.textContent = `${finalValue}m`; });

        // Carga inicial movida a initializeAppData, llamada después del manejo del AKA

    }); // Fin DOMContentLoaded

    // --- Funciones Configuración UI y Carga ---
    function configureTrainingUI(mode) {
        // ... (igual que antes, configura título, visibilidad paneles, intervalo default) ...
        console.log("Configuring UI for mode:", mode);
        let modeTitleText = "Entrenamiento";
        const modeCard = document.querySelector(`.mode-card[data-mode="${mode}"]`);
        if (modeCard) { modeTitleText = modeCard.querySelector('h3').textContent; }
        homeTitle.innerHTML = `<i class="fas ${modeCard ? modeCard.querySelector('i').className.split(' ')[1] : 'fa-cogs'} fa-spin" style="--fa-animation-duration: 4s; margin-right: 10px;"></i> Modo: ${modeTitleText}`;
        const needsDictLangPanel = ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'kickback', 'mixto'].includes(mode);
        dictLangPanel.classList.toggle('hidden', !needsDictLangPanel);
        if (needsDictLangPanel) {
            dictionaryGroup.style.display = (mode === 'kickback' || languageSelect.value === 'en') ? 'none' : 'inline-flex';
            dictionarySelect.disabled = (languageSelect.value === 'en');
        }
        multiWordGroup.classList.toggle('hidden', mode !== 'multi-palabras');
        mixtoWordGroup.classList.toggle('hidden', mode !== 'mixto');
        if (mode === "multi-palabras") modeIntervalInput.value = 10;
        else if (mode === "imagenes-aleatorias" || mode === "mixto") modeIntervalInput.value = 5;
        else modeIntervalInput.value = 3;
        modeIntervalInput.dispatchEvent(new Event('input'));
        trainingContent.classList.remove('hidden');
        trainingContent.style.animation = 'none'; void trainingContent.offsetWidth; trainingContent.style.animation = 'fadeInSection 0.5s ease-out forwards';
        // NO reseteamos visuales aquí, se hace antes o después de cargar datos
    }

    // --- resetSessionVisuals CORREGIDO ---
    function resetSessionVisuals() {
        console.log("Resetting session visuals.");
        // Limpiar timers ANTES de cambiar estados
        clearInterval(sessionTimer); sessionTimer = null;
        clearInterval(wordTimer); wordTimer = null;

        if (sessionActive) {
             sessionActive = false; // Marcar como inactiva ANTES de cambiar botones
        }

        // Resetear estado de botones y UI
        startBtn.disabled = true; // Deshabilitado por defecto hasta que se seleccione modo y carguen datos
        stopBtn.disabled = true;
        sessionArea.classList.remove('session-active');
        timerDisplay.textContent = "00:00";
        wordDisplay.textContent = `[ ${userAKA} // Listo ]`;
        wordDisplay.classList.remove('glitchy', 'content-changing', 'content-entering');
        wordDisplay.style.animation = 'none'; void wordDisplay.offsetWidth;
        wordDisplay.style.opacity = '1'; wordDisplay.style.transform = 'translateY(0) scale(1)';

        currentMode = null; // IMPORTANTE: Limpiar modo actual al resetear

        // Opcional: ocultar el panel de idioma/diccionario si no hay modo
         if (!currentMode && !dictLangPanel.classList.contains('hidden')) {
             // dictLangPanel.classList.add('hidden'); // Ocultar si no hay modo seleccionado
         }
    }

    // --- showLoadingIndicator MODIFICADO ---
    function showLoadingIndicator(show, text = "Cargando...") {
        if (!loadingIndicatorEl) return;
        isDataLoading = show; // Actualizar flag global

        // Mostrar panel si se necesita y está oculto
         if (show && dictLangPanel.classList.contains('hidden') && ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'kickback', 'mixto'].includes(currentMode) ) {
              dictLangPanel.classList.remove('hidden');
         }

        loadingIndicatorEl.textContent = text;
        loadingIndicatorEl.classList.toggle('hidden', !show);

        // Deshabilitar controles mientras carga
        languageSelect.disabled = show;
        const disableDict = show || languageSelect.value === 'en' || currentMode === 'kickback';
        dictionarySelect.disabled = disableDict;
        // Deshabilitar botón Iniciar MIENTRAS carga
        startBtn.disabled = show;

        // Ocultar panel si ya no se necesita
        if (!show) {
            const needsDictLangPanel = currentMode && ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'kickback', 'mixto'].includes(currentMode);
            if (!needsDictLangPanel && !dictLangPanel.classList.contains('hidden')) {
                 dictLangPanel.classList.add('hidden');
            }
             // NO habilitamos startBtn aquí, se hace en updateWordSource o en el listener de modeCards
        }
    }

    async function handleLanguageChange() { /* ... (sin cambios) ... */ const lang = languageSelect.value; console.log("Language changed to:", lang); startBtn.disabled = true; /* Deshabilitar al cambiar */ if (['palabras-aleatorias','multi-palabras','palabras-largas','mixto', 'kickback'].includes(currentMode)) { await updateWordSource(); } dictionaryGroup.style.display = (lang === 'es' && currentMode !== 'kickback') ? 'inline-flex' : 'none'; dictionarySelect.disabled = (lang === 'en'); }
    async function handleDictionaryChange() { /* ... (sin cambios) ... */ console.log("Dictionary changed:", dictionarySelect.value); startBtn.disabled = true; /* Deshabilitar al cambiar */ if (languageSelect.value === 'es' && ['palabras-aleatorias','multi-palabras','palabras-largas','mixto'].includes(currentMode)) { await updateWordSource(); } }

    // --- updateWordSource CORREGIDO ---
    async function updateWordSource() {
        // Añadir return de promesa para poder usar .then()/.catch()
        return new Promise(async (resolve, reject) => {
            if (!currentMode) {
                console.warn("updateWordSource called without currentMode.");
                return reject(new Error("No mode selected"));
            }
            const lang = languageSelect.value;
            const dictType = dictionarySelect.value;
            showLoadingIndicator(true, `Cargando ${currentMode === 'kickback' ? 'preguntas' : 'palabras'} (${lang})...`);

            try {
                if (currentMode === 'kickback') { kickbackQuestions = await loadKickbackQuestions(lang); wordList = []; originalWords = []; }
                else if (['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'mixto'].includes(currentMode)) {
                    if (lang === 'en') { const englishWords = await loadEnglishDictionary(); wordList = englishWords; originalWords = englishWords; }
                    else { let fileUrl, colIndex; if (dictType === 'complete') { fileUrl = completeDictionaryUrl; colIndex = 1; } else { fileUrl = essentialDictionaryUrl; colIndex = 0; } const spanishWords = await loadSpanishDictionary(fileUrl, colIndex); wordList = spanishWords; originalWords = spanishWords; }
                    kickbackQuestions = [];
                } else { wordList = []; originalWords = []; kickbackQuestions = []; }

                resetSessionVisuals(); // Resetear visuales DESPUÉS de cargar datos con éxito
                configureTrainingUI(currentMode); // Reconfigurar UI por si reset la afectó
                wordDisplay.textContent = `[ ${userAKA} // Listo ]`; // Poner texto listo
                showLoadingIndicator(false); // Ocultar indicador al final
                startBtn.disabled = false; // *** HABILITAR BOTÓN START AQUÍ ***
                resolve(); // Indicar éxito

            } catch (error) {
                console.error("Error updating word source:", error);
                wordDisplay.textContent = "[ Error de Carga ]";
                if (['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'mixto'].includes(currentMode)) { wordList = [...demoWords]; originalWords = [...demoWords]; } else { wordList = []; originalWords = []; }
                if (currentMode === 'kickback') { kickbackQuestions = ["Error cargando."]; }
                resetSessionVisuals(); // Resetear visuales también en caso de error
                 wordDisplay.textContent = "[ Error de Carga ]"; // Mostrar error después de reset
                showLoadingIndicator(false); // Ocultar indicador
                startBtn.disabled = true; // *** ASEGURAR BOTÓN START DESHABILITADO EN ERROR ***
                reject(error); // Indicar fallo
            }
        });
    }


    // --- startSession CORREGIDO ---
    function startSession() {
        // Comprobaciones robustas antes de iniciar
        if (sessionActive) { console.warn("Session already active."); return; }
        if (!currentMode) { console.warn("Cannot start session: No mode selected."); return; }
        if (isDataLoading) { console.warn("Cannot start session: Data is still loading."); return; }

        // Comprobar si el modo actual necesita datos y si están cargados
        const needsWordList = ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'mixto'].includes(currentMode);
        const needsKickback = currentMode === 'kickback';

        if (needsWordList && (!wordList || wordList.length === 0)) {
            console.error("Cannot start session: Word list is empty for the current mode.");
            wordDisplay.textContent = "[ Error: Datos no cargados ]";
            return;
        }
        if (needsKickback && (!kickbackQuestions || kickbackQuestions.length === 0)) {
            console.error("Cannot start session: Kickback questions not loaded.");
             wordDisplay.textContent = "[ Error: Datos no cargados ]";
            return;
        }

        console.log(`Attempting to start session: Mode=${currentMode}, Interval=${wordInterval}ms, Duration=${sessionDuration}ms`);

        // Limpiar timers por si acaso (aunque resetSessionVisuals debería hacerlo)
        clearInterval(sessionTimer); sessionTimer = null;
        clearInterval(wordTimer); wordTimer = null;

        sessionActive = true;
        startBtn.disabled = true; // Deshabilitar Iniciar
        stopBtn.disabled = false; // Habilitar Detener
        sessionArea.classList.add('session-active');
        wordHistory = [];
        elapsedTime = 0;
        sessionStartTime = Date.now();

        // Iniciar timer de sesión
        sessionTimer = setInterval(updateSessionTime, 1000);
        updateSessionTime(); // Llamada inicial

        // Lógica inicial de contenido según el modo
        if (currentMode === "imagenes-aleatorias" || currentMode === "mixto") {
            firstImage = true;
            wordDisplay.innerHTML = '<div class="spinner" style="margin: auto;"></div>';
            showNextContent(); // Cargar la primera imagen/contenido mixto
        } else if (currentMode === "libre") {
            wordDisplay.textContent = `[ ${userAKA} // MODO LIBRE ]`;
            animateWordDisplay(wordDisplay);
        } else {
            showNextContent(); // Mostrar el primer contenido inmediatamente
            if(wordInterval > 0) {
                wordTimer = setInterval(showNextContent, wordInterval);
            }
        }
        console.log("Session successfully started.");
    }

    // --- stopSession CORREGIDO ---
    function stopSession() {
        if (!sessionActive) return;
        console.log("Stopping session.");

        // Limpiar timers ANTES de cambiar estados
        clearInterval(sessionTimer); sessionTimer = null;
        clearInterval(wordTimer); wordTimer = null;

        sessionActive = false;
        startBtn.disabled = false; // Habilitar Iniciar (si hay un modo válido seleccionado)
        stopBtn.disabled = true; // Deshabilitar Detener
        sessionArea.classList.remove('session-active');

        wordDisplay.textContent = `[ ${userAKA} // Sesión Finalizada ]`;
        wordDisplay.classList.remove('glitchy', 'content-changing', 'content-entering');
        animateWordDisplay(wordDisplay);

        // Habilitar Iniciar solo si un modo está seleccionado y listo
        if (!currentMode || isDataLoading) {
             startBtn.disabled = true;
        } else {
            // Comprobar si los datos necesarios para el modo actual están cargados
             const needsWordList = ['palabras-aleatorias', 'multi-palabras', 'palabras-largas', 'mixto'].includes(currentMode);
             const needsKickback = currentMode === 'kickback';
             const dataReady = (needsWordList && wordList && wordList.length > 0) ||
                               (needsKickback && kickbackQuestions && kickbackQuestions.length > 0) ||
                               (!needsWordList && !needsKickback); // Modos sin datos

             startBtn.disabled = !dataReady;
        }
    }

    // showNextContent (sin cambios funcionales, solo contexto)
     function showNextContent() {
        if (!sessionActive) { clearInterval(wordTimer); wordTimer = null; return; } // Detener timer si sesión ya no está activa
        if (elapsedTime >= sessionDuration) { stopSession(); return; }
        // console.log("Generating content for mode:", currentMode); // Opcional: reducir logs
        wordDisplay.classList.add('content-changing'); wordDisplay.classList.remove('content-entering');
        setTimeout(() => {
            if (!sessionActive) return; // Doble check
            wordDisplay.classList.remove('glitchy'); wordDisplay.innerHTML = '';

            // --- Lógica de modos (sin cambios) ---
            if (currentMode === "libre") { wordDisplay.textContent = `[ ${userAKA} // MODO LIBRE ]`; animateWordDisplay(wordDisplay); return; }
            if (currentMode === "imagenes-aleatorias") { wordDisplay.innerHTML = '<div class="spinner" style="margin: auto;"></div>'; const img = new Image(); const r = Date.now(); img.src = `https://picsum.photos/720/480?random=${r}`; img.alt = "Imagen Aleatoria"; img.style.cssText = 'max-width:100%; max-height:100%; border-radius:4px; box-shadow:var(--shadow-depth-1); opacity: 0; transition: opacity 0.4s ease 0.1s;'; img.onload = () => { if (!sessionActive) return; wordDisplay.innerHTML = ''; wordDisplay.appendChild(img); void img.offsetWidth; img.style.opacity = '1'; if (firstImage) { firstImage = false; clearInterval(wordTimer); if (wordInterval > 0) wordTimer = setInterval(showNextContent, wordInterval); } }; img.onerror = () => { if (!sessionActive) return; wordDisplay.textContent = '[ Error Imagen ]'; animateWordDisplay(wordDisplay); if (firstImage) { firstImage = false; clearInterval(wordTimer); if (wordInterval > 0) wordTimer = setInterval(showNextContent, wordInterval); } }; return; }
            if (currentMode === "mixto") { wordDisplay.innerHTML = '<div class="spinner" style="margin: auto;"></div>'; const img = new Image(); const r = Date.now(); img.src = `https://picsum.photos/720/480?random=${r}`; img.alt = "Imagen Aleatoria"; img.style.cssText = 'max-width:80%; max-height:60%; border-radius:4px; box-shadow:var(--shadow-depth-1); margin-bottom:1.5rem; opacity: 0; transition: opacity 0.4s ease 0.1s;'; img.onload = () => { if (!sessionActive) return; let c = parseInt(mixtoWordCountInput.value,10)||3; c=Math.max(1,Math.min(c,10)); let l=(originalWords&&originalWords.length>0)?[...originalWords]:[...demoWords]; let w=[]; if(l.length>0){for(let i=0;i<c;i++){if(l.length===0)break; const x=Math.floor(Math.random()*l.length); w.push(l.splice(x,1)[0]);}}else{w=['[NO DATA]'];} const d=w.join(" / "); wordDisplay.innerHTML = `<div style="display:flex; flex-direction:column; align-items:center; width: 100%; height: 100%; justify-content: center; opacity: 0;" class="mixto-content-wrapper"> ${img.outerHTML} <div style="font-size:1.8rem; font-weight: 500; color: var(--neon-cyan); text-shadow: var(--shadow-neon-cyan);">${d}</div> </div>`; const wr=wordDisplay.querySelector('.mixto-content-wrapper'); const li=wordDisplay.querySelector('img'); if(li)li.style.opacity='1'; if(wr){void wr.offsetWidth; wr.style.opacity='1'; wr.style.transition='opacity 0.4s ease-out 0.2s';} if(firstImage){firstImage=false; clearInterval(wordTimer); if(wordInterval>0)wordTimer=setInterval(showNextContent,wordInterval);} }; img.onerror = () => { if (!sessionActive) return; wordDisplay.textContent = '[ Error Imagen Mixto ]'; animateWordDisplay(wordDisplay); if (firstImage) { firstImage = false; clearInterval(wordTimer); if (wordInterval > 0) wordTimer = setInterval(showNextContent, wordInterval); } }; return; }
            if (currentMode === "kickback") { if (kickbackQuestions && kickbackQuestions.length > 0) { const x = Math.floor(Math.random() * kickbackQuestions.length); wordDisplay.textContent = kickbackQuestions[x]; } else { wordDisplay.textContent = "[ No hay preguntas ]"; } }
            else { let l = (originalWords && originalWords.length > 0) ? [...originalWords] : [...demoWords]; if (currentMode === "palabras-largas") { let lg = l.filter(w => w.length >= 9); l = lg.length > 0 ? lg : l; } if (l.length === 0) { wordDisplay.textContent = "[ Diccionario Vacío ]"; } else if (currentMode === "multi-palabras") { const c = Math.min(Math.max(parseInt(multiWordCountInput.value,10)||2,2),15); let w=[]; let a=[...l]; for(let i=0;i<c;i++){if(a.length===0)break; const x=Math.floor(Math.random()*a.length); w.push(a.splice(x,1)[0]);} wordDisplay.textContent = w.join(" / "); } else { const x = Math.floor(Math.random()*l.length); wordDisplay.textContent = l[x]; } }
            animateWordDisplay(wordDisplay);
        }, 200);
    }

    // animateWordDisplay (sin cambios)
    function animateWordDisplay(elem, useContainerAnimation = true) { elem.classList.remove('content-changing'); if (useContainerAnimation) { elem.classList.add('content-entering'); elem.addEventListener('animationend', () => { if (elem.classList.contains('content-entering')) { elem.classList.remove('content-entering'); } }, { once: true }); } else { elem.style.opacity = '1'; elem.style.transform = 'translateY(0) scale(1)'; } }

    // updateSessionTime (sin animación de color)
    function updateSessionTime() {
        if (!sessionActive || !sessionStartTime) return;
        elapsedTime = Date.now() - sessionStartTime;
        if (elapsedTime >= sessionDuration) { elapsedTime = sessionDuration; updateTimerDisplay(); stopSession(); return; }
        updateTimerDisplay();
    }
    // updateTimerDisplay (sin cambios)
    function updateTimerDisplay() { const tS = Math.floor(elapsedTime / 1000); const min = Math.floor(tS / 60); const sec = tS % 60; timerDisplay.textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`; }

  </script>

  <!-- Código Reproductor Música (sin cambios) -->
   <script>
     const archivePlaylist = [ "https://archive.org/download/beat-61/beat%20%281%29.mp3", "https://archive.org/download/beat-61/beat%20%2810%29.mp3", "https://archive.org/download/beat-61/beat%20%28100%29.mp3", "https://archive.org/download/beat-61/beat%20%28101%29.mp3", "https://archive.org/download/beat-61/beat%20%28102%29.mp3", "https://archive.org/download/beat-61/beat%20%28103%29.mp3", "https://archive.org/download/beat-61/beat%20%28104%29.mp3", "https://archive.org/download/beat-61/beat%20%28105%29.mp3", "https://archive.org/download/beat-61/beat%20%28106%29.mp3", "https://archive.org/download/Free_Beats_1/WipEout_XL_OST_Future_Sound_Of_London_We_Have_Explosive.mp3", "https://archive.org/download/Free_Beats_1/WipEout_XL_OST_The_Prodigy_Firestarter_Instrumental.mp3", "https://archive.org/download/hardtrapbeat/Hard%20Trap%20Beat%20-%20%27MASAYUKI%27%20_%20Dark%20Japanese%20Type%20Beat%20_%20Trap%20Instrumental%202021.mp3", "https://archive.org/download/royalty-free-music-ASSIGNMENT/ASSIGNMENT%20-%20Atmospheric%20Cyberpunk%20Music%20_%20Royalty%20Free%20Music.mp3" ];
     function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
     shuffleArray(archivePlaylist); let currentTrackIndex = 0; const player = document.getElementById('player'); const playPauseBtn = document.getElementById('play-pause-btn'); const prevTrackBtn = document.getElementById('prev-track'); const nextTrackBtn = document.getElementById('next-track'); const repeatToggle = document.getElementById('repeat-toggle'); const progressBar = document.getElementById('progress-bar'); const progressContainer = document.getElementById('progress-container'); const timeIndicator = document.getElementById('time-indicator'); const audioPlayer = document.getElementById('audio-player'); const playPauseIcon = playPauseBtn.querySelector('i'); const loadingIndicatorPlayer = playPauseBtn.querySelector('#loading-indicator'); let repeat = false; let isDragging = false; let playAfterLoad = false;
     function loadInitialTrack() { if (archivePlaylist.length > 0) { player.src = archivePlaylist[currentTrackIndex]; player.load(); } else { console.warn("Audio playlist empty."); [playPauseBtn, prevTrackBtn, nextTrackBtn, repeatToggle].forEach(btn => btn.disabled = true); } }
     function loadTrack(index, autoPlay = false) { if (index < 0 || index >= archivePlaylist.length) { index = (index + archivePlaylist.length) % archivePlaylist.length; } currentTrackIndex = index; player.src = archivePlaylist[currentTrackIndex]; player.load(); playAfterLoad = autoPlay; playPauseBtn.classList.add('loading'); playPauseBtn.disabled = true; }
     function playTrack() { const pP = player.play(); if (pP !== undefined) { pP.then(_ => { playPauseIcon.className = 'fas fa-pause'; playPauseBtn.title = "Pausa"; }).catch(e => { console.error("Audio play failed:", e); playPauseIcon.className = 'fas fa-play'; playPauseBtn.title = "Reproducir"; playPauseBtn.classList.remove('loading'); playPauseBtn.disabled = false; playAfterLoad = false; }); } else { playPauseIcon.className = 'fas fa-pause'; playPauseBtn.title = "Pausa"; } }
     function pauseTrack() { player.pause(); playPauseIcon.className = 'fas fa-play'; playPauseBtn.title = "Reproducir"; }
     function togglePlayPause() { if (!player.src) { loadInitialTrack(); playAfterLoad = true; return; } if (player.paused) { playTrack(); } else { pauseTrack(); } }
     function nextTrack() { const nI = (currentTrackIndex + 1) % archivePlaylist.length; loadTrack(nI, !player.paused); }
     function prevTrack() { const nI = (currentTrackIndex - 1 + archivePlaylist.length) % archivePlaylist.length; loadTrack(nI, !player.paused); }
     function toggleRepeat() { repeat = !repeat; repeatToggle.classList.toggle('active', repeat); repeatToggle.textContent = repeat ? "Repeat On" : "Repeat Off"; player.loop = repeat; }
     playPauseBtn.addEventListener('click', togglePlayPause); nextTrackBtn.addEventListener('click', nextTrack); prevTrackBtn.addEventListener('click', prevTrack); repeatToggle.addEventListener('click', toggleRepeat);
     player.addEventListener('loadedmetadata', () => { updateProgress(); }); player.addEventListener('timeupdate', () => { if (!isDragging) { updateProgress(); } }); player.addEventListener('ended', () => { if (!repeat) { nextTrack(); } else { player.play(); } }); player.addEventListener('error', (e) => { console.error("Audio player error:", e); playPauseBtn.classList.remove('loading'); playPauseBtn.disabled = false; playPauseIcon.className = 'fas fa-play'; playPauseBtn.title = "Reproducir"; setTimeout(nextTrack, 1500); }); player.addEventListener('waiting', () => { playPauseBtn.classList.add('loading'); playPauseBtn.disabled = true; }); player.addEventListener('canplay', () => { playPauseBtn.classList.remove('loading'); playPauseBtn.disabled = false; if (playAfterLoad) { playTrack(); playAfterLoad = false; } else if (!player.paused) { playPauseIcon.className = 'fas fa-pause'; playPauseBtn.title = "Pausa"; } }); player.addEventListener('playing', () => { playPauseBtn.classList.remove('loading'); playPauseIcon.className = 'fas fa-pause'; playPauseBtn.title = "Pausa"; playPauseBtn.disabled = false; }); player.addEventListener('pause', () => { playPauseBtn.classList.remove('loading'); playPauseIcon.className = 'fas fa-play'; playPauseBtn.title = "Reproducir"; });
     progressContainer.addEventListener('click', seek); progressContainer.addEventListener('mousedown', (e) => { isDragging = true; seek(e); document.addEventListener('mousemove', dragSeek); document.addEventListener('mouseup', stopDragSeek); });
     function seek(e) { if (!player.duration || isNaN(player.duration)) return; const r = progressContainer.getBoundingClientRect(); const oX = e.clientX - r.left; const w = r.width; const p = Math.max(0, Math.min(1, oX / w)); const sT = p * player.duration; player.currentTime = sT; updateProgress(); }
     function dragSeek(e) { if (!isDragging || !player.duration || isNaN(player.duration)) return; const r = progressContainer.getBoundingClientRect(); const oX = e.clientX - r.left; const w = r.width; const p = Math.max(0, Math.min(1, oX / w)); progressBar.style.width = `${p * 100}%`; const dTF = formatTime(p * player.duration); const tDF = formatTime(player.duration); timeIndicator.textContent = `${dTF} / ${tDF}`; }
     function stopDragSeek(e) { if (!isDragging) return; isDragging = false; seek(e); document.removeEventListener('mousemove', dragSeek); document.removeEventListener('mouseup', stopDragSeek); }
     function updateProgress() { if (!player.duration || isNaN(player.duration)) { progressBar.style.width = "0%"; timeIndicator.textContent = "00:00 / --:--"; return; } const p = (player.currentTime / player.duration) * 100; progressBar.style.width = `${p}%`; const cTF = formatTime(player.currentTime); const tDF = formatTime(player.duration); timeIndicator.textContent = `${cTF} / ${tDF}`; }
     function formatTime(s) { if (isNaN(s) || s < 0) return '00:00'; const min = Math.floor(s / 60); const sec = Math.floor(s % 60); return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`; }
     document.addEventListener('DOMContentLoaded', loadInitialTrack);
   </script>

</body>
</html>
